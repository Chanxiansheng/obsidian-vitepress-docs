import{_ as t,c as l,o as e,ae as a}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"GitDiff 算法","description":"","frontmatter":{},"headers":[],"relativePath":"工具说明书/Git/GitDiff算法.md","filePath":"工具说明书/Git/GitDiff算法.md"}'),d={name:"工具说明书/Git/GitDiff算法.md"};function r(n,i,o,f,s,u){return e(),l("div",null,i[0]||(i[0]=[a('<h1 id="gitdiff-算法" tabindex="-1">GitDiff 算法 <a class="header-anchor" href="#gitdiff-算法" aria-label="Permalink to &quot;GitDiff 算法&quot;">​</a></h1><h2 id="基础分类" tabindex="-1">基础分类 <a class="header-anchor" href="#基础分类" aria-label="Permalink to &quot;基础分类&quot;">​</a></h2><ul><li>精确匹配类：KMP、Boyer-Moore、Rabin-Karp</li><li>序列差异类：LCS、Myers、Patience diff（Git）</li><li>序列重排类：LIS（Vue）、最小编辑距离（Levenshtein）</li></ul><h2 id="git-使用的-diff-算法-myers-diff" tabindex="-1">Git 使用的 Diff 算法（Myers diff） <a class="header-anchor" href="#git-使用的-diff-算法-myers-diff" aria-label="Permalink to &quot;Git 使用的 Diff 算法（Myers diff）&quot;">​</a></h2><ul><li>类型：最短编辑脚本（O(ND)）</li><li>实现：基于最长公共子序列（LCS）</li><li>单位：默认按“行”对比，也支持字节流</li><li>特点：</li><li>输出最小的添加/删除操作集合</li><li>精确找出文本内容变更</li><li>可应用于生成 patch、还原历史</li><li>Git 使用模块：xdiff（xdiffi.c）</li></ul><h2 id="vue-3-使用的-diff-算法-lis" tabindex="-1">Vue 3 使用的 Diff 算法（LIS） <a class="header-anchor" href="#vue-3-使用的-diff-算法-lis" aria-label="Permalink to &quot;Vue 3 使用的 Diff 算法（LIS）&quot;">​</a></h2><ul><li>类型：最长递增子序列（Longest Increasing Subsequence）</li><li>实现：贪心 + 二分查找，O(n log n)</li><li>单位：VNode 列表中的 key 索引</li><li>特点： <ul><li>用于 DOM diff 中最小化移动</li><li>并不关心内容变化，只关心顺序是否一致</li><li>优化 DOM patch 性能</li></ul></li></ul><h2 id="lcs-算法-longest-common-subsequence" tabindex="-1">LCS 算法（Longest Common Subsequence） <a class="header-anchor" href="#lcs-算法-longest-common-subsequence" aria-label="Permalink to &quot;LCS 算法（Longest Common Subsequence）&quot;">​</a></h2><ul><li>类型：动态规划，时间复杂度 O(n^2)，可优化为 O(n log n)</li><li>应用场景：文本对比、DNA 序列比对、Git diff 核心思想</li><li>特点： <ul><li>找出两个序列中公共且顺序一致的最长子序列</li><li>不是“连续子串”，而是“子序列”</li></ul></li></ul><h2 id="lis-算法-longest-increasing-subsequence" tabindex="-1">LIS 算法（Longest Increasing Subsequence） <a class="header-anchor" href="#lis-算法-longest-increasing-subsequence" aria-label="Permalink to &quot;LIS 算法（Longest Increasing Subsequence）&quot;">​</a></h2><ul><li>类型：优化版动态规划 + 贪心，时间复杂度 O(n log n)</li><li>应用场景：Vue diff、最小序列重排</li><li>特点： <ul><li>在一个数组中找出最长单调递增的索引子序列</li><li>用于找出无需移动的 DOM 节点</li></ul></li></ul><h2 id="kmp-算法-knuth–morris–pratt" tabindex="-1">KMP 算法（Knuth–Morris–Pratt） <a class="header-anchor" href="#kmp-算法-knuth–morris–pratt" aria-label="Permalink to &quot;KMP 算法（Knuth–Morris–Pratt）&quot;">​</a></h2><ul><li>类型：前缀函数优化的字符串匹配算法，O(m + n)</li><li>应用场景：字符串搜索、正则预处理</li><li>特点： <ul><li>精确匹配模式串，不适用于结构性 diff</li><li>不能对比整体差异，只能判断“包含关系”</li></ul></li></ul><h2 id="对比表格-简化" tabindex="-1">对比表格（简化） <a class="header-anchor" href="#对比表格-简化" aria-label="Permalink to &quot;对比表格（简化）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>算法</th><th>输入</th><th>输出</th><th>时间复杂度</th><th>应用</th></tr></thead><tbody><tr><td>KMP</td><td>模式串 + 文本</td><td>匹配位置</td><td>O(m + n)</td><td>字符串搜索</td></tr><tr><td>LCS</td><td>序列 A + B</td><td>公共子序列</td><td>O(n^2)</td><td>Git diff</td></tr><tr><td>Myers</td><td>序列 A + B</td><td>最短编辑路径</td><td>O(ND)</td><td>Git (xdiff)</td></tr><tr><td>LIS</td><td>单一数组</td><td>递增子序列索引</td><td>O(n log n)</td><td>Vue 3 DOM diff</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>Git 追求“精确记录变更”，使用 LCS/Myers 算法</li><li>Vue 追求“最小更新成本”，使用 LIS 重排优化</li><li>diff 类算法普遍目标是：找出结构差异，用于同步/还原/渲染</li></ul>',17)]))}const m=t(d,[["render",r]]);export{c as __pageData,m as default};
