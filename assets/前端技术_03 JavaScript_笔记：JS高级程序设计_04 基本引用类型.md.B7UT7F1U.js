import{_ as e,c as d,o as i,ag as a}from"./chunks/framework.-ewJmwvT.js";const k=JSON.parse('{"title":"04 基本引用类型","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/04 基本引用类型.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/04 基本引用类型.md"}'),s={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/04 基本引用类型.md"};function o(l,t,r,n,c,h){return i(),d("div",null,t[0]||(t[0]=[a(`<h1 id="_04-基本引用类型" tabindex="-1">04 基本引用类型 <a class="header-anchor" href="#_04-基本引用类型" aria-label="Permalink to &quot;04 基本引用类型&quot;">​</a></h1><div class="info custom-block github-alert"><p class="custom-block-title">+ 对比 Java 、JS 、C++ 、Python 的面向对象实现</p><p>Java 依赖于编译好的类文件并在运行时加载（<strong>编译型</strong>）；而 JavaScript 则是根据需要在运行时动态地在内存中构建对象及其继承关系（<strong>解释型</strong>）。</p><ul><li><strong>静态 vs 动态</strong>：Java 依赖于编译时生成的 <code>.class</code> 文件来定义类结构，这是一种相对静态的方式。而 JavaScript 则完全依赖于运行时的原型链来动态地构建对象间的关系。</li><li><strong>类加载机制</strong>：Java 有一个复杂的类加载机制，包括类加载器、双亲委派模型等，保证了类的安全性和唯一性。JavaScript 则不需要这样的机制，因为它不涉及跨模块或跨包的类加载问题。</li><li><strong>继承实现</strong>：Java 通过类继承实现代码复用，而 JavaScript 通过原型链实现类似的继承效果。两者虽然都能达到相似的结果，但在实现细节上有显著的不同。</li></ul><p>在 C++ 中，类结构在编译后会形成相互关联的机器码，这些机器码包含了类成员变量的数据以及成员函数的指令。当程序运行时，这些代码和数据会在内存中被加载并执行。</p><p>Python 中类本身是<strong>type 类的实例</strong>，类的定义在运行时动态生成类对象，并存储在内存中。Python 的继承是<strong>基于类层级和 MRO 的静态链式查找</strong>。</p></div><p>引用值（或者对象）是某个特定==引用类型==（原型对象）的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。</p><p>对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。<br><code>let now = new Date();</code></p><h2 id="date-类型" tabindex="-1">Date 类型 <a class="header-anchor" href="#date-类型" aria-label="Permalink to &quot;Date 类型&quot;">​</a></h2><p>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。<br> 创建：<code>let now = new Date();</code></p><h3 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h3><blockquote><p>[!example]+ Date.parse<br><code>Date.parse()</code> 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。</p><ul><li>所有实现都必须支持下列日期格式： <ul><li>“月/日/年”，如 &quot;5/23/2019&quot;；</li><li>“月名 日, 年”，如 &quot;May 23, 2019&quot;；</li><li>“周几 月名 日 年 时: 分: 秒 时区”，如 &quot;Tue May 23 2019 00:00:00 GMT-0700&quot;；</li><li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）。</li></ul></li><li>如果传给 Date.parse() 的字符串并不表示日期，则该方法会返回 NaN。</li><li>如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。</li></ul></blockquote><blockquote><p>[!example]+ Date.UTC<br><code>Date.UTC()</code> 方法也返回日期的毫秒表示。<br> 参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// GMT 时间2005 年5 月5 日下午5 点55 分55 秒</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allFives </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UTC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2005</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><p>Date.UTC() 也会被 Date 构造函数隐式调用，但有这种情况下创建的是本地日期，不是 GMT 日期。<br><code>let allFives = new Date(2005, 4, 5, 17, 55, 55);</code></p></blockquote><blockquote><p>[!example]+ Date.now<br> 返回表示方法执行时日期和时间的毫秒数。</p></blockquote><h3 id="继承方法" tabindex="-1">继承方法 <a class="header-anchor" href="#继承方法" aria-label="Permalink to &quot;继承方法&quot;">​</a></h3><p>Date 类型重写了 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法。</p><ul><li><code>toLocaleString()</code> 方法返回与浏览器运行的本地环境一致的日期和时间。</li><li><code>toString()</code> 方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。</li><li><code>valueOf()</code> 方法根本就不返回字符串，返回的是日期的毫秒表示。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2025/2/14 23:30:06</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLocaleString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fri Feb 14 2025 23:30:06 GMT+0800 (香港标准时间)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1739547006593</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><h3 id="日期格式化方法" tabindex="-1">日期格式化方法 <a class="header-anchor" href="#日期格式化方法" aria-label="Permalink to &quot;日期格式化方法&quot;">​</a></h3><p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ul><li><code>toDateString()</code> 显示日期中的周几、月、日、年（格式特定于实现）；</li><li><code>toTimeString()</code> 显示日期中的时、分、秒和时区（格式特定于实现）；</li><li><code>toLocaleDateString()</code> 显示日期中的周几、月、日、年（格式特定于实现和地区）；</li><li><code>toLocaleTimeString()</code> 显示日期中的时、分、秒（格式特定于实现和地区）；</li><li><code>toUTCString()</code> 显示完整的 UTC 日期（格式特定于实现）。<br> 这些方法的输出与 toLocaleString() 和 toString() 一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</li></ul><h3 id="日期-时间组件方法" tabindex="-1">日期/时间组件方法 <a class="header-anchor" href="#日期-时间组件方法" aria-label="Permalink to &quot;日期/时间组件方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getTime()</code></td><td>返回日期的毫秒表示；与 <code>valueOf()</code> 相同</td></tr><tr><td><code>setTime(milliseconds)</code></td><td>设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td><code>getFullYear()</code></td><td>返回 4 位数年（即 2019 而不是 19）</td></tr><tr><td><code>getUTCFullYear()</code></td><td>返回 UTC 日期的 4 位数年</td></tr><tr><td><code>setFullYear(year)</code></td><td>设置日期的年（year 必须是 4 位数）</td></tr><tr><td><code>setUTCFullYear(year)</code></td><td>设置 UTC 日期的年（year 必须是 4 位数）</td></tr><tr><td><code>getMonth()</code></td><td>返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td><code>getUTCMonth()</code></td><td>返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td><code>setMonth(month)</code></td><td>设置日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td><code>setUTCMonth(month)</code></td><td>设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td><code>getDate()</code></td><td>返回日期中的日（1~31）</td></tr><tr><td><code>getUTCDate()</code></td><td>返回 UTC 日期中的日（1~31）</td></tr><tr><td><code>setDate(date)</code></td><td>设置日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td><code>setUTCDate(date)</code></td><td>设置 UTC 日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td><code>getDay()</code></td><td>返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td><code>getUTCDay()</code></td><td>返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td><code>getHours()</code></td><td>返回日期中的时（0~23）</td></tr><tr><td><code>getUTCHours()</code></td><td>返回 UTC 日期中的时（0~23）</td></tr><tr><td><code>setHours(hours)</code></td><td>设置日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td><code>setUTCHours(hours)</code></td><td>设置 UTC 日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td><code>getMinutes()</code></td><td>返回日期中的分（0~59）</td></tr><tr><td><code>getUTCMinutes()</code></td><td>返回 UTC 日期中的分（0~59）</td></tr><tr><td><code>setMinutes(minutes)</code></td><td>设置日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td><code>setUTCMinutes(minutes)</code></td><td>设置 UTC 日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td><code>getSeconds()</code></td><td>返回日期中的秒（0~59）</td></tr><tr><td><code>getUTCSeconds()</code></td><td>返回 UTC 日期中的秒（0~59）</td></tr><tr><td><code>setSeconds(seconds)</code></td><td>设置日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td><code>setUTCSeconds(seconds)</code></td><td>设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td><code>getMilliseconds()</code></td><td>返回日期中的毫秒</td></tr><tr><td><code>getUTCMilliseconds()</code></td><td>返回 UTC 日期中的毫秒</td></tr><tr><td><code>setMilliseconds(milliseconds)</code></td><td>设置日期中的毫秒</td></tr><tr><td><code>setUTCMilliseconds(milliseconds)</code></td><td>设置 UTC 日期中的毫秒</td></tr><tr><td><code>getTimezoneOffset()</code></td><td>返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）</td></tr></tbody></table><h2 id="regexp-类型" tabindex="-1">RegExp 类型 <a class="header-anchor" href="#regexp-类型" aria-label="Permalink to &quot;RegExp 类型&quot;">​</a></h2><p>ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：<br><code>let expression = /pattern/flags;</code><br> pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、 分组、向前查找和反向引用。<br> 每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p><ul><li>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li><li>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</li><li>m：多行模式，表示查找到一行文本末尾时会继续查找。</li><li>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</li><li>u：Unicode 模式，启用 Unicode 匹配。</li><li>s：dotAll 模式，表示元字符.匹配任何字符（包括\\n 或\\r）。</li></ul><p>所有元字符在模式中也必须转义，包括：<code>( [ { \\ ^ $ | ) ] } ? * + .</code></p><p>正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。<br><code>let expression = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);</code></p><h3 id="实例属性" tabindex="-1">实例属性 <a class="header-anchor" href="#实例属性" aria-label="Permalink to &quot;实例属性&quot;">​</a></h3><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。</p><ul><li>global：布尔值，表示是否设置了 g 标记。</li><li>ignoreCase：布尔值，表示是否设置了 i 标记。</li><li>unicode：布尔值，表示是否设置了 u 标记。</li><li>sticky：布尔值，表示是否设置了 y 标记。</li><li>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li><li>multiline：布尔值，表示是否设置了 m 标记。</li><li>dotAll：布尔值，表示是否设置了 s 标记。</li><li>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的</li><li>斜杠。</li><li>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没</li><li>有前后斜杠）。</li></ul><h3 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h3><blockquote><p>[!example]+ regexp.exec<br><code>exec()</code> 主要用于捕获和处理字符串中的特定模式，它不仅能够告诉你是否找到了匹配项，还能提供关于匹配的详细信息。</p><ul><li>只接收一个参数，即要应用模式的字符串。</li><li>当 <code>exec()</code> 找到了匹配项时，它返回一个数组，该数组包含以下内容： <ul><li><code>[0]</code>：整个匹配到的字符串。</li><li><code>[1], [2], ...</code>：分别对应于正则表达式中的第一个、第二个捕获组的内容（如果有使用捕获组的话）。</li><li><code>index</code>：匹配开始的位置（即在原始字符串中的起始索引）。</li><li><code>input</code>：被搜索的原始字符串。</li><li><code>groups</code>：一个对象，包含所有命名捕获组的匹配内容（如果使用了命名捕获组的话）。例如，在正则表达式中使用了命名捕获组 <code>(?\\d{4})-(?\\d{2})-(?\\d{2})</code> 来提取日期格式，那么 <code>groups.year</code> 将保存年份，<code>groups.month</code> 保存月份，以此类推。</li></ul></li><li>全局标志<br> 如果正则表达式使用了全局标志（<code>g</code>），每次调用 <code>exec()</code> 都会从上一次匹配结束的位置继续搜索下一个匹配项。这意味着你可以通过循环调用 <code>exec()</code> 来遍历字符串中的所有匹配项。在这种情况下，正则表达式的 <code>lastIndex</code> 属性会被更新为最后一个匹配字符之后的位置。</li><li>如果模式设置了粘附标记 y，则每次调用 exec() 就只会在 lastIndex 的位置上寻找匹配项。</li></ul></blockquote><blockquote><p>[!example]+ regexp.test<br><code>test()</code> 接收一个字符串参数。<br> 如果输入的文本与模式匹配，则参数返回 true，否则返回 false。</p></blockquote><p>无论正则表达式是怎么创建的，继承的方法 toLocaleString() 和 toString() 都返回正则表达式的字面量表示。</p><h3 id="静态属性" tabindex="-1">静态属性 <a class="header-anchor" href="#静态属性" aria-label="Permalink to &quot;静态属性&quot;">​</a></h3><p>RegExp 构造函数（原型）的属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。每个属性都有一个全名和一个简写。</p><table tabindex="0"><thead><tr><th>全 名</th><th>简 写</th><th>说 明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最后搜索的字符串（非标准特性）</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最后匹配的文本</td></tr><tr><td>lastParen</td><td>$+</td><td>最后匹配的捕获组（非标准特性）</td></tr><tr><td>leftContext</td><td>$\`</td><td>input 字符串中出现在 lastMatch 前面的文本</td></tr><tr><td>rightContext</td><td>$&#39;</td><td>input 字符串中出现在 lastMatch 后面的文本</td></tr></tbody></table><p>通过这些属性可以提取出与 exec() 和 test() 执行的操作相关的信息。</p><h2 id="原始值包装类型" tabindex="-1">原始值包装类型 <a class="header-anchor" href="#原始值包装类型" aria-label="Permalink to &quot;原始值包装类型&quot;">​</a></h2><p>ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，==而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间==。</p><h3 id="boolean" tabindex="-1">Boolean <a class="header-anchor" href="#boolean" aria-label="Permalink to &quot;Boolean&quot;">​</a></h3><p>==（永远不要使用）==<br><code>let booleanObject = new Boolean(true);</code><br> Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true 或 false。toString() 方法被调用时也会被覆盖，返回字符串 &quot;true&quot; 或 &quot;false&quot;。</p><h3 id="number" tabindex="-1">Number <a class="header-anchor" href="#number" aria-label="Permalink to &quot;Number&quot;">​</a></h3><p>==（不建议实例化使用）==<br><code>let numberObject = new Number(10);</code><br> Number 类型重写了 valueOf()、toLocaleString() 和 toString() 方法。valueOf() 方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，</p><p>实例方法：</p><ul><li><code>toFixed()</code> 方法返回包含指定小数点位数的数值字符串，可以用于处理货币。</li><li><code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表示的数值字符串。</li><li><code>toPrecision()</code> 方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）</li></ul><p>静态方法：</p><ul><li><code>Number.isInteger()</code> 方法，用于辨别一个数值是否保存为整数。</li></ul><h3 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h3><p><code>let stringObject = new String(&quot;hello world&quot;);</code><br> 3 个继承的方法 valueOf()、toLocaleString() 和 toString() 都返回对象的原始字符串值。<br> 每个 String 对象都有一个 length 属性，表示字符串中字符的数量。</p><div class="info custom-block github-alert"><p class="custom-block-title">+ 字符串编码策略</p><p></p><ul><li>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。</li><li>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。</li><li>UCS-2 意味着它用两个字节（即 16 位）来表示一个字符。16 位只能唯一表示 65 536 个字符，在 Unicode 中称为<strong>基本多语言平面（BMP）</strong>。</li><li>为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个<strong>增补平面</strong>。这种每个字符使用两个 16 位码元的策略称为<strong>代理对</strong>。UTF-16 会使用一对连续的 16 位值来表示它们，这两个值分别被称为<strong>高代理项</strong>和<strong>低代理项</strong>。</li><li><strong>码点</strong>是 Unicode 中一个字符的完整标识。比如，&quot;c&quot; 的码点是 0x0063，而 &quot;☺&quot; 的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位。</li></ul></div><p>字符相关实例方法：</p><ul><li><code>charAt()</code> 方法返回给定索引位置的字符，由传给方法的整数参数指定。</li><li><code>charCodeAt()</code> 方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定</li><li><code>fromCharCode()</code> 方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串。</li><li><code>codePointAt()</code> （代替 charCodeAt()）可以正确解析既包含单码元字符又包含代理对字符的字符串。</li><li><code>fromCodePoint()</code> （代替 fromCharCode()）方法接收任意数量的码点，返回对应字符拼接起来的字符串。</li></ul><div class="info custom-block github-alert"><p class="custom-block-title">+ Unicode 标准化</p><p><code>normalize()</code> 用于将字符串转换为 Unicode 标准化形式。<br> Unicode 标准定义了几种规范化形式，这些形式可以确保即使有不同的表示方式，具有相同抽象含义的字符也会有统一的形式。以下是四种主要的规范化形式：</p><ol><li><strong>NFC (Normalization Form C)</strong>：规范组合。首先进行完全分解，然后重新组合成最简形式。</li><li><strong>NFD (Normalization Form D)</strong>：规范分解。将复合字符拆分为基础字符和单独的组合标记。</li><li><strong>NFKC (Normalization Form KC)</strong>：兼容性组合。类似于 NFC，但会应用额外的兼容性转换来进一步简化字符。</li><li><strong>NFKD (Normalization Form KD)</strong>：兼容性分解。类似于 NFD，但同样包括兼容性转换。</li></ol><p>当你调用 <code>normalize()</code> 方法时，可以指定上述四种形式之一作为参数。如果没有提供参数，则默认使用 &quot;NFC&quot; 形式。</p></div><ol><li><p>字符串操作方法：</p><ul><li>字符串拼接：<code>concat()</code> 用于将一个或多个字符串拼接成一个新字符串。</li><li>字符串提取：<code>slice()</code>、<code>substr()</code> 和 <code>substring()</code>3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。 <ul><li><strong><code>slice(start, end)</code></strong>（支持负数参数，并将其视为从字符串末尾开始的位置。）</li><li><strong><code>substring(start, end)</code></strong>（不支持负数参数，任何负值都会被视为 0。）</li><li><strong><code>substr(start, length)</code></strong></li></ul></li></ul></li><li><p>字符串位置方法：</p><ul><li><code>indexOf()</code> ：从字符串开头开始查找子字符串（如果没找到，则返回 -1）</li><li><code>lastIndexOf()</code>。从字符串末尾开始查找子字符串（如果没找到，则返回 -1）</li></ul></li><li><p>字符串包含方法：<br><code>startsWith()</code>、<code>endsWith()</code> 和 <code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith() 检查开始于索引 0 的匹配项，endsWith() 检查开始于索引 (string.length - substring.length) 的匹配项，而 includes() 检查整个字符串。</p></li><li><p><code>trim()</code> 方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果（返回的是字符串的副本）。</p></li><li><p><code>repeat()</code> 方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p></li><li><p><code>padStart()</code> 和 <code>padEnd()</code> 方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p></li><li><p>字符串迭代与解构:<br> 字符串的原型上暴露了一个 <code>@@iterator</code> 方法，表示可以迭代字符串的每个字符。有了这个迭代器之后，字符串就可以通过解构操作符 (<code>...</code>) 来解构了。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;abcde&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringIterator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> str[Symbol.iterator]();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span></code></pre></div></li><li><p>字符串大小写转换：<br><code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code> 和 <code>toLocaleUpperCase()</code>，带有 Locale 的函数旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。</p></li><li><p>字符串模式匹配方法：</p><ul><li><p><code>match()</code> 方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。返回的数组与 RegExp 对象的 exec() 方法返回的数组是一样的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;cat, bat, sat, fat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pattern </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等价于pattern.exec(text)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> matches </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pattern);</span></span></code></pre></div></li><li><p><code>search()</code> 方法接收一个正则表达式字符串或 RegExp 对象，返回模式第一个匹配的位置索引，如果没找到则返回 -1。search() 始终从字符串开头向后匹配模式。</p></li><li><p><code>replace()</code> 方法用于简化子字符串替换操作。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数是一个用于替换的字符串或一个函数。</p></li><li><p><code>split()</code> 方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。</p></li></ul></li><li><p><code>localeCompare()</code> 方法比较两个字符串返回如下 3 个值中的一个：</p><ul><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是 -1，具体还要看与实际值相关的实现。）</li><li>如果字符串与字符串参数相等，则返回 0。</li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</li></ul></li></ol><h2 id="单例内置对象" tabindex="-1">单例内置对象 <a class="header-anchor" href="#单例内置对象" aria-label="Permalink to &quot;单例内置对象&quot;">​</a></h2><h3 id="global" tabindex="-1">Global <a class="header-anchor" href="#global" aria-label="Permalink to &quot;Global&quot;">​</a></h3><p>ECMA-262 规定 Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。</p><ol><li><p>URL 编码方法</p><ul><li><code>ecnodeURI()</code> 方法用于对整个 URI 进行编码</li><li><code>encodeURIComponent()</code> 方法用于编码 URI 中单独的组件</li><li><code>decodeURI()</code> 解码</li><li><code>decodeURIComponent()</code></li></ul></li><li><p><code>eval()</code><br><code>eval()</code> 方法是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。通过 eval() 执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。在严格模式下，在 eval() 内部创建的变量和函数无法被外部访问。</p></li><li><p>Global 对象属性</p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>undefined</td><td>特殊值 <code>undefined</code></td></tr><tr><td>NaN</td><td>特殊值 <code>NaN</code></td></tr><tr><td>Infinity</td><td>特殊值 <code>Infinity</code></td></tr><tr><td>Object</td><td><code>Object</code> 的构造函数</td></tr><tr><td>Array</td><td><code>Array</code> 的构造函数</td></tr><tr><td>Function</td><td><code>Function</code> 的构造函数</td></tr><tr><td>Boolean</td><td><code>Boolean</code> 的构造函数</td></tr><tr><td>String</td><td><code>String</code> 的构造函数</td></tr><tr><td>Number</td><td><code>Number</code> 的构造函数</td></tr><tr><td>Date</td><td><code>Date</code> 的构造函数</td></tr><tr><td>RegExp</td><td><code>RegExp</code> 的构造函数</td></tr><tr><td>Symbol</td><td><code>Symbol</code> 的伪构造函数</td></tr><tr><td>Error</td><td><code>Error</code> 的构造函数</td></tr><tr><td>EvalError</td><td><code>EvalError</code> 的构造函数</td></tr><tr><td>RangeError</td><td><code>RangeError</code> 的构造函数</td></tr><tr><td>ReferenceError</td><td><code>ReferenceError</code> 的构造函数</td></tr><tr><td>SyntaxError</td><td><code>SyntaxError</code> 的构造函数</td></tr><tr><td>TypeError</td><td><code>TypeError</code> 的构造函数</td></tr><tr><td>URIError</td><td><code>URIError</code> 的构造函数</td></tr></tbody></table></li><li><p>window 对象<br> ==虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。==</p></li></ol><h3 id="math" tabindex="-1">Math <a class="header-anchor" href="#math" aria-label="Permalink to &quot;Math&quot;">​</a></h3><p>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。</p><ol><li><p>Math 对象属性</p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Math.E</td><td>自然对数的基数 e 的值</td></tr><tr><td>Math.LN10</td><td>10 为底的自然对数</td></tr><tr><td>Math.LN2</td><td>2 为底的自然对数</td></tr><tr><td>Math.LOG2E</td><td>以 2 为底 e 的对数</td></tr><tr><td>Math.LOG10E</td><td>以 10 为底 e 的对数</td></tr><tr><td>Math.PI</td><td>π 的值</td></tr><tr><td>Math.SQRT1_2</td><td>1/2 的平方根</td></tr><tr><td>Math.SQRT2</td><td>2 的平方根</td></tr></tbody></table></li><li><p><code>min()</code> 和 <code>max()</code> 方法用于确定一组数值中的最小值和最大值。</p></li><li><p>舍入方法</p><ul><li><code>Math.ceil()</code> 始终向上舍入为最接近的整数。</li><li><code>Math.floor()</code> 始终向下舍入为最接近的整数。</li><li><code>Math.round()</code> 执行四舍五入。</li><li><code>Math.fround()</code> 返回数值最接近的单精度（32 位）浮点值表示。</li></ul></li><li><p><code>random()</code><br><code>Math.random()</code> 方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。<br> 可以基于如下公式从一组整数中随机选择一个数：<br><code>number = Math.floor(Math.random() * total_number_of_choices + first_possible_value)</code></p></li><li><p>公式方法</p></li></ol><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Math.abs(x)</td><td>返回 x 的绝对值</td></tr><tr><td>Math.exp(x)</td><td>返回 Math.E 的 x 次幂</td></tr><tr><td>Math.expm1(x)</td><td>等于 Math.exp(x) - 1</td></tr><tr><td>Math.log(x)</td><td>返回 x 的自然对数</td></tr><tr><td>Math.log1p(x)</td><td>等于 1 + Math.log(x)</td></tr><tr><td>Math.pow(x, power)</td><td>返回 x 的 power 次幂</td></tr><tr><td>Math.hypot(...nums)</td><td>返回 nums 中每个数平方和的平方根</td></tr><tr><td>Math.clz32(x)</td><td>返回 32 位整数 x 的前置零的数量</td></tr><tr><td>Math.sign(x)</td><td>返回表示 x 符号的 1、0、-0 或 -1</td></tr><tr><td>Math.trunc(x)</td><td>返回 x 的整数部分，删除所有小数</td></tr><tr><td>Math.sqrt(x)</td><td>返回 x 的平方根</td></tr><tr><td>Math.cbrt(x)</td><td>返回 x 的立方根</td></tr><tr><td>Math.acos(x)</td><td>返回 x 的反余弦</td></tr><tr><td>Math.acosh(x)</td><td>返回 x 的反双曲余弦</td></tr><tr><td>Math.asin(x)</td><td>返回 x 的反正弦</td></tr><tr><td>Math.asinh(x)</td><td>返回 x 的反双曲正弦</td></tr><tr><td>Math.atan(x)</td><td>返回 x 的反正切</td></tr><tr><td>Math.atanh(x)</td><td>返回 x 的反双曲正切</td></tr><tr><td>Math.atan2(y, x)</td><td>返回 y/x 的反正切</td></tr><tr><td>Math.cos(x)</td><td>返回 x 的余弦</td></tr><tr><td>Math.sin(x)</td><td>返回 x 的正弦</td></tr><tr><td>Math.tan(x)</td><td>返回 x 的正切</td></tr></tbody></table>`,61)]))}const g=e(s,[["render",o]]);export{k as __pageData,g as default};
