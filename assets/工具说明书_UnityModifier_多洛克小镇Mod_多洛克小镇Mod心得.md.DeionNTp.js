import{_ as a,c as e,o,ae as s}from"./chunks/framework.CIivgcbp.js";const d="/obsidian-vitepress-docs/assets/%E5%A4%9A%E6%B4%9B%E5%85%8B%E5%B0%8F%E9%95%87Mod%E5%BF%83%E5%BE%97-1.CJSUG9gv.png",b=JSON.parse('{"title":"多洛克小镇 Mod 心得","description":"","frontmatter":{},"headers":[],"relativePath":"工具说明书/UnityModifier/多洛克小镇Mod/多洛克小镇Mod心得.md","filePath":"工具说明书/UnityModifier/多洛克小镇Mod/多洛克小镇Mod心得.md"}'),r={name:"工具说明书/UnityModifier/多洛克小镇Mod/多洛克小镇Mod心得.md"};function n(i,t,l,h,p,c){return o(),e("div",null,t[0]||(t[0]=[s('<h1 id="多洛克小镇-mod-心得" tabindex="-1">多洛克小镇 Mod 心得 <a class="header-anchor" href="#多洛克小镇-mod-心得" aria-label="Permalink to &quot;多洛克小镇 Mod 心得&quot;">​</a></h1><h2 id="阶段总结" tabindex="-1">阶段总结 <a class="header-anchor" href="#阶段总结" aria-label="Permalink to &quot;阶段总结&quot;">​</a></h2><h3 id="目前总结" tabindex="-1">目前总结 <a class="header-anchor" href="#目前总结" aria-label="Permalink to &quot;目前总结&quot;">​</a></h3><div class="note custom-block github-alert"><p class="custom-block-title">Title</p><p>目前，界面的渲染还是与游戏本身的数据 - 视图结构强耦合，如何未来有时间，我希望直接使用游戏的预制体嵌入游戏面板中，实现自己的 eventbus，实现真正的双向数据绑定</p></div><p>🧱 当前状态（DolocTown）</p><table tabindex="0"><thead><tr><th>层级</th><th>框架逻辑</th></tr></thead><tbody><tr><td>配置源头</td><td><code>BepInEx.ConfigEntry</code></td></tr><tr><td>数据存储</td><td><code>UserSettings.currentData</code>（JSON 支撑）</td></tr><tr><td>UI 视图</td><td><code>SettingPanel → SettingGroupUI → ToggleItemUI</code> 等</td></tr><tr><td>更新逻辑</td><td>基于枚举 ID → MessageSystem 派发</td></tr></tbody></table><p>🔗 游戏采用的是传统的<strong>枚举映射 + 显式注册 + 静态方法绑定</strong>，所以非常硬编码。</p><p>🧭 未来愿景</p><table tabindex="0"><thead><tr><th>特性</th><th>效果</th></tr></thead><tbody><tr><td>🧩 使用原生 UI Prefab</td><td>保证风格一致，直接挂载到现有 UI</td></tr><tr><td>📦 支持外部注入自己的 <code>SettingGroupUI</code></td><td>比如一个自定义的列表框或 Rebind 区块</td></tr><tr><td>🔁 双向数据绑定</td><td>修改 UI 会立刻映射到 BepInEx 的 ConfigEntry，反之亦然</td></tr><tr><td>📡 事件解耦（ModBus）</td><td>UI、数据、游戏逻辑间通过中间层通信，避免直接调用</td></tr></tbody></table><h2 id="笔记" tabindex="-1">笔记 <a class="header-anchor" href="#笔记" aria-label="Permalink to &quot;笔记&quot;">​</a></h2><h3 id="unity-协程-与-js-promise-在事件循环中的相似点" tabindex="-1"><strong>Unity 协程 与 JS Promise 在事件循环中的相似点：</strong> <a class="header-anchor" href="#unity-协程-与-js-promise-在事件循环中的相似点" aria-label="Permalink to &quot;**Unity 协程 与 JS Promise 在事件循环中的相似点：**&quot;">​</a></h3><p>虽然它们底层实现机制不同（一个是编译时状态机 + 帧驱动，一个是事件循环 + 微任务队列），但它们<strong>思维模型非常相近</strong>：</p><table tabindex="0"><thead><tr><th>维度</th><th>Unity 协程（Coroutine）</th><th>JS Promise（事件循环）</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>延时执行、分帧控制</td><td>异步操作、延后执行</td></tr><tr><td><strong>执行时机</strong></td><td><code>yield return</code> 延迟到未来的帧执行</td><td><code>.then()</code> 延迟到微任务队列执行</td></tr><tr><td><strong>暂停点</strong></td><td><code>yield return</code></td><td><code>await</code> / <code>.then()</code></td></tr><tr><td><strong>驱动机制</strong></td><td>每帧执行一次检查</td><td>事件循环（event loop）</td></tr><tr><td><strong>状态机/队列</strong></td><td>编译器生成状态机</td><td>引擎维护 promise 状态与回调队列</td></tr><tr><td><strong>不能并行处理任务</strong></td><td>单线程运行，不能跳过帧</td><td>单线程，不能并行（除非 worker）</td></tr></tbody></table><p>✅ 深层理解：<strong>“异步流程线”控制权交还</strong></p><table tabindex="0"><thead><tr><th>语言/平台</th><th>“交还控制权”的方式</th></tr></thead><tbody><tr><td>Unity</td><td><code>yield return</code> 把控制权交给 Unity，引擎每帧再判断是否继续</td></tr><tr><td>JS</td><td><code>await</code> / <code>.then()</code> 把控制权交给事件循环，引擎在任务完成时回调</td></tr><tr><td>Python</td><td><code>await</code> / <code>yield</code> 把控制权交给事件循环（如 asyncio）</td></tr></tbody></table><h3 id="游戏面板配置加载流程" tabindex="-1">游戏面板配置加载流程 <a class="header-anchor" href="#游戏面板配置加载流程" aria-label="Permalink to &quot;游戏面板配置加载流程&quot;">​</a></h3><p><img src="'+d+`" alt=""></p><p><code>rebindActionUIByGroup</code> 就是由 <code>Labels</code> 构建的字典。<br> 说明冲突检测是 <strong>以 Label Group 为单位进行的</strong>。</p><h2 id="心得" tabindex="-1">心得 <a class="header-anchor" href="#心得" aria-label="Permalink to &quot;心得&quot;">​</a></h2><h3 id="❌-忽略版本管理" tabindex="-1">❌ 忽略版本管理 <a class="header-anchor" href="#❌-忽略版本管理" aria-label="Permalink to &quot;❌ 忽略版本管理&quot;">​</a></h3><blockquote><p><strong>问题：</strong> 起初没有用 Git 进行备份和分支管理，导致回滚困难、调试失控。<br><strong>反思：</strong> 版本控制不是锦上添花，而是项目基础建设，哪怕是个人项目也必须用。</p></blockquote><p>📌 <strong>经验总结</strong></p><ul><li><strong>Git 是最低成本的保险；</strong></li><li>开新功能时记得新建分支；</li><li>出现“感觉哪里不对”的时候，先 commit 一下。</li></ul><h3 id="❌-别为了-理论上的完美-去实现代价极高的修改" tabindex="-1">❌ 别为了“理论上的完美”，去实现代价极高的修改 <a class="header-anchor" href="#❌-别为了-理论上的完美-去实现代价极高的修改" aria-label="Permalink to &quot;❌ 别为了“理论上的完美”，去实现代价极高的修改&quot;">​</a></h3><blockquote><p><strong>问题：</strong> 为了实现“CM → 游戏 UI 的实时同步”，试图实现复杂的双向数据绑定。<br><strong>结果：</strong> 引发了一堆耦合、缓存同步、UI 组件状态异常的问题，回调套回调极其难维护。<br><strong>反思：</strong> 游戏原生设计并不支持双向绑定，强行实现代价高且收益低。</p></blockquote><p>📌 <strong>经验总结：</strong></p><ul><li><strong>不要和游戏原有架构硬刚；</strong></li><li>保持“命令式调用 → 配置更新”足矣；</li><li>能不做的功能就是最省 bug 的功能。</li></ul><p>ModSettingManager 现在的数据链如下：</p><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">用户操作 UI </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ↓</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">游戏触发 SettingId 回调 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ↓</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">设置对应的 ConfigEntry&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;.Value （通过你的 SettingItem 包装）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ↓</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ConfigEntry 本身触发 SettingChanged 事件 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ↓</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CM 正确双向数据绑定</span></span></code></pre></div><p>这个链条已经是一个 <strong>健壮的单向数据流</strong>。</p><h3 id="❌-过度封装导致失去对底层的控制权" tabindex="-1">❌ 过度封装导致失去对底层的控制权 <a class="header-anchor" href="#❌-过度封装导致失去对底层的控制权" aria-label="Permalink to &quot;❌ 过度封装导致失去对底层的控制权&quot;">​</a></h3><blockquote><p><strong>问题：</strong> 初期希望通过泛型、抽象、继承封装出一套优雅的 SettingItem 结构。<br><strong>后果：</strong> 封装过深导致很难调试真实值，调起 UI 行为或更新变得间接、复杂。<br><strong>反思：</strong> 封装的前提是你能掌控每一层逻辑。</p></blockquote><p>📌 <strong>经验总结：</strong></p><ul><li>在理解不足时，<strong>“暴露字段 + 明确命名”优于“抽象泛型”</strong>；</li><li>封装不能压缩信息，得提升可用性；</li><li>有时候，<strong>复制粘贴 3 次胜过强抽象</strong>。</li></ul>`,34)]))}const u=a(r,[["render",n]]);export{b as __pageData,u as default};
