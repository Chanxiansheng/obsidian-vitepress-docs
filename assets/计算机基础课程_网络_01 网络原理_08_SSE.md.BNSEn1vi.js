import{_ as i,c as a,o as e,ae as n}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"SSE","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/08_SSE.md","filePath":"计算机基础课程/网络/01 网络原理/08_SSE.md"}'),t={name:"计算机基础课程/网络/01 网络原理/08_SSE.md"};function l(h,s,k,p,E,r){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="sse" tabindex="-1">SSE <a class="header-anchor" href="#sse" aria-label="Permalink to &quot;SSE&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><ul><li><p>SSE（Server-Sent Events）是一种用于实现服务器主动向客户端推送数据的技术，也被称为“事件流”（Event Stream）。它基于 HTTP 协议，利用了其长连接特性，在客户端与服务器之间建立一条持久化连接，并通过这条连接实现服务器向客户端的实时数据推送。</p></li><li><p><strong>SSE 是一种单工通讯。</strong> 前端只先后端发送一次请求，后端不断返回数据。</p></li><li><p>适用场景：</p><p>chatGPT 返回的数据 就是使用的 SSE 技术<br> 实时数据大屏 如果只是需要展示，实时的数据可以使用 SSE 技术，而不是非要使用 webSocket</p></li></ul><h2 id="eventsource-用法" tabindex="-1">EventSource 用法 <a class="header-anchor" href="#eventsource-用法" aria-label="Permalink to &quot;EventSource 用法&quot;">​</a></h2><p><code>EventSource</code> 对象是 HTML5 新增的一个客户端 API，用于通过服务器推送实时更新的数据和通知。在使用 EventSource 对象时，可以通过以下方法进行配置和操作：</p><h3 id="eventsource-构造函数" tabindex="-1">EventSource() 构造函数 <a class="header-anchor" href="#eventsource-构造函数" aria-label="Permalink to &quot;EventSource() 构造函数&quot;">​</a></h3><p>EventSource 的构造函数接收一个 URL 参数，通过该 URL 可以建立起与服务器的连接，并开始接收服务器发送的数据。</p><p><code>const eventSource = new EventSource(url, options);</code></p><ul><li>url：String 类型，表示与服务器建立连接的 URL。必填。</li><li>options：Object 类型，表示可选参数。常用的可选参数包括： <ul><li>withCredentials：Boolean 类型，表示是否允许发送 Cookie 和 HTTP 认证信息。默认为 false。</li><li>headers：Object 类型，表示要发送的请求头信息。</li><li>retryInterval：Number 类型，表示与服务器失去连接后，重新连接的时间间隔。默认为 1000 毫秒。</li></ul></li></ul><h3 id="eventsource-readystate-属性" tabindex="-1">EventSource.readyState 属性 <a class="header-anchor" href="#eventsource-readystate-属性" aria-label="Permalink to &quot;EventSource.readyState 属性&quot;">​</a></h3><p>readyState 属性表示当前 EventSource 对象的状态，它是一个只读属性，它的值有以下几个：</p><ul><li>CONNECTING：表示正在和服务器建立连接。</li><li>OPEN：表示已经建立连接，正在接收服务器发送的数据。</li><li>CLOSED：表示连接已经被关闭，无法再接收服务器发送的数据。</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (eventSource.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventSource.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CONNECTING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;正在连接服务器...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (eventSource.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventSource.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OPEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;已经连接上服务器！&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (eventSource.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventSource.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLOSED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;连接已经关闭。&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="eventsource-close-方法" tabindex="-1">EventSource.close() 方法 <a class="header-anchor" href="#eventsource-close-方法" aria-label="Permalink to &quot;EventSource.close() 方法&quot;">​</a></h3><p>close() 方法用于关闭 EventSource 对象与服务器的连接，停止接收服务器发送的数据。</p><p><code>eventSource.close()</code></p><h3 id="eventsource-生命钩子" tabindex="-1">EventSource 生命钩子 <a class="header-anchor" href="#eventsource-生命钩子" aria-label="Permalink to &quot;EventSource 生命钩子&quot;">​</a></h3><ul><li>EventSource.onopen 事件<br><code>onopen</code> 事件表示 EventSource 对象已经和服务器建立了连接，并开始接收来自服务器的数据。当 EventSource 对象建立连接时，触发该事件。</li><li>EventSource.onerror 事件<br><code>onerror</code> 事件表示在建立连接或接收服务器数据时发生了错误。当出现错误时，触发该事件。</li><li>EventSource.onmessage 事件<br><code>onmessage</code> 事件表示已经接收到服务器发送的数据，当接收到数据时，触发该事件。</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eventSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onopen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;连接成功！&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eventSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;发生错误：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eventSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;接收到数据：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>以上就是 EventSource 对象的常用 API 介绍，需要注意的是，在使用 EventSource 对象的过程中，如果服务器没有正确地设置响应头信息（如：<code>Content-Type: text/event-stream</code>），会导致 EventSource 对象无法接收到服务器发送的数据。</p><h2 id="sse-和-socket-区别" tabindex="-1">SSE 和 Socket 区别 <a class="header-anchor" href="#sse-和-socket-区别" aria-label="Permalink to &quot;SSE 和 Socket 区别&quot;">​</a></h2><p>SSE（Server-Sent Events）和 WebSocket 都是实现服务器向客户端实时推送数据的技术，但它们在某些方面还是有一定的区别。</p><ul><li>技术实现<br> SSE 基于 HTTP 协议，利用了其长连接特性，通过浏览器向服务器发送一个 HTTP 请求，建立一条持久化的连接。而 WebSocket 则是通过特殊的升级协议（HTTP/1.1 Upgrade 或者 HTTP/2）建立新的 TCP 连接，与传统 HTTP 连接不同。</li><li>数据格式<br> SSE 可以传输文本和二进制格式的数据，但只支持单向数据流，即只能由服务器向客户端推送数据。WebSocket 支持双向数据流，客户端和服务器可以互相发送消息，并且没有消息大小限制。</li><li>连接状态<br> SSE 的连接状态仅有三种：已连接、连接中、已断开。连接状态是由浏览器自动维护的，客户端无法手动关闭或重新打开连接。而 WebSocket 连接的状态更灵活，可以手动打开、关闭、重连等。</li><li>兼容性<br> SSE 是标准的 Web API，可以在大部分现代浏览器和移动设备上使用。但如果需要兼容老版本的浏览器（如 IE6/7/8），则需要使用 polyfill 库进行兼容。而 WebSocket 在一些老版本 Android 手机上可能存在兼容性问题，需要使用一些特殊的 API 进行处理。</li><li>安全性<br> SSE 的实现比较简单，都是基于 HTTP 协议的，与普通的 Web 应用没有太大差异，因此风险相对较低。WebSocket 则需要通过额外的安全措施（如 SSL/TLS 加密）来确保数据传输的安全性，避免被窃听和篡改，否则可能会带来安全隐患。</li></ul><p>总体来说，SSE 和 WebSocket 都有各自的优缺点，适用于不同的场景和需求。如果只需要服务器向客户端单向推送数据，并且应用在前端的浏览器环境中，则 SSE 是一个更加轻量级、易于实现和维护的选择。而如果需要双向传输数据、支持自定义协议、或者在更加复杂的网络环境中应用，则 WebSocket 可能更加适合。</p>`,24)]))}const d=i(t,[["render",l]]);export{c as __pageData,d as default};
