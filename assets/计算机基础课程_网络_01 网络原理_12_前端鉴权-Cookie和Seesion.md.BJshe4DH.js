import{_ as i,c as o,o as e,ae as t}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"前端鉴权 - Cookie 和 Seesion","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/12_前端鉴权-Cookie和Seesion.md","filePath":"计算机基础课程/网络/01 网络原理/12_前端鉴权-Cookie和Seesion.md"}'),n={name:"计算机基础课程/网络/01 网络原理/12_前端鉴权-Cookie和Seesion.md"};function a(r,s,l,k,h,d){return e(),o("div",null,s[0]||(s[0]=[t('<h1 id="前端鉴权-cookie-和-seesion" tabindex="-1">前端鉴权 - Cookie 和 Seesion <a class="header-anchor" href="#前端鉴权-cookie-和-seesion" aria-label="Permalink to &quot;前端鉴权 - Cookie 和 Seesion&quot;">​</a></h1><h2 id="什么是-cookie" tabindex="-1">什么是 Cookie <a class="header-anchor" href="#什么是-cookie" aria-label="Permalink to &quot;什么是 Cookie&quot;">​</a></h2><ul><li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><h2 id="cookie-的使用" tabindex="-1">Cookie 的使用 <a class="header-anchor" href="#cookie-的使用" aria-label="Permalink to &quot;Cookie 的使用&quot;">​</a></h2><p>步骤：</p><ol><li>提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li><li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li></ol><p>重要属性</p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong><br>- 如果值为 Unicode 字符，需要为字符编码。<br>- 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 &#39;/&#39;</strong>。如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table><p>设置 cookie</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jimu; domain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xxxx.com; path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">blog; Expires</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Wed, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Oct </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2015</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">00</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; Secure; HttpOnly</span></span></code></pre></div><p>前端读取<br> 如果服务端创建的 cookie 没加 <code>HttpOnly</code>，可以调用 <code>document.cookie</code> 可以创建、修改 cookie。</p><h2 id="什么是-session" tabindex="-1">什么是 Session <a class="header-anchor" href="#什么是-session" aria-label="Permalink to &quot;什么是 Session&quot;">​</a></h2><ul><li>session 是另一种记录服务器和客户端会话状态的机制</li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端</strong>，sessionId 会被存储到客户端的 cookie 中</li></ul><h2 id="session-的使用" tabindex="-1">Session 的使用 <a class="header-anchor" href="#session-的使用" aria-label="Permalink to &quot;Session 的使用&quot;">​</a></h2><h3 id="典型的-session-登陆-验证流程" tabindex="-1">典型的 session 登陆/验证流程： <a class="header-anchor" href="#典型的-session-登陆-验证流程" aria-label="Permalink to &quot;典型的 session 登陆/验证流程：&quot;">​</a></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37adb2019d064967923a659848870771~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><ul><li>浏览器登录发送账号密码，服务端查用户库，校验用户</li><li>服务端把用户登录状态存为 Session，生成一个 sessionId</li><li>通过登录接口返回，把 sessionId set 到 cookie 上</li><li>此后浏览器再请求业务接口，sessionId 随 cookie 带上</li><li>服务端查 sessionId 校验 session</li><li>成功后正常做业务处理，返回结果</li></ul><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p><h3 id="node-js-使用" tabindex="-1">node.js 使用 <a class="header-anchor" href="#node-js-使用" aria-label="Permalink to &quot;node.js 使用&quot;">​</a></h3><p>通过 <a href="https://link.juejin.cn?target=https://www.npmjs.com/package/express-session" title="express-session - npm" target="_blank" rel="noreferrer">express-session - npm</a> 这个已经封装好的中间件</p><p>主要实现了：</p><ul><li>封装了对 cookie 的读写操作，并提供配置项配置字段、加密方式、过期时间等。</li><li>封装了对 session 的存取操作，并提供配置项配置 session 存储方式（内存/redis）、存储规则等。</li><li>给 req 提供了 session 属性，控制属性的 set/get 并响应到 cookie 和 session 存取上，并给 req.session 提供了一些方法。</li></ul><h2 id="cookie-和-session-的区别" tabindex="-1">Cookie 和 Session 的区别 <a class="header-anchor" href="#cookie-和-session-的区别" aria-label="Permalink to &quot;Cookie 和 Session 的区别&quot;">​</a></h2><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul>',24)]))}const g=i(n,[["render",a]]);export{c as __pageData,g as default};
