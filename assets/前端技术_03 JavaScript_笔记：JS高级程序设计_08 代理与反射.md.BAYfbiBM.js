import{_ as t,c as i,o as s,ag as a}from"./chunks/framework.-ewJmwvT.js";const k=JSON.parse('{"title":"08 代理与反射","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/08 代理与反射.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/08 代理与反射.md"}'),r={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/08 代理与反射.md"};function l(o,e,p,n,c,d){return s(),i("div",null,e[0]||(e[0]=[a(`<h1 id="_08-代理与反射" tabindex="-1">08 代理与反射 <a class="header-anchor" href="#_08-代理与反射" aria-label="Permalink to &quot;08 代理与反射&quot;">​</a></h1><p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p><h2 id="代理基础" tabindex="-1">代理基础 <a class="header-anchor" href="#代理基础" aria-label="Permalink to &quot;代理基础&quot;">​</a></h2><h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h3><p>代理是使用 Proxy 构造函数创建的。</p><blockquote><p>[!example]+ Proxy</p><p><code>new Proxy(target, handler)</code> 创建一个代理对象，它包装了目标对象并允许你自定义基本操作（如属性查找、赋值、枚举等）的行为。</p><ul><li>target: 要包装的目标对象。可以是任何类型的对象，包括原生的对象类型和函数。</li><li>handler: 一个对象，其属性是函数，这些函数定义了在执行各种内部操作时的拦截行为（捕获器）。</li></ul><p>返回值: 一个新的代理对象，它封装了目标对象，并根据需要通过 handler 对象的方法定制行为。</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;target&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span></code></pre></div><p>访问两个对象的同名属性是同一个值，给目标属性赋值会反映在两个对象上。<br><code>target.id === proxy.id //true</code></p><p>严格相等可以用来区分代理和目标。<br><code>target === proxy //false</code></p><h3 id="捕获器" tabindex="-1">捕获器 <a class="header-anchor" href="#捕获器" aria-label="Permalink to &quot;捕获器&quot;">​</a></h3><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。<br> 每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。<br> 每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><p>定义了一个 <code>get()</code> 捕获器：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  foo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 捕获器在处理程序对象中以方法名为键</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;handler override&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span></code></pre></div><p>这样，当通过代理对象执行 <code>get()</code> 操作时，就会触发定义的 <code>get()</code> 捕获器。<br><code>proxy[property]</code>、<code>proxy.property</code> 或 <code>Object.create(proxy)[property]</code> 等操作都会触发基本的 <code>get()</code> 操作以获取属性。<br> 只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.foo);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;handler override&#39;</span></span></code></pre></div><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。<br> 比如，<code>get()</code> 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(trapTarget, property, receiver) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建原始行为。<br> ==处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。==这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(trapTarget, property, receiver) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>捕获器不变式<br> 根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式” （trap invariant）。<br> 比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError。</li></ul><h3 id="可撤销代理" tabindex="-1">可撤销代理 <a class="header-anchor" href="#可撤销代理" aria-label="Permalink to &quot;可撤销代理&quot;">​</a></h3><p>Proxy 也暴露了 <code>revocable()</code> 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。</p><blockquote><p>[!example]+ Proxy.revocable</p><p><code>Proxy.revocable(target, handler)</code> 方法创建一个可撤销的代理对象。与标准的 <code>Proxy</code> 构造函数不同，它允许你在稍后的时间点撤销代理，从而禁用其陷阱处理功能。</p><ul><li>target: 要包装的目标对象。可以是任何类型的对象，包括原生的对象类型和函数。</li><li>handler: 一个对象，其属性是函数，这些函数定义了在执行各种内部操作时的拦截行为（称为“陷阱”）。</li></ul><p>返回值: 一个对象，包含两个属性：</p><ul><li>proxy: 创建的代理实例本身。</li><li>revoke: 一个没有参数的函数，调用它将撤销代理。一旦代理被撤销，对代理的所有后续操作都将抛出 TypeError 异常。</li></ul></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revocable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行撤销代理</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TypeError</span></span></code></pre></div><h3 id="实用反射-api" tabindex="-1">实用反射 API <a class="header-anchor" href="#实用反射-api" aria-label="Permalink to &quot;实用反射 API&quot;">​</a></h3><p>某些情况下应该优先使用反射 API：</p><ol><li><p>状态标记<br> 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。以下反射方法都会提供状态标记：</p><ul><li><code>Reflect.defineProperty()</code></li><li><code>Reflect.preventExtensions()</code></li><li><code>Reflect.setPrototypeOf()</code></li><li><code>Reflect.set()</code></li><li><code>Reflect.deleteProperty()</code></li></ul></li><li><p>用一等函数替代操作符</p><ul><li><code>Reflect.get()</code>：可以替代对象属性访问操作符。</li><li><code>Reflect.set()</code>：可以替代=赋值操作符。</li><li><code>Reflect.has()</code>：可以替代 in 操作符或 with()。</li><li><code>Reflect.deleteProperty()</code>：可以替代 delete 操作符。</li><li><code>Reflect.construct()</code>：可以替代 new 操作符。</li></ul></li><li><p>安全地应用函数<br> 在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myFunc, thisVal, argumentsList);</span></span></code></pre></div></li></ol><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p><h3 id="代理的问题" tabindex="-1">代理的问题 <a class="header-anchor" href="#代理的问题" aria-label="Permalink to &quot;代理的问题&quot;">​</a></h3><ol><li><p>代理中的 this<br> 代理潜在的一个问题来源是 this 值。</p></li><li><p>代理与内部槽位<br> 代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。<br> 一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位 <code>[[NumberDate]]</code>。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get() 和 set() 操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError。</p></li></ol><h2 id="代理捕获器与反射方法" tabindex="-1">代理捕获器与反射方法 <a class="header-anchor" href="#代理捕获器与反射方法" aria-label="Permalink to &quot;代理捕获器与反射方法&quot;">​</a></h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p><h3 id="get" tabindex="-1">get <a class="header-anchor" href="#get" aria-label="Permalink to &quot;get&quot;">​</a></h3><blockquote><p>[!example]+ get() 捕获器</p><p><code>get(target, property, receiver)</code> 用于拦截对目标对象属性值的读取操作。<br> 对应的反射 API 方法为 <code>Reflect.get()</code>。</p><ul><li>target: 目标对象，即代理对象包装的对象。</li><li>property: 正在被访问的属性名（字符串或符号类型）。</li><li>receiver: 代理对象或继承代理对象的对象。</li></ul><ol><li>返回值<br> 应该返回给用户的属性值。如果没有提供返回值，则默认行为将直接从目标对象中读取属性值。</li><li>拦截的操作<br><code>proxy.property</code><br><code>proxy[property]</code><br><code>Object.create(proxy)[property]</code><br><code>Reflect.get(proxy, property, receiver)</code></li><li>捕获器不变式<br> 如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。<br> 如果 target.property 不可配置且 <code>[[Get]]</code> 特性为 undefined，处理程序的返回值也必须是 undefined。</li></ol></blockquote><h3 id="set" tabindex="-1">set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;set&quot;">​</a></h3><blockquote><p>[!example]+ set() 捕获器</p><p><code>set(target, property, value, receiver)</code> 用于拦截对目标对象属性值的设置操作。<br> 对应的反射 API 方法为 <code>Reflect.set()</code>。</p><ul><li>target: 目标对象，即代理对象包装的对象。</li><li>property: 正在被设置的属性名（字符串或符号类型）。</li><li>value: 要赋予属性的新值。</li><li>receiver: 接收最初赋值的对象。</li></ul><ol><li>返回值<br> 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</li><li>拦截的操作<br><code>proxy.property = value</code><br><code>proxy[property] = value</code><br><code>Object.create(proxy)[property] = value</code><br><code>Reflect.set(proxy, property, value, receiver)</code></li><li>捕获器不变式<br> 如果 target.property 不可写且不可配置，则不能修改目标属性的值。<br> 如果 target.property 不可配置且 <code>[[Set]]</code> 特性为 undefined，则不能修改目标属性的值。<br> 在严格模式下，处理程序中返回 false 会抛出 TypeError。</li></ol></blockquote><h3 id="has" tabindex="-1">has <a class="header-anchor" href="#has" aria-label="Permalink to &quot;has&quot;">​</a></h3><blockquote><p>[!example]+ has</p><p><code>has(target, property)</code> 拦截 <code>in</code> 操作符的检查。<br> 对应的反射 API 方法为 <code>Reflect.has()</code>。</p><ul><li>target: 目标对象。</li><li>property: 被检查的属性名（字符串或符号）。</li></ul><ol><li>返回值<br> has() 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<br><code>property in proxy</code><br><code>property in Object.create(proxy)</code><br><code>with(proxy) {(property);}</code><br><code>Reflect.has(proxy, property)</code></li><li>捕获器不变式<br> 如果 target.property 存在且不可配置，则处理程序必须返回 true。<br> 如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</li></ol></blockquote><h3 id="defineproperty" tabindex="-1">defineProperty <a class="header-anchor" href="#defineproperty" aria-label="Permalink to &quot;defineProperty&quot;">​</a></h3><blockquote><p>[!example]+ construct</p><p><code>defineProperty(target, property, descriptor)</code> 拦截 <code>Object.defineProperty()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.defineProperty()</code>。</p><ul><li>target: 目标对象。</li><li>property: 要定义或修改的属性名（字符串或符号）。</li><li>descriptor: 属性描述符对象。</li></ul><ol><li>返回值<br> 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<br><code>Object.defineProperty(proxy, property, descriptor)</code><br><code>Reflect.defineProperty(proxy, property, descriptor)</code></li><li>捕获器不变式<br> 如果目标对象不可扩展，则无法定义属性。<br> 如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。<br> 如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</li></ol></blockquote><h3 id="getownpropertydescriptor" tabindex="-1">getOwnPropertyDescriptor <a class="header-anchor" href="#getownpropertydescriptor" aria-label="Permalink to &quot;getOwnPropertyDescriptor&quot;">​</a></h3><blockquote><p>[!example]+ getOwnPropertyDescriptor</p><p><code>getOwnPropertyDescriptor(target, property)</code> 拦截 <code>Object.getOwnPropertyDescriptor()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.getOwnPropertyDescriptor()</code>。</p><ul><li>target: 目标对象。</li><li>property: 要获取描述符的属性名（字符串或符号）。</li></ul><ol><li>返回值<br> 必须返回对象，或者在属性不存在时返回 undefined。</li><li>拦截的操作<br><code>Object.getOwnPropertyDescriptor(proxy, property)</code><br><code>Reflect.getOwnPropertyDescriptor(proxy, property)</code></li><li>捕获器不变式<br> 如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的<br> 对象。<br> 如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。<br> 如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存<br> 在的对象。<br> 如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属<br> 性不存在。<br> 如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。</li></ol></blockquote><h3 id="deleteproperty" tabindex="-1">deleteProperty <a class="header-anchor" href="#deleteproperty" aria-label="Permalink to &quot;deleteProperty&quot;">​</a></h3><blockquote><p>[!example]+ deleteProperty</p><p><code>deleteProperty(target, property)</code> 拦截 <code>delete</code> 操作符的执行。<br> 对应的反射 API 方法为 <code>Reflect.deleteProperty()</code>。</p><ul><li>target: 目标对象。</li><li>property: 要删除的属性名（字符串或符号）。</li></ul><ol><li>返回值<br> 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<br><code>delete proxy.property</code><br><code>delete proxy[property]</code><br><code>Reflect.deleteProperty(proxy, property)</code></li><li>捕获器不变式<br> 如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。</li></ol></blockquote><h3 id="ownkeys" tabindex="-1">ownKeys <a class="header-anchor" href="#ownkeys" aria-label="Permalink to &quot;ownKeys&quot;">​</a></h3><blockquote><p>[!example]+ ownKeys</p><p><code>ownKeys(target)</code> 会在 <code>Object.keys()</code> 及类似方法中被调用。<br> 对应的反射 API 方法为 <code>Reflect.ownKeys()</code>。</p><ul><li>target: 目标对象。</li></ul><ol><li>返回值<br> 必须返回包含字符串或符号的可枚举对象。</li><li>拦截的操作<br><code>Object.getOwnPropertyNames(proxy)</code><br><code>Object.getOwnPropertySymbols(proxy)</code><br><code>Object.keys(proxy)</code><br><code>Reflect.ownKeys(proxy)</code></li><li>捕获器不变式<br> 返回的可枚举对象必须包含 target 的所有不可配置的自有属性。<br> 如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</li></ol></blockquote><h3 id="getprototypeof" tabindex="-1">getPrototypeOf <a class="header-anchor" href="#getprototypeof" aria-label="Permalink to &quot;getPrototypeOf&quot;">​</a></h3><blockquote><p>[!example]+ getPrototypeOf</p><p><code>getPrototypeOf(target)</code> 会拦截 <code>Object.getPrototypeOf()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.getPrototypeOf()</code>。</p><ul><li>target: 目标对象。</li></ul><ol><li>返回值:<br> 对象或 null。</li><li>拦截的操作<br><code>Object.getPrototypeOf(proxy)</code><br><code>Reflect.getPrototypeOf(proxy)</code><br><code>proxy.__proto__</code><br><code>Object.prototype.isPrototypeOf(proxy)</code><br><code>proxy instanceof Object</code></li><li>捕获器不变式<br> 如果 target 不可扩展，则 Object.getPrototypeOf(proxy) 唯一有效的返回值就是 Object.<br> getPrototypeOf(target) 的返回值。</li></ol></blockquote><h3 id="setprototypeof" tabindex="-1">setPrototypeOf <a class="header-anchor" href="#setprototypeof" aria-label="Permalink to &quot;setPrototypeOf&quot;">​</a></h3><blockquote><p>[!example]+ setPrototypeOf</p><p><code>setPrototypeOf(target, prototype)</code> 会拦截 <code>Object.setPrototypeOf()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.setPrototypeOf()</code>。</p><ul><li>target: 目标对象。</li><li>prototype: 新的原型对象或 <code>null</code>。</li></ul><ol><li>返回值<br> 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<br><code>Object.setPrototypeOf(proxy)</code><br><code>Reflect.setPrototypeOf(proxy)</code></li><li>捕获器不变式<br> 如果 target 不可扩展，则唯一有效的 prototype 参数就是 Object.getPrototypeOf(target)<br> 的返回值。</li></ol></blockquote><h3 id="isextensible" tabindex="-1">isExtensible <a class="header-anchor" href="#isextensible" aria-label="Permalink to &quot;isExtensible&quot;">​</a></h3><blockquote><p>[!example]+ isExtensible</p><p><code>isExtensible(target)</code> 会拦截 <code>Object.isExtensible()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.isExtensible()</code>。</p><ul><li>target: 目标对象。</li></ul><ol><li>返回值<br> 必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<br><code>Object.isExtensible(proxy)</code><br><code>Reflect.isExtensible(proxy)</code></li><li>捕获器不变式<br> 如果 target 可扩展，则处理程序必须返回 true。<br> 如果 target 不可扩展，则处理程序必须返回 false。</li></ol></blockquote><h3 id="preventextensions" tabindex="-1">preventExtensions <a class="header-anchor" href="#preventextensions" aria-label="Permalink to &quot;preventExtensions&quot;">​</a></h3><blockquote><p>[!example]+ preventExtensions</p><p><code>preventExtensions(target)</code> 会拦截 <code>Object.preventExtensions()</code> 方法。<br> 对应的反射 API 方法为 <code>Reflect.preventExtensions()</code>。</p><ul><li>target: 目标对象。</li></ul><ol><li>返回值<br> preventExtensions() 必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转<br> 型为布尔值。</li><li>拦截的操作<br><code>Object.preventExtensions(proxy)</code><br><code>Reflect.preventExtensions(proxy)</code></li><li>捕获器不变式<br> 如果 Object.isExtensible(proxy) 是 false，则处理程序必须返回 true。</li></ol></blockquote><h3 id="apply" tabindex="-1">apply <a class="header-anchor" href="#apply" aria-label="Permalink to &quot;apply&quot;">​</a></h3><blockquote><p>[!example]+ apply</p><p>apply(target, thisArg, ...argumentsList) 拦截函数调用。<br> 对应的反射 API 方法为 <code>Reflect.apply()</code>。</p><ul><li>target: 目标函数。</li><li>thisArg: 函数调用时的 <code>this</code> 上下文。</li><li>argumentsList: 调用函数时传递的参数列表。</li></ul><ol><li>返回值<br> 返回值无限制。</li><li>拦截的操作<br><code>proxy(...argumentsList)</code><br><code>Function.prototype.apply(thisArg, argumentsList)</code><br><code>Function.prototype.call(thisArg, ...argumentsList)</code><br><code>Reflect.apply(target, thisArgument, argumentsList)</code></li><li>捕获器不变式<br> target 必须是一个函数对象。</li></ol></blockquote><h3 id="construct" tabindex="-1">construct <a class="header-anchor" href="#construct" aria-label="Permalink to &quot;construct&quot;">​</a></h3><blockquote><p>[!example]+ construct</p><p><code>construct(target, argumentsList, newTarget)</code> 拦截使用 <code>new</code> 运算符构造实例的过程。<br> 对应的反射 API 方法为 <code>Reflect.construct()</code>。</p><ul><li>target: 目标构造函数。</li><li>argumentsList: 构造函数调用时传递的参数列表。</li><li>newTarget: 最初被调用的构造函数。</li></ul><ol><li>返回值<br> 必须返回一个对象。</li><li>拦截的操作<br><code>new proxy(...argumentsList)</code><br><code>Reflect.construct(target, argumentsList, newTarget)</code></li><li>捕获器不变式<br> target 必须可以用作构造函数。</li></ol></blockquote><h2 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h2><p>使用代理可以在代码中实现一些有用的编程模式。</p><ul><li><p>跟踪属性访问<br> 通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获<br> 器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p></li><li><p>隐藏属性<br> 代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p></li><li><p>属性验证<br> 因为所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p></li><li><p>函数与构造函数参数验证<br> 跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。</p></li><li><p>数据绑定与可观察对象<br> 通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p></li></ul>`,61)]))}const y=t(r,[["render",l]]);export{k as __pageData,y as default};
