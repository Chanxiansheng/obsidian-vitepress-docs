import l from"./前端技术_02 CSS_image_flex布局一图.excalidraw.md.DrkY5taZ.js";import{_ as i,c as a,o as s,ae as t}from"./chunks/framework.CIivgcbp.js";const o="/obsidian-vitepress-docs/assets/image_PY1sSQbYfe.DZRH0pyU.png",r="/obsidian-vitepress-docs/assets/image_0U-zRBri0m.mLOPgiZz.png",n="/obsidian-vitepress-docs/assets/image_uBCtY3gEu6.C_-Qrnb5.png",p="/obsidian-vitepress-docs/assets/image_lW6HfdxaIV.BprLcdUi.png",c="/obsidian-vitepress-docs/assets/image_jhh_3e6vuK.BzFWmTtN.png",d="/obsidian-vitepress-docs/assets/image_HKuOZNvh-N.D_WO9rIZ.png",f="/obsidian-vitepress-docs/assets/image_GYlMNGllKm.dNQZjU2w.png",x="/obsidian-vitepress-docs/assets/image_yISyuzSIer.-EOnChqs.png",h="/obsidian-vitepress-docs/assets/image_RirHNSwg87.Dap1dEqs.png",g="/obsidian-vitepress-docs/assets/image_1JT9AvAIXw.Cr6RvR6T.png",u="/obsidian-vitepress-docs/assets/image__na84XyRe7.C_VFl8d9.png",m="/obsidian-vitepress-docs/assets/image_p0NWfhuesv.BMfnR1CM.png",b="/obsidian-vitepress-docs/assets/image_1d6pPzdgIb.BL0Mv8mX.png",_="/obsidian-vitepress-docs/assets/image_6NtP4wIpTc.DF30TT03.png",w="/obsidian-vitepress-docs/assets/image_-grcE0Ue7D.DVVcZKct.png",I=JSON.parse('{"title":"Flex布局","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/02 CSS/02 CSS进阶/核心布局/Flex布局.md","filePath":"前端技术/02 CSS/02 CSS进阶/核心布局/Flex布局.md"}'),k={name:"前端技术/02 CSS/02 CSS进阶/核心布局/Flex布局.md"};function v(q,e,P,y,S,E){return s(),a("div",null,e[0]||(e[0]=[t(`<h1 id="flex布局" tabindex="-1">Flex布局 <a class="header-anchor" href="#flex布局" aria-label="Permalink to &quot;Flex布局&quot;">​</a></h1><p><a href="https://www.w3school.com.cn/css/css3_flexbox.asp?spm=wolai.workspace.0.0.17611a60PSuIaP&amp;file=css3_flexbox.asp" target="_blank" rel="noreferrer">https://www.w3school.com.cn/css/css3_flexbox.asp?spm=wolai.workspace.0.0.17611a60PSuIaP&amp;file=css3_flexbox.asp</a></p><p><a href="https://flexboxfroggy.com/?spm=wolai.workspace.0.0.17611a60PSuIaP" target="_blank" rel="noreferrer">https://flexboxfroggy.com/?spm=wolai.workspace.0.0.17611a60PSuIaP</a></p><ul><li>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。</li><li>我们说 flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 CSS Grid Layout，可以同时处理行和列上的布局。</li><li><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.container {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: flex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flex;       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可以有两种取值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>flex有下面六种属性可以设置在容器上，它们分别是： <ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol></li></ul><p><img src="`+l+'" alt="1200"></p><h3 id="flex-direction主轴" tabindex="-1">flex-direction主轴 <a class="header-anchor" href="#flex-direction主轴" aria-label="Permalink to &quot;flex-direction主轴&quot;">​</a></h3><p>flex-direction<strong>决定主轴的方向(即项目的排列方向)</strong>。它有四个取值：</p><p><code> flex-direction: row | row-reverse | column | column-reverse;</code></p><ul><li>row：从左到右排列 ，默认值</li><li>row-reverse：从右到左排列</li><li>column：从上到下排列;</li><li>column-reverse：从下到上排列</li></ul><h3 id="flex-wrap是否换行" tabindex="-1">flex-wrap是否换行 <a class="header-anchor" href="#flex-wrap是否换行" aria-label="Permalink to &quot;flex-wrap是否换行&quot;">​</a></h3><p>flex-wrap 属性规定是否应该对 flex 项目换行。默认情况下，项目都排在主轴线上。</p><p><code>flex-wrap: nowrap | wrap | wrap-reverse;</code></p><ul><li>nowrap：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。</li><li>wrap：项目主轴总尺寸超出容器时换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><h3 id="flex-flow简写" tabindex="-1">flex-flow简写 <a class="header-anchor" href="#flex-flow简写" aria-label="Permalink to &quot;flex-flow简写&quot;">​</a></h3><p>flex-flow 属性是用于同时设置 flex-direction 和 flex-wrap 属性的简写属性。</p><p><code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</code></p><h3 id="justify-content主轴对齐方式" tabindex="-1">justify-content主轴对齐方式 <a class="header-anchor" href="#justify-content主轴对齐方式" aria-label="Permalink to &quot;justify-content主轴对齐方式&quot;">​</a></h3><p>justify-content定义了项目在主轴的对齐方式。有5个选项值：</p><p><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></p><p>当 flex-direction的排列方向不同时，对齐会依据其有不同的变化，以flex-direction：row为例：</p><ul><li><code>flex-start</code> 左对齐，默认值。</li></ul><p><img src="'+o+'" alt=""></p><ul><li><code>flex-end</code>：右对齐</li></ul><p><img src="'+r+'" alt=""></p><ul><li><code>center</code>：居中</li></ul><p><img src="'+n+'" alt=""></p><ul><li><code>space-between</code>：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。</li></ul><p><img src="'+p+'" alt=""></p><ul><li><code>space-around</code>：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。</li></ul><p><img src="'+c+'" alt=""></p><h3 id="align-items交叉轴对齐方式" tabindex="-1">align-items交叉轴对齐方式 <a class="header-anchor" href="#align-items交叉轴对齐方式" aria-label="Permalink to &quot;align-items交叉轴对齐方式&quot;">​</a></h3><p>align-items定义了项目在交叉轴上的对齐方式。交叉轴，即与主轴垂直的轴。同样有5个选项。</p><p><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></p><p>同样以flex-direction：row为例：</p><ul><li><code>stretch</code>：即如果项目未设置高度或者设为 auto，将占满整个容器的高度，为默认值。</li></ul><p><img src="'+d+'" alt=""></p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li></ul><p><img src="'+f+'" alt=""></p><ul><li><code>flex-end</code>：交叉轴的终点对齐</li></ul><p><img src="'+x+'" alt=""></p><ul><li><code>center</code>：交叉轴的中点对齐</li></ul><p><img src="'+h+'" alt=""></p><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐</li></ul><p><img src="'+g+'" alt=""></p><h3 id="align-content多轴线对齐方式" tabindex="-1">align-content多轴线对齐方式 <a class="header-anchor" href="#align-content多轴线对齐方式" aria-label="Permalink to &quot;align-content多轴线对齐方式&quot;">​</a></h3><p>align-content定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用。</p><p><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></p><p>当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><ul><li><code>stretch</code> 值拉伸弹性线以占据剩余空间，为默认值。</li></ul><p><img src="'+u+'" alt=""></p><ul><li><code>flex-start</code> 值在容器开头显示弹性线。</li></ul><p><img src="'+m+'" alt=""></p><ul><li><code>flex-end</code> 值在容器的末尾显示弹性线。</li><li><code>center</code> 值在容器中间显示弹性线。</li></ul><p><img src="'+b+'" alt=""></p><ul><li><code>space-between</code> 值显示的弹性线之间有相等的间距。</li></ul><p><img src="'+_+'" alt=""></p><ul><li><code>space-around</code> 值显示弹性线在其之前、之间和之后带有空格。</li></ul><p><img src="'+w+'" alt=""></p><h2 id="flex-项目属性" tabindex="-1">Flex 项目属性 <a class="header-anchor" href="#flex-项目属性" aria-label="Permalink to &quot;Flex 项目属性&quot;">​</a></h2><ul><li>有六种属性可运用在 item 项目上： <ol><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ol></li></ul><h4 id="order顺序" tabindex="-1">order顺序 <a class="header-anchor" href="#order顺序" aria-label="Permalink to &quot;order顺序&quot;">​</a></h4><p>order定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0。可以为负数。</p><p><code>order: &lt;integer&gt;;</code></p><h4 id="flex-basis占据主轴空间" tabindex="-1">flex-basis占据主轴空间 <a class="header-anchor" href="#flex-basis占据主轴空间" aria-label="Permalink to &quot;flex-basis占据主轴空间&quot;">​</a></h4><p>flex-basis定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。</p><p><code> flex-basis: &lt;length&gt; | auto;</code></p><h4 id="flex-grow放大比例" tabindex="-1">flex-grow放大比例 <a class="header-anchor" href="#flex-grow放大比例" aria-label="Permalink to &quot;flex-grow放大比例&quot;">​</a></h4><p>flex-grow定义项目的放大比例。默认值为 0。</p><p><code>flex-grow: &lt;number&gt;;</code></p><h4 id="flex-shrink缩小比例" tabindex="-1">flex-shrink缩小比例 <a class="header-anchor" href="#flex-shrink缩小比例" aria-label="Permalink to &quot;flex-shrink缩小比例&quot;">​</a></h4><p>flex-shrink定义了项目的缩小比例。默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。</p><p><code>flex-shrink: &lt;number&gt;;</code></p><h4 id="flex简写" tabindex="-1">flex简写 <a class="header-anchor" href="#flex简写" aria-label="Permalink to &quot;flex简写&quot;">​</a></h4><p>flex是flex-grow, flex-shrink 和 flex-basis的简写。</p><p><code> flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p><h4 id="align-self单项对齐" tabindex="-1">align-self单项对齐 <a class="header-anchor" href="#align-self单项对齐" aria-label="Permalink to &quot;align-self单项对齐&quot;">​</a></h4><p>align-self允许单个项目有与其他项目不一样的对齐方式。</p><p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><p><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code></p>',82)]))}const D=i(k,[["render",v]]);export{I as __pageData,D as default};
