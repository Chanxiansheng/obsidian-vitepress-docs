import{_ as o,c as e,o as c,ag as r}from"./chunks/framework.-ewJmwvT.js";const _=JSON.parse('{"title":"HTML script 标签","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/01 HTML/HTML script标签.md","filePath":"前端技术/01 HTML/HTML script标签.md"}'),i={name:"前端技术/01 HTML/HTML script标签.md"};function a(p,t,s,d,l,n){return c(),e("div",null,t[0]||(t[0]=[r('<h1 id="html-script-标签" tabindex="-1">HTML script 标签 <a class="header-anchor" href="#html-script-标签" aria-label="Permalink to &quot;HTML script 标签&quot;">​</a></h1><p>将 JavaScript 插入 HTML 的主要方法是使用 <code>&lt;script&gt;</code> 元素。</p><p><code>&lt;script&gt;</code> 元素有下列 8 个属性：</p><ul><li><code>async</code>：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</li><li><code>defer</code>：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。</li><li><code>charset</code>：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li><li><code>crossorigin</code>：可选。配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin=&quot;anonymous&quot; 配置文件请求不必设置凭据标志。crossorigin=&quot;use-credentials&quot; 设置凭据标志，意味着出站请求会包含凭据。</li><li><code>integrity</code>：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI， Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</li><li><code>language</code>：废弃。最初用于表示代码块中的脚本语言（如 &quot;JavaScript&quot;、&quot;JavaScript 1.2&quot; 或 &quot;VBScript&quot;）。大多数浏览器都会忽略这个属性，不应该再使用它。</li><li><code>src</code>：可选。表示包含要执行的代码的外部文件。</li><li><code>type</code>：可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。JavaScript 文件的 MIME 类型通常是 &quot;application/x-javascript&quot;，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有 &quot;application/javascript&quot; 和 &quot;application/ecmascript&quot;。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。</li></ul><p>使用 <code>&lt;script&gt;</code> 的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</p><p>过去，所有 <code>&lt;script&gt;</code> 元素都被放在页面的 <code>&lt;head&gt;</code> 标签内。这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，这就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。<br> 为解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中的页面内容后面。</p><p>==可以使用 <strong>defer(延迟)</strong> 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出==<br> ==的次序执行。==</p><p>==可以使用 <strong>async(异步)</strong> 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异==<br> ==步脚本不能保证按照它们在页面中出现的次序执行。==</p><p>通过使用 <code>&lt;noscript&gt;</code> 元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启<br> 用脚本，则 <code>&lt;noscript&gt;</code> 元素中的任何内容都不会被渲染。</p>',9)]))}const g=o(i,[["render",a]]);export{_ as __pageData,g as default};
