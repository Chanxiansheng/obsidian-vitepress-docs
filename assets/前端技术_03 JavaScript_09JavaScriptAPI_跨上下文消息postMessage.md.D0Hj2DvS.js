import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.-ewJmwvT.js";const g=JSON.parse('{"title":"跨上下文消息 postMessage","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/09JavaScriptAPI/跨上下文消息postMessage.md","filePath":"前端技术/03 JavaScript/09JavaScriptAPI/跨上下文消息postMessage.md"}'),n={name:"前端技术/03 JavaScript/09JavaScriptAPI/跨上下文消息postMessage.md"};function p(l,s,o,r,h,k){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="跨上下文消息-postmessage" tabindex="-1">跨上下文消息 postMessage <a class="header-anchor" href="#跨上下文消息-postmessage" aria-label="Permalink to &quot;跨上下文消息 postMessage&quot;">​</a></h1><p>跨文档消息，有时候也简称为 XDM（cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力。</p><p>XDM 的核心是 <code>postMessage()</code> 方法。</p><blockquote><p>[!example]+ ​<strong>postMessage()</strong></p><p><code>target.postMessage(message, targetOrigin, [transfer])</code> 用于跨窗口/跨线程安全通信，支持跨源数据传递（如窗口间、主线程与 Web Worker 间）。</p><ul><li><code>message</code>: 要发送的数据（需支持结构化克隆算法，如基础类型、Array、Object 等）</li><li><code>targetOrigin</code>: 接收方的源（字符串或 URI），设为 <code>&quot;*&quot;</code> 表示不限制源（存在安全风险）</li><li><code>transfer</code> (可选): 可转移对象（如 ArrayBuffer）的所有权数组，转移后原上下文将无法访问</li></ul><p>​<strong>返回值</strong>: <code>undefined</code>（无返回值，仅执行发送操作）</p><p>​<strong>注意点</strong>：</p><ul><li>接收方需通过 <code>message</code> 事件监听消息</li><li>数据通过结构化克隆传输，无法传递函数、DOM 节点等不可序列化对象</li><li>严格设置 <code>targetOrigin</code> 避免安全漏洞</li><li>传递大型数据（如 ArrayBuffer）时优先用 <code>transfer</code> 参数提升性能</li><li>主线程与 Web Worker 间的通信需通过 <code>worker.postMessage()</code> 和 <code>self.postMessage()</code> 实现</li></ul></blockquote><p>接收到 XDM 消息后，window 对象上会触发 message 事件。这个事件是异步触发的，因此从消息发出到接收到消息（接收窗口触发 message 事件）可能有延迟。传给 onmessage 事件处理程序的 event 对象包含以下 3 方面重要信息。</p><ul><li><strong>data</strong>：作为第一个参数传递给 <code>postMessage()</code> 的字符串数据。</li><li><strong>origin</strong>：发送消息的文档源，例如 <code>&quot;http://www.wrox.com&quot;</code></li><li><strong>source</strong>：发送消息的文档中 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中执行 <code>postMessage()</code> 方法。如果发送窗口有相同的源，那么这个对象应该就是 window 对象。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 确保来自预期发送者</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.origin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://www.wrox.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 对数据进行一些处理</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		processMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 可选：向来源窗口发送一条消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		event.source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Received!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://p2p.wrox.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>在通过内嵌窗格加载不同域时，使用 XDM 是非常方便的。这种方法在混搭（mashup）和社交应用中非常常用。通过使用 XDM 与内嵌窗格中的网页通信，可以保证包含页面的安全。XDM 也可以用于同源页面之间通信。</p>`,8)]))}const c=i(n,[["render",p]]);export{g as __pageData,c as default};
