import{_ as h,C as k,c as e,o as d,ae as n,j as i,a,G as t,w as p}from"./chunks/framework.CIivgcbp.js";const b=JSON.parse('{"title":"CSharp02 面向对象","description":"","frontmatter":{},"headers":[],"relativePath":"语言学习/CSharp/CSharp02面向对象.md","filePath":"语言学习/CSharp/CSharp02面向对象.md"}'),r={name:"语言学习/CSharp/CSharp02面向对象.md"};function E(g,s,c,y,o,F){const l=k("font");return d(),e("div",null,[s[14]||(s[14]=n(`<h1 id="csharp02-面向对象" tabindex="-1">CSharp02 面向对象 <a class="header-anchor" href="#csharp02-面向对象" aria-label="Permalink to &quot;CSharp02 面向对象&quot;">​</a></h1><h2 id="调试和错误处理" tabindex="-1">调试和错误处理 <a class="header-anchor" href="#调试和错误处理" aria-label="Permalink to &quot;调试和错误处理&quot;">​</a></h2><ul><li><p>中断模式指我们可以暂停程序的执⾏，然后查看程序中的状态，也可以让程序继续执⾏。</p></li><li><p>断点是源代码中⾃动进⼊中断模式的⼀个标记，当遇到断点的时候，程序会进⼊中断模 式。</p></li><li><p>如何插⼊断点？</p><ol><li>右击代码⾏，选择 breakpoint(断点) -&gt; insert breakpoint（插⼊断点）</li><li>光标定位到代码⾏，选择菜单上的 Debug(调试)-&gt;Toggle Breakpoint(切换断点)</li><li>光标定位到代码⾏，按下 F9 键，在此按下 F9 是取消断点</li><li>在需要添加断点的⾏⾸位置，直接单击，再次单击取消断点</li></ol></li><li><p>窗⼝ Breakpoints：我们可以通过 (调试 - 窗⼝ - 断点)，打开断点窗⼝，这个窗⼝显⽰了当前项⽬中添加了的所有的断点，我们可以在这⾥定位断点的位置，也可以去删除断点。</p></li><li><p>监视变量的内容：在中断模式下查看变量值最简单的⽅式，就是把⿏标指向源代码中的变量名，此时会出现 ⼀个⼯具提⽰，显⽰该变量的信息。</p></li><li><p>中断模式下的窗⼝（左下⾓），有三个选项卡：</p><ul><li>错误列表 - 程序运⾏中发⽣的所有错误的列表</li><li>局部变量 - 当前运⾏环境中所有的局部变量的值</li><li>监视 - 监视某个变量的值的变化 在上⾯的⼏个窗⼝中不但可以观察变量值的变化，还可以直接去修改变量中存储的值</li></ul></li><li><p>调⽤堆栈和即时窗⼝： 在中断模式下，可以在右下⾓看到调⽤堆栈和即时窗⼝。在调⽤堆栈窗⼝下我们可以观察到当前代码执⾏到哪⼀⾏了，并且可以看到这个代码的是 被什么语句调⽤的 即时窗⼝我们可以在这⾥输⼊⼀些命令，查看变量的值，修改变量的值，可以输⼊表达式查看结果。</p></li><li><p>单步执⾏代码：在中断模式下我们可以单步执⾏代码，单步执⾏带有有两种 逐过程和逐语句，他们两个 都是⼀条语句⼀跳语句的执⾏，区别在于逐过程遇到函数，不会进⼊函数内部，⽽把函数 当成⼀条语句去执⾏。</p></li></ul><h3 id="异常处理语句" tabindex="-1">异常处理语句 <a class="header-anchor" href="#异常处理语句" aria-label="Permalink to &quot;异常处理语句&quot;">​</a></h3><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其中 catch 块可以有 0 或者多个，finally 可以有 0 或者 1 个</p><h2 id="什么是面向对象" tabindex="-1">什么是面向对象 <a class="header-anchor" href="#什么是面向对象" aria-label="Permalink to &quot;什么是面向对象&quot;">​</a></h2><p>为了让编程更加清晰，把程序中的功能进⾏模块化划分，每个模块提供特定的功能，⽽且 每个模块都是孤⽴的，这种模块化编程提供了⾮常⼤的多样性，⼤⼤增加了重⽤代码的机 会。<br> ⾯向对象编程也叫做 OOP 编程，简单来说⾯向对象编程就是结构化编程，对程序中的变量结构划分，让编程更清晰。<br> 面向对象的三大特性：封装、继承、多态。</p><h3 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h3><ul><li><p>类是什么东⻄？<br> 类实际上是创建对象的模板，每个对象都包含数据，并提供了处理和访问数据的⽅法。 类定义了类的每个对象（称为实例）可以包含什么数据和功能。</p></li><li><p>类中的数据和函数称为类的成员</p><ul><li>数据成员： 数据成员是包含类的数据 -- 字段，常量和事件的成员。</li><li>函数成员： 函数成员提供了操作类中数据的某些功能。（⽅法，属性，构造⽅法和终结器（析构 ⽅法），运算符，和索引器）</li></ul></li><li><p>类的声明</p></li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">访问标识符</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> class &lt;类名&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	...各种成员	</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p>类的字段和⽅法</p><ul><li>字段的声明 <code>&lt;访问修饰符&gt; &lt;类型&gt; &lt;字段名称&gt;;</code></li><li>⽅法的声明 <code>&lt;访问修饰符&gt; &lt;返回值类型&gt; &lt;方法名称&gt;(参数){ //⽅法体 }</code></li></ul></li><li><p>类的实例化</p></li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClassName</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h3>`,14)),i("p",null,[s[1]||(s[1]=a("我们构造对象的时候，对象的初始化过程是⾃动完成的，但是在初始化对象的过程中有的 时候需要做⼀些额外的⼯作，例如需要初始化对象存储的数据，构造函数就是⽤于初始化 数据的函数。")),s[2]||(s[2]=i("br",null,null,-1)),s[3]||(s[3]=a(" 声明基本的构造函数的语法就是声明⼀个")),t(l,{color:"#ff0000"},{default:p(()=>s[0]||(s[0]=[a("和所在类同名的⽅法")])),_:1,__:[0]}),s[4]||(s[4]=a("，但是该⽅法没有返回类 型。"))]),s[15]||(s[15]=n(`<div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	 //这个构造函数的函数体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当我们使⽤ <code>new</code> 关键字创建类的时候，就会调⽤构造⽅法。</p><h3 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h3><ul><li>属性的定义结构</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyIntProp{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	get{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// get code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	set{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//set code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li>定义属性需要名字和类型</li><li>属性包含两个块 get 块和 set 块 ，可以只提供⼀个 set 块或者 get 块</li><li>访问属性和访问字段⼀样，当取得属性的值的时候，就会调⽤属性中的 get 块，所以<br> get 块，类型需要⼀个返回值就是属性的类型；当我们去给属性设置值的时候，就会调⽤<br> 属性中的 set 块，我们可以在 set 块中通过 value 访问到我们设置的值。</li></ol><ul><li><p>属性与字段的区别</p><ol><li>我们习惯上把字段设置为私有的，这样外界不能修改字段的值，然后我们可以通过定义属性来设置和取得字段的值。</li><li>习惯上属性⼤写，字段⼩写</li></ol></li><li><p>⾃动实现的属性<br><code>public int Age{get;set;}</code> ，编译器会⾃动创建 private int age 属性</p></li><li><p>匿名类型<br> 我们创建变量（对象的时候），必须指定类型，其实我们也可以不去指定类型，这个就是 匿名类型，我们可以使⽤ var 声明⼀个匿名类型。 使⽤ var 声明的匿名类型，当初始化的时候，这个变量的类型就被确定下来，并且以后不可以修改。</p></li></ul><blockquote><p><strong>堆 栈 静态存储区</strong><br> 程序所有的数据，也就是所有的变量，都是存储在内存中的。<br> 栈空间⽐较⼩，但是读取速度快<br> 堆空间⽐较⼤，但是读取速度慢</p></blockquote><blockquote><p><strong>值类型和引⽤类型</strong><br> 类型被分为两种：值类型 (整数，bool struct char ⼩数) 和引⽤类型（string 数组 ⾃定义的 类，内置的类）。<br> 值类型只需要⼀段单独的内存，⽤于存储实际的数据，（单独定义的时候放在栈中）<br> 引⽤类型需要两段内存 第⼀段存储实际的数据，它总是位于堆中，第⼆段是⼀个引⽤，指向数据在堆中的存放位置。</p></blockquote><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3>`,10)),i("ul",null,[i("li",null,[s[12]||(s[12]=i("p",null,"继承的类型",-1)),i("ol",null,[s[10]||(s[10]=i("li",null,[i("p",null,"实现继承： 表⽰⼀个类型派⽣于⼀个基类型,它拥有该基类型的所有成员字段和函数。 在实现继 承中,派⽣类型采⽤基类型的每个函数的实现代码,除⾮在派⽣类型的定义中指定重写 某个函数的实现代码。 在需要给现有的类型添加功能,或许多相关的类型共享⼀组重 要的公共功能时,这种类型的继承⾮常有⽤。")],-1)),s[11]||(s[11]=i("li",null,[i("p",null,"接⼝继承： 表⽰⼀个类型只继承了函数的签名,没有继承任何实现代码。 在需要指定该类型具有 某些可⽤的特性时,最好使⽤这种类型的继承。")],-1)),i("li",null,[i("p",null,[s[7]||(s[7]=a("多重继承：⼀些语⾔ (C++) ⽀持所谓的 “多重继承”，即⼀个类派⽣⾃多个类。 使⽤多重继承的优点是有争议的: ⼀⽅⾯,毫⽆疑问，可以使⽤多重继承编写⾮常复杂、 但很紧凑的代码。另⼀⽅⾯，使⽤多重实现继承的代码常常很难理解和调试。 如前所述，简化健壮代码的编写⼯作是开发 C#的重要设计⽬标。 因此，")),t(l,{color:"#ff0000"},{default:p(()=>s[5]||(s[5]=[a("C#不⽀持多重实现继承。")])),_:1,__:[5]}),s[8]||(s[8]=a(" ⽽ ")),t(l,{color:"#ff0000"},{default:p(()=>s[6]||(s[6]=[a("C#允许类型派⽣⾃多个接⼝— —多重接⼝继承")])),_:1,__:[6]}),s[9]||(s[9]=a("。 这说明,C#类可以派⽣⾃另⼀个类和任意多个接⼝。更准确地说, System.Object 是⼀个公共的基类，所以每个 C#(除了 Object 类之外) 都有⼀个基类,还可以有任意多个基接⼝。"))])])])]),s[13]||(s[13]=i("li",null,[i("p",null,"继承的实现")],-1))]),s[16]||(s[16]=n(`<div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyBaseclass</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// functions and data members here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyBaseClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInterface1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInterface2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// etc.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>虚方法<br> 把⼀个基类函数声明为 <code>virtual</code>,就可以在任何派⽣类中重写该函数:</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyBaseClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Method is called in base class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyBaseClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Method is called in derivedclass.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在派⽣类中重写另外⼀个函数时，要使⽤ <code>override</code> 关键字显⽰声明。</p><ul><li>隐藏⽅法<br> 如果签名相同的⽅法在基类和派⽣类中都进⾏了声明，但是该⽅法没有分别声明为 virtual 和 override，派⽣类就会隐藏基类⽅法。（要使⽤ new 关键字进⾏声明）</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyBaseClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyBaseClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>抽象类</li></ul><p>C#允许把类和函数声明为 <code>abstract</code>。 抽象类不能实例化，抽象类可以包含普通函数和抽象函数，抽象函数就是只有函数定义没有函数体。 显然，抽象函数本⾝也是虚拟的 Virtual(只有函数定义，没有函数体实现)。 类是⼀个模板，那么抽象类就是⼀个不完整的模板，我们不能使⽤不完整的模板去构造对象。</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Building</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> decimal</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CalculateHeatingCost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>密封类和密封⽅法</li></ul><p>C#允许把类和⽅法声明为 <code>sealed</code>。 对于类 ,这表⽰不能继承该类；对于⽅法表⽰不能重 写该⽅法。</p><p>主要目的是防⽌重写某些类导致代码混乱或者商业原因。</p><ul><li>派⽣类（⼦类）的构造函数 <ol><li>在⼦类中调⽤⽗类的默认构造函数（⽆参）（会先调⽤⽗类的，然后是⼦类的），<code>:base()</code> 可以直接不写，因为默认会调⽤⽗类中的默认构造函数。</li><li>调⽤有参数的构造函数</li></ol></li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyDerivedClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">base</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="修饰符一览" tabindex="-1">修饰符一览 <a class="header-anchor" href="#修饰符一览" aria-label="Permalink to &quot;修饰符一览&quot;">​</a></h3><p><code>public</code>: 同⼀程序集 (DLL 或 EXE) 中的任何其他代码或引⽤该程序集的其他程序集都可<br> 以访问该类型或成员。</p><p><code>private</code>: 只有同⼀类或结构中的代码可以访问该类型或成员。</p><p><code>protected</code>: 只有同⼀类或结构或者此类的派⽣类中的代码才可以访问该类型或成员。</p><p><code>internal</code>: 同⼀程序集中的任何代码都可以访问该类型或成员，但的代码不可以。</p><p><code>protected internal</code>: 在⼀程序集中，protected internal 体现的是 internal 的性质；在其<br> 他程序集中，protected internal 体现的是 protected 的性质。</p><p><code>new</code><br> 隐藏继承的成员</p><p><code>abstract</code><br> 使⽤ abstract 修饰的类为抽象类，抽象类只能是其他类的基类，不能与 sealed、static ⼀起使⽤。<br> abstract 可以修饰抽象类中的⽅法或属性，此时，⽅法或属性不能包含实现，且访问级别<br> 不能为私有。抽象类不能被实例化。</p><p><code>sealed</code><br> 使⽤ sealed 修饰的类为密封类，密封类⽆法被继承，不能和 abstract、static ⼀起使⽤。当 sealed ⽤于⽅法或属性时，必须始终与 override ⼀起使⽤。</p><p><code>static</code><br> 使⽤ static 修饰的类为静态类，静态类所有成员都必须是静态的，不能与 abstract、sealed<br> ⼀起使⽤。<br> static 可以修饰⽅法、字段、属性或事件，始终通过类名⽽不是实例名称访问静态成员，<br> 静态字段只有⼀个副本。静态类不能被实例化。</p><p><code>const</code><br> 使⽤ const 关键字来声明某个常量字段或常量局部变量，必须在声明常量时赋初值。<br> 不能与 static ⼀起使⽤，常量默认是 static 的，常量字段只有⼀个副本。</p><p><code>readonly</code><br> 使⽤ readonly 关键字来声明只读字段。<br> 只读字段可以在声明或构造函数中初始化，每个类或结构的实例都有⼀个独⽴的副本。<br> 可以与 static ⼀起使⽤，声明静态只读字段。<br> 静态只读字段可以在声明或静态构造函数中初始化，静态常量字段只有⼀个副本。</p><p><code>virtual</code><br> virtual 关键字⽤于修饰⽅法、属性、索引器或事件声明，并使它们可以在派⽣类中被重<br> 写。默认情况下，⽅法是⾮虚拟的。 不能重写⾮虚⽅法。<br> virtual 修饰符不能与 static、abstract、private 或 override 修饰符⼀起使⽤。</p><p><code>override</code><br> 要扩展或修改继承的⽅法、属性、索引器或事件的抽象实现或虚实现，必须使⽤ override<br> 修饰符。<br> 重写的成员必须是 virtual、abstract 或 override 的。</p><h3 id="接口" tabindex="-1">接口 <a class="header-anchor" href="#接口" aria-label="Permalink to &quot;接口&quot;">​</a></h3><p>定义接⼝</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IFlyHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>实现接口</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Type1Enemy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IFlyHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ }</span></span></code></pre></div><p>定义⼀个接⼝在语法上跟定义⼀个抽象类完全相同，但不允许提供接⼝中任何成员的实现 ⽅式，⼀般情况下，接⼝只能包含⽅法，属性，索引器和事件的声明。 接⼝不能有构造函数，也不能有字段，接⼝也不允许运算符重载。 接⼝定义中不允许声明成员的修饰符，接⼝成员都是公有的。</p><p>接⼝可以彼此继承，其⽅式和类的继承⽅式相同</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Method1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Method2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h3><ul><li><p>泛型是什么？<br> 通过参数化类型来实现在同⼀份代码上操作多种数据类型。利⽤“参数化类型”将类型抽象 化，从⽽实现灵活的复⽤。</p></li><li><p>泛型类定义<br> 定义⼀个泛型类就是指的是，定义⼀个类，这个类中某些字段的类型是不确定的，这些类<br> 型可以在类构造的时候确定下来。</p></li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a ;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">“”</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>泛型⽅法<br> 定义泛型⽅法就是定义⼀个⽅法，这个⽅法的参数的类型可以是不确定的，当调⽤这个⽅ 法的时候再去确定⽅法的参数的类型。</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div>`,41))])}const C=h(r,[["render",E]]);export{b as __pageData,C as default};
