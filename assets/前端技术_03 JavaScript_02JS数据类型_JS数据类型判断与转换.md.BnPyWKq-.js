import{_ as i,c as s,o as a,ae as e}from"./chunks/framework.CIivgcbp.js";const l="/obsidian-vitepress-docs/assets/60e869154bf3479eadc1cb7598c9834d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.Crzy5mp9.webp",y=JSON.parse('{"title":"JS 数据类型判断与转换","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/02JS数据类型/JS数据类型判断与转换.md","filePath":"前端技术/03 JavaScript/02JS数据类型/JS数据类型判断与转换.md"}'),n={name:"前端技术/03 JavaScript/02JS数据类型/JS数据类型判断与转换.md"};function h(p,t,r,k,d,o){return a(),s("div",null,t[0]||(t[0]=[e(`<h1 id="js-数据类型判断与转换" tabindex="-1">JS 数据类型判断与转换 <a class="header-anchor" href="#js-数据类型判断与转换" aria-label="Permalink to &quot;JS 数据类型判断与转换&quot;">​</a></h1><h2 id="数据类型分类" tabindex="-1">数据类型分类 <a class="header-anchor" href="#数据类型分类" aria-label="Permalink to &quot;数据类型分类&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">类型</th><th style="text-align:left;">存储方式</th></tr></thead><tbody><tr><td style="text-align:left;">基本数据类型</td><td style="text-align:left;">Number，String，Boolean，null，undefined，symbol（ES6），bigint（ES6）</td><td style="text-align:left;">直接存储在**==栈==**中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。</td></tr><tr><td style="text-align:left;">复杂 (引用) 数据类型</td><td style="text-align:left;"><p style="box-sizing:inherit;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-border-opacity:1;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-blur:var(--tw-empty,   );--tw-brightness:var(--tw-empty,   );--tw-contrast:var(--tw-empty,   );--tw-grayscale:var(--tw-empty,   );--tw-hue-rotate:var(--tw-empty,   );--tw-invert:var(--tw-empty,   );--tw-saturate:var(--tw-empty,   );--tw-sepia:var(--tw-empty,   );--tw-drop-shadow:var(--tw-empty,   );--tw-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);--tw-backdrop-blur:var(--tw-empty,   );--tw-backdrop-brightness:var(--tw-empty,   );--tw-backdrop-contrast:var(--tw-empty,   );--tw-backdrop-grayscale:var(--tw-empty,   );--tw-backdrop-hue-rotate:var(--tw-empty,   );--tw-backdrop-invert:var(--tw-empty,   );--tw-backdrop-opacity:var(--tw-empty,   );--tw-backdrop-saturate:var(--tw-empty,   );--tw-backdrop-sepia:var(--tw-empty,   );--tw-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);border:0px solid rgb(221, 221, 221);font-size:14px;margin:12px 0px;padding:0px;user-select:text;outline:none;line-height:1.8;word-break:break-word;color:rgb(0, 0, 0);font-family:&quot;PingFang SC&quot;, &quot;Source Han Sans CN&quot;, &quot;Microsoft YaHei&quot;, system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;Segoe UI&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, sans-serif;">object：包括普通对象，数组对象，正则对象，日期对象，Math 数学函数对象。<br></p></td><td style="text-align:left;">存储在**==堆==**内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</td></tr></tbody></table><h2 id="类型判断方法" tabindex="-1">类型判断方法 <a class="header-anchor" href="#类型判断方法" aria-label="Permalink to &quot;类型判断方法&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">基础数据类型</th><th style="text-align:left;">引用类型</th><th style="text-align:left;">注意事项</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>typeof</strong></td><td style="text-align:left;">√</td><td style="text-align:left;">×</td><td style="text-align:left;">NaN、object、document.all</td></tr><tr><td style="text-align:left;"><strong>toString</strong></td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;">对象的 Symbol.toStringTag 可能会被篡改</td></tr><tr><td style="text-align:left;">constructor</td><td style="text-align:left;">√ 部分</td><td style="text-align:left;">√</td><td style="text-align:left;">可以被改写</td></tr><tr><td style="text-align:left;">instanceof</td><td style="text-align:left;">×</td><td style="text-align:left;">√</td><td style="text-align:left;">右边构造函数或者 class</td></tr><tr><td style="text-align:left;">isPrototypeof</td><td style="text-align:left;">×</td><td style="text-align:left;">√</td><td style="text-align:left;">小心 null 和 undefined</td></tr><tr><td style="text-align:left;">鸭子类型</td><td style="text-align:left;">-</td><td style="text-align:left;">√</td><td style="text-align:left;">不得已兼容</td></tr><tr><td style="text-align:left;">Symbol.toStringTag</td><td style="text-align:left;">×</td><td style="text-align:left;">√</td><td style="text-align:left;">识别自定义对象</td></tr><tr><td style="text-align:left;">等比较</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;">特殊对象</td></tr></tbody></table><p>其中，最为常用的是 typeof 和 toString 方法。</p><h3 id="typeof" tabindex="-1">typeof <a class="header-anchor" href="#typeof" aria-label="Permalink to &quot;typeof&quot;">​</a></h3><ul><li>typeof 是一个关键字，只能识别简单数据类型，引用类型均为 object。</li><li>注意 null、 NaN、 Undefined 的判断</li><li>语法：<code>typeof XXX</code></li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">typeof 返回值</th><th style="text-align:left;">对象包装器</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>NaN</strong></td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;"><strong>Null</strong></td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;"><strong>Undefined</strong></td><td style="text-align:left;"><code>undefined</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;">Boolean</td><td style="text-align:left;"><code>boolean</code></td><td style="text-align:left;">Boolean</td></tr><tr><td style="text-align:left;">Number</td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;">BigInt</td><td style="text-align:left;"><code>bigint</code></td><td style="text-align:left;">BigInt</td></tr><tr><td style="text-align:left;">String</td><td style="text-align:left;"><code>string</code></td><td style="text-align:left;">String</td></tr><tr><td style="text-align:left;">Symbol</td><td style="text-align:left;"><code>symbol</code></td><td style="text-align:left;">Symbol</td></tr><tr><td style="text-align:left;">Function</td><td style="text-align:left;"><code>function</code></td><td style="text-align:left;">Function</td></tr><tr><td style="text-align:left;">Object、Array 等</td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">对应的引用数据类型</td></tr></tbody></table><h3 id="tostring" tabindex="-1">toString <a class="header-anchor" href="#tostring" aria-label="Permalink to &quot;toString&quot;">​</a></h3><p>toString 是 Object 原型上的方法，<code>Object.prototype.toString()</code></p><p>当 toString 方法被调用的时候，下面的步骤会被执行：</p><ol><li>如果 this 值是 undefined，就返回 <code>[object Undefined]</code></li><li>如果 this 的值是 null，就返回 <code>[object Null]</code></li><li>（ES6 新增）获取 this 指向对象的 <code>[Symbol.toStringTag]</code> 属性值</li><li>获取 this 指向对象的 <code>[[Class]]</code> 属性（该属性不能外部查询）的值。</li><li>最后返回由 <code>[object</code> 和 <code>class</code> 和 <code>]</code> 三个部分组成的字符串<br> 通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 &quot;<code>[object &quot; 和 class 和 &quot;]</code>&quot; 组成的字符串，其中 class 是要判断对象的内部属性。</li></ol><p>虽然 JS 中 Object 为顶级对象，任意实例理应可以直接使用 toString 方法，但是由于许多类型重写了该方法 (例如 Array)，因此需要借助 call/apply 进行使用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Undefined]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Null]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Number]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Number]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object String]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Boolean]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Object]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[object Array]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span></code></pre></div><p>由于返回类型格式问题，可以自行封装返回值：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> typeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Symbol.toStringTag 问题<br><code>Symbol.toStringTag</code> 是 ES6 中新增的属性，只读。如果对象类型存在该属性，toString 会优先返回该属性，该方法可以代替对 toString 的重写。<br> toStringTag 适用于所有 DOM 原型对象，由于 2020 年年中 <a href="https://github.com/whatwg/webidl/pull/357" target="_blank" rel="noreferrer">WebIDL 规范的变化</a>，浏览器正在向所有 DOM 原型对象添加 <code>Symbol.toStringTag</code> 属性。</p><p>缺点：</p><ul><li>toString 会进行 <code>装箱操作</code>，产生很多<strong>临时对象</strong>（所以真正进行类型转换时建议配合 <code>typeof</code> 来区分是对象类型还是基本类型）</li><li>他无法区分<strong>自定义对象类型</strong>，用来判断这类对象时，返回的都是 <code>Object</code>（针对“自定义类型”可以采用 <code>instanceof</code> 区分）</li></ul><h3 id="instanceof" tabindex="-1">instanceof <a class="header-anchor" href="#instanceof" aria-label="Permalink to &quot;instanceof&quot;">​</a></h3><p>instanceof 是一个关键字，instance 是英语实例的意思，即判断一个实例是否属于某种类或构造函数。</p><ul><li>原理：判断实例的 <strong>proto</strong> 是否全等于类的 propotype。</li><li>可参考 <a href="./../03对象与函数/JS面向对象与原型链.html#原型链">D-学习笔记/前端技术/03 JavaScript/03对象与函数/JS面向对象与原型链 &gt; 原型链</a></li><li>语法：<code>object instanceof constructor</code><ul><li>object：某个实例对象</li><li>constructor：某个类或构造函数</li></ul></li><li>简单实现：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myInstanceOf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parentP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 向上递归</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parentP){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		childP </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childP.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><code>isPrototypeOf()</code><br> 判断对象是否在自己的原型链上<br> 它是 Object 上的实例方法，与 instanceo 的区别在于，instanceof 只会判断某个对象实例，而这个方法可以直接使用原型对象进行判断。<br> 示例：<br><code>constructor.prototype.isPrototypeOf(object)</code><br><code>Object.isPrototypeOf(object)</code></p></blockquote><h2 id="类型转换" tabindex="-1">类型转换 <a class="header-anchor" href="#类型转换" aria-label="Permalink to &quot;类型转换&quot;">​</a></h2><p>类型转换指将一种类型转换为另一种类型，分为显式类型转换和隐式类型转换。</p><h3 id="装箱-拆箱" tabindex="-1">装箱/拆箱 <a class="header-anchor" href="#装箱-拆箱" aria-label="Permalink to &quot;装箱/拆箱&quot;">​</a></h3><p>为了方便操作基本数据类型， ECMAScript 还提供了三个特殊的引用类型，基本包装类型，String、Boolean、Number。有了这三个类型，在需要的时候，原始类型会自动转换成相应的包装对象（这个过程叫自动装箱）。自动装箱就是临时创建一个包装对象，将原始类型的值封装起来，以便调用包装对象的函数。但是原来那个变量的值不会有任何变化。</p><blockquote><p>扩展：什么是装箱操作？<br><code>“装箱”</code> 就是把基本类型用它们相应的引用类型包装起来，使其具有对象的性质。可以简单理解为 <strong>“包装类”</strong>。<br> 而对应的“拆箱”，就是将引用类型的对象简化成值类型的数据。</p></blockquote><p>例如在使用字符串方法的时候，<code>&#39;str&#39;.indexOf()</code> ，字符串是基本数据类型，为什么能直接调用方法呢，这其实在后台进行了一系列的操作:</p><ol><li>创建 String 类型的一个实例</li><li>在实例上调用指定的方法。</li><li>销毁这个实例。<br> 当然，你可以将 Boolean 、Number 、String 这三个函数当作构造函数来使用，通过手动 new 包装类来装箱（得到包装对象）。</li></ol><h3 id="类型转换规则" tabindex="-1">类型转换规则 <a class="header-anchor" href="#类型转换规则" aria-label="Permalink to &quot;类型转换规则&quot;">​</a></h3><p><img src="`+l+`" alt="60e869154bf3479eadc1cb7598c9834dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp"></p><p>Toprimitive 内部方法:<br> Toprimitive 是一个内部方法，没有任何暴露，它将一个数据转化为原始类型<br><code>Toprimitive(v,PreferredType?)</code><br> v 是要转换的值， PreferredType 是可选参数，仅能为 Number 或 String</p><p>PreferredType 的值会按照这样的规则来自动设置：</p><ol><li>该对象为 Date 类型，则 PreferredType 被设置为 String</li><li>否则，PreferredType 被设置为 Number</li></ol><p>如果 preferredType 为 Number，ToPrimitive 执行过程如下：</p><ol><li>如果 data 为原始类型，直接返回；</li><li>对象将依次调用它的 <code>[Symbol.toPrimitive]()</code>、<code>valueOf()</code> 和 <code>toString()</code> 方法，将其转换为原始值。</li></ol><p>如果 preferredType 为 String，valueOf() 和 toString() 顺序调换，即：</p><ol><li>如果 data 为原始类型，直接返回；</li><li>对象将依次调用它的 <code>[Symbol.toPrimitive]()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法，将其转换为原始值。</li></ol><p>当 <code>({}) + yes</code> 被执行时，js 内部会发生什么？</p><ol><li>{} 和 yes 都会调用 ToPrimitive，yes 原始类型直接返回。</li><li>{} 内部调用 DefaultNumber，使用 valueOf 方法返回 object，为非原始值。</li><li>再调用 toString 方法，返回 <code>[object, object]</code> 字符串。</li><li>所以最后的结果就是 <code>[object, object]yes</code>。</li></ol><blockquote><p>ES6 中新增了 <code>[Symbol.toPrimitive](hint)</code>，是内置的 Symbol 属性，其指定了一种接受首选类型并返回对象原始值的表示的方法。它被所有的强类型转换制算法优先调用，必须有返回的原始值。<br> 参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive" target="_blank" rel="noreferrer">Symbol.toPrimitive - JavaScript | MDN (mozilla.org)</a></p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;派大星&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;yes&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//打印1： [object Object]yes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj[Symbol.toPrimitive] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hint);       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//打印2： default</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;default&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;yes&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//打印3： 派大星yes</span></span></code></pre></div><h3 id="显式类型转换" tabindex="-1">显式类型转换 <a class="header-anchor" href="#显式类型转换" aria-label="Permalink to &quot;显式类型转换&quot;">​</a></h3><p>显式类型转换，即手动调用 <code>Boolean(value)</code>、<code>Number(value)</code>、<code>String(value)</code> 等类型转换方法完成的类型转换。</p><h3 id="隐式类型转换" tabindex="-1">隐式类型转换 <a class="header-anchor" href="#隐式类型转换" aria-label="Permalink to &quot;隐式类型转换&quot;">​</a></h3><p>在某些运算符执行时，因为类型不同无法进行运算，js 引擎会自动将其类型转换之后在进行运算，称为隐式类型转换。</p><p>一元操作符：<br> 会默认调用 ToNumber 方法</p><p>二元操作符：</p><ul><li><p>操作符为 <code>+</code> 号：如果有一边是字符串，执行字符串强制转换，并拼接。否则，执行数字强制转换，并相加。</p></li><li><p>操作符为==号的情况</p><ul><li>如果 x 和 y 是同一类型, <ol><li>同为 undefined,返回 true</li><li>同为 null,返回 true</li><li>x 是数字 x 是 NaN,返回 false</li><li>如果 x 和 y 指向同一个对象,返回 true,否则返回 fasle</li></ol></li><li>特例: null == undefined //true</li><li>1 == &#39;h&#39; 会先 ToNumber(&#39;h&#39;) 再判断</li><li>false == &#39;1&#39; 会先 ToNumber(&#39;false&#39;) ToNumber(&#39;1&#39;)</li><li>true == {a:1} // ToPrimitive({a:1})</li></ul></li><li><p>其他操作符：默认调用 ToNumber 方法</p></li></ul>`,52)]))}const c=i(n,[["render",h]]);export{y as __pageData,c as default};
