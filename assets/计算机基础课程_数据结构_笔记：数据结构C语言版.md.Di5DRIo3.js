import{_ as t,C as l,c as p,o as k,ag as a,j as n,a as i,G as e,w as E}from"./chunks/framework.-ewJmwvT.js";const r="/obsidian-vitepress-docs/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.B3Butv7L.png",d="/obsidian-vitepress-docs/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2.UIZ9yP3z.png",g="/obsidian-vitepress-docs/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3.CDR7CGpl.png",o="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-1.CONADQ7Y.png",y="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-2.mzjDI3ly.png",c="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-3.Cnrm7K2_.png",F="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-4.BMDC__Wo.png",A="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-5.BSxMPhhN.png",u="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-6.B1emQmkd.png",b="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-7.D9LJAacU.png",C="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-8.BVKxYxA6.png",D="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-9.qGsQ7F1s.png",B="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-10.DMowb6h6.png",m="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-11.m6Id13Sc.png",$="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-12.Dm3fGDSj.png",_="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-14.BVSJVFt3.png",q="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-15.BoKV5lhN.png",x="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-13.CWVFxIdy.png",S="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-16.mESVNS4r.png",f="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-17.CiI2z5mS.png",v="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-18.DUQhGuVn.png",P="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-19.iSw9erAx.png",L="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-20.Cz_AjWeH.png",T="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-21.CDX8Kb20.png",j="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-23.BcFHxYei.png",Q="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-22.i6qMoQA8.png",O="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-24.CB7RlK5y.png",N="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-25.DAfSr0bN.png",I="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-26.BF8zI7ye.png",M="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-27.kFESW-fN.png",K="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-28.g-4zy2yP.png",V="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-29.DyiuOx9H.png",R="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-30.Dnlah31b.png",G="/obsidian-vitepress-docs/assets/%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E7%89%88-31.BJRff4We.png",Y=JSON.parse('{"title":"数据结构","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/数据结构/笔记：数据结构C语言版.md","filePath":"计算机基础课程/数据结构/笔记：数据结构C语言版.md"}'),X={name:"计算机基础课程/数据结构/笔记：数据结构C语言版.md"};function Z(z,s,U,w,H,W){const h=l("font");return k(),p("div",null,[s[3]||(s[3]=a('<h1 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h1><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>电子书：<a href="pdf/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80(C%E8%AF%AD%E8%A8%80%E7%89%88)%EF%BC%88%E5%8F%8C%E8%89%B2%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">数据结构基础(C语言版)（双色第2版）</a><br> 课后习题答案：<a href="pdf/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89-%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88%EF%BC%88%E5%AD%A6%E7%94%9F%E7%89%88%EF%BC%89.doc.doc">数据结构（C语言版）（第2版）-习题答案（学生版）.doc</a></p></div><p>#待补（程度：高）</p><h2 id="一、概念术语" tabindex="-1">一、概念术语 <a class="header-anchor" href="#一、概念术语" aria-label="Permalink to &quot;一、概念术语&quot;">​</a></h2><h3 id="数据定义" tabindex="-1">数据定义 <a class="header-anchor" href="#数据定义" aria-label="Permalink to &quot;数据定义&quot;">​</a></h3><p><strong>数据（Data）</strong> 是客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称。如数学计算中用到的整数和实数，文本编辑中用到的字符串，多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。</p><p><strong>数据元素（Data Element）</strong> 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录等。数据元素用于完整地描述一个对象，如前一节示例中的一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。</p><p><strong>数据项（Data Item）</strong> 是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。</p><p><strong>数据对象（Data Object）</strong> 是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合 N={0，±1，±2，…}，字母字符数据对象是集合 C={‘A’,‘B’,…,‘Z’,‘a’,‘b’,…,‘z’}，学生基本信息表也可以是一个数据对象。</p><h3 id="数据结构-1" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构-1" aria-label="Permalink to &quot;数据结构&quot;">​</a></h3><p><strong>数据结构（Data Structure）</strong> 是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。</p><p>数据结构包括<strong>逻辑结构</strong>和<strong>存储结构</strong>两个层次。</p><ul><li><h6 id="逻辑结构" tabindex="-1">逻辑结构 <a class="header-anchor" href="#逻辑结构" aria-label="Permalink to &quot;逻辑结构&quot;">​</a></h6></li></ul><p>数据的<strong>逻辑结构</strong>是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作从具体问题中抽象出来的数学模型。 数据的逻辑结构有两个要素：一是数据元素；二是关系。数据元素的含义如前所述，关系是指数据元素间的逻辑关系。根据数据元素之间关系的不同特性，数据的逻辑结构通常有 4 类基本逻辑结构，它们的复杂程度依次递进。</p><p><img src="'+r+'" alt="400"></p><p><strong>（1）集合结构</strong><br> 数据元素之间除了“属于同一集合”的关系外，别无其他关系。<br><strong>（2）线性结构</strong><br> 数据元素之间存在一对一的关系。<br><strong>（3）树结构</strong><br> 数据元素之间存在一对多的关系。<br><strong>（4）图结构或网状结构</strong><br> 数据元素之间存在多对多的关系。</p><p>==其中集合结构、树结构和图结构或网状结构都属于非线性结构。==</p><p>线性结构包括<strong>线性表</strong>（典型的线性结构）、<strong>栈和队列</strong>（具有特殊限制的线性表，数据操作只能在表的一端或两端进行）、<strong>字符串</strong>（特殊的线性表，其特殊性表现在它的数据元素仅由一个字符组成）、<strong>数组</strong>（线性表的推广，它的数据元素是一个线性表）、<strong>广义表</strong>（线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是线性表）。</p><p>非线性结构包括<strong>树结构</strong>[分为<strong>树</strong>（具有多个分支的层次结构）和<strong>二叉树</strong>（具有两个分支的层次结构）]、<strong>图结构</strong>[分为<strong>有向图</strong>（一种图结构，边是顶点的有序对）和<strong>无向图</strong>（另一种图结构，边是顶点的无序对）] 和<strong>集合结构</strong>。<br><img src="'+d+`" alt="600"></p><ul><li><h6 id="物理结构" tabindex="-1">物理结构 <a class="header-anchor" href="#物理结构" aria-label="Permalink to &quot;物理结构&quot;">​</a></h6></li></ul><p>数据对象在计算机中的存储表示称为数据的<strong>存储结构</strong>，也称为<strong>物理结构</strong>。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个节点来表示。数据元素在计算机中有两种基本的存储结构，分别是<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p><p>（1）顺序存储结构<br><strong>顺序存储结构</strong>是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系的，通常借助程序设计语言的数组类型来描述。</p><p>（2）链式存储结构<br> 顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而<strong>链式存储结构</strong>，无须占用一整块存储空间。但为了表示节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址。</p><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><p>在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算，<strong>数据类型</strong>（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称。</p><p><strong>抽象数据类型</strong>（Abstract Data Type，ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括 3 个部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。</p><p>抽象数据类型的定义格式如下：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ADT 抽象数据类型名{</span></span>
<span class="line"><span>　 数据对象：〈数据对象的定义〉</span></span>
<span class="line"><span>　 数据关系：〈数据关系的定义〉</span></span>
<span class="line"><span>　 基本操作：基本操作名（参数表）</span></span>
<span class="line"><span>					　 初始条件：〈初始条件描述〉</span></span>
<span class="line"><span>					　 操作结果：〈操作结果描述〉</span></span>
<span class="line"><span>}ADT 抽象数据类型名</span></span></code></pre></div><p>基本操作有两种参数：赋值参数只为操作提供输入值；引用参数以“&amp;”打头，除可提供输入值外，还将返回操作结果。“初始条件”描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。“操作结果”说明了操作正常完成之后，数据结构的变化状况和应返回的结果。</p><div class="important custom-block github-alert"><p class="custom-block-title">与面对对象中类的比对</p><p>​<strong>ADT（抽象数据类型）与面向对象编程中的“类”（Class）或“对象”（Object）在抽象思想上高度相似</strong>，它们都试图通过封装数据结构和操作接口来定义一种逻辑上的数据类型。</p><ul><li><strong>ADT 是“类”的理论原型</strong>：两者都通过封装数据结构和操作接口定义逻辑类型。</li><li><strong>ADT 更纯粹</strong>：仅关注“数据 + 操作”的抽象，无关语言特性。</li><li><strong>类是 ADT 的实践扩展</strong>：在 ADT 的基础上，通过面向对象语言实现更复杂的工程需求（如继承、多态、访问控制）</li></ul><p>抽象数据类型和类的概念实际上反映了程序或软件设计的两层抽象：抽象数据类型相当于在概念层（或称为抽象层）上描述问题，而类相当于在实现层上描述问题。</p></div><h3 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h3><p><strong>算法</strong>（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。</p><p>一个算法必须满足以下 5 个重要特性。<br> （1）<em>有穷性</em>。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。<br> （2）<em>确定性</em>。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，算法的执行者或阅读者都能明确其含义及如何执行。<br> （3）<em>可行性</em>。算法中的所有操作都可以通过将已经实现的基本操作运算执行有限次来实现。<br> （4）<em>输入</em>。一个算法有 0 个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。<br> （5）<em>输出</em>。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</p><p>一个算法的优劣应该从以下几方面来评价。<br> （1）<em>正确性</em>。在合理的数据输入下，好的算法能够在有限的运行时间内得到正确的结果。<br> （2）<em>可读性</em>。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法容易隐藏错误，且难于调试和修改。<br> （3）<em>健壮性</em>。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。<br> （4）<em>高效性</em>。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。</p><p>不考虑计算机的软硬件等环境因素，影响算法时间代价的最主要因素是问题规模。<strong>问题规模</strong>是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数 n 表示。<br> 一条语句的重复执行次数称作<strong>语句频度</strong>（Frequency Count）。</p><ul><li><h6 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h6></li></ul><p>对于稍微复杂一些的算法，计算所有语句的频度则通常是比较困难的，即便能够计算出，也可能是个非常复杂的函数。因此，==为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句”的执行次数来度量算法的工作量。==所谓“<strong>基本语句</strong>”指的是算法中重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。</p><p>一般情况下，算法中基本语句重复执行的次数是问题规模 n 的某个函数 f(n)，算法的时间量度记作：</p><p>$$ T(n) = O(f(n)) $$</p><p>它表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的<strong>渐近时间复杂度</strong>，简称<strong>时间复杂度</strong>（Time Complexity）。</p><p>分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模 n 的某个函数 f(n)，取其数量级用符号“O”表示即可。具体计算数量级时，可以遵循以下定理：</p><p>$$ 若 f(n) = a_{m}n^{m} + a_{m-1}n^{m-1} + \\dots + a_{1}n + a_{0} 是一个 m 次多项式，则 T(n) = \\mathcal{O}(n^{m}) $$</p><div class="warning custom-block github-alert"><p class="custom-block-title">注意</p><p>如果算法的执行时间不随问题规模 n 的增长而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是 $O(1)$。 如：<br><code>for(i=0;i&lt;10000;i++){x++;s=0;}</code></p></div><p>常见的时间复杂度按数量级递增排列依次为：常量阶 $\\mathcal{O}(1)$、对数阶 $\\mathcal{O}(\\log_2 n)$、线性阶 $\\mathcal{O}(n)$、线性对数阶 $\\mathcal{O}(n \\log_2 n)$、平方阶 $\\mathcal{O}(n^2)$、立方阶 $\\mathcal{O}(n^3)$、……、k 次方阶 $\\mathcal{O}(n^k)$、指数阶 $\\mathcal{O}(2^n)$ 等。</p><p><img src="`+g+`" alt="300"></p><p>称算法在最好情况下的时间复杂度为<strong>最好时间复杂度</strong>，是指算法计算量可能达到的最小值；<br> 称算法在最坏情况下的时间复杂度为<strong>最坏时间复杂度</strong>，是指算法计算量可能达到的最大值；<br> 算法的<strong>平均时间复杂度</strong>是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</p><ul><li><h6 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h6></li></ul><p>采用<strong>渐近空间复杂度</strong>（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模 n 的函数，记作：</p><p>$$ S(n) = O(f (n)) $$</p><p>一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的辅助存储空间。其中，输入数据所占的具体存储量取决于问题本身，与算法无关，这样只需分析该算法在实现时所需要的辅助空间就可以了。</p><hr><h2 id="二、线性表" tabindex="-1">二、线性表 <a class="header-anchor" href="#二、线性表" aria-label="Permalink to &quot;二、线性表&quot;">​</a></h2><p>诸如此类由 n（n≥0）个数据特性相同的元素构成的有限序列，称为<strong>线性表</strong>。<br> 线性表中元素的个数 n（n≥0）定义为线性表的长度，当 n = 0 时称之为<strong>空表</strong>。</p><p>对于非空的线性表或线性结构，其特点是：<br> （1）存在唯一的一个被称作“第一个”的数据元素；<br> （2）存在唯一的一个被称作“最后一个”的数据元素；<br> （3）除第一个元素之外，结构中的每个数据元素均只有一个前驱；<br> （4）除最后一个元素之外，结构中的每个数据元素均只有一个后继。</p><p>线性表的抽象数据类型定义：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据对象：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ai|ai ∈ ElemSet,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n,n ≥ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据关系：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai&gt;|ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ∈ D,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　基本操作：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　InitList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：构造一个空的线性表L。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DestroyList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：销毁线性表L。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ClearList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：将L 重置为空表。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ListEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若L 为空表，则返回true，否则返回false。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ListLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回L 中数据元素的个数。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　GetElem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,i,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在，且1 ≤i ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：用e返回L 中第i个数据元素的值。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　LocateElem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　PriorElem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,cur_e,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pre_e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若cur_e 是L 的数据元素，且不是第一个，则用pre_e 返回其前驱，否则操作失败，pre_e 无定义。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　NextElem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,cur_e,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next_e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若cur_e 是L 的数据元素，且不是最后一个，则用next_e 返回其后继，否则操作失败，next_e 无定义。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ListInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,i,e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在，且1 ≤i ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：在L 中第i个位置之前插入新的数据元素e，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的长度加1。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ListDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在且非空，且1 ≤i ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：删除L 的第i个数据元素，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的长度减1。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　TraverseList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：线性表L 已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：对线性表L 进行遍历，在遍历过程中对L 的每个节点访问一次。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List</span></span></code></pre></div><h3 id="线性表的顺序表示和实现" tabindex="-1">线性表的顺序表示和实现 <a class="header-anchor" href="#线性表的顺序表示和实现" aria-label="Permalink to &quot;线性表的顺序表示和实现&quot;">​</a></h3><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为<strong>顺序表（Sequential List）</strong>。其特点是，逻辑上相邻的数据元素，其物理位置也是相邻的。</p><p>只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种<strong>随机存取</strong>的存储结构。<br><img src="`+o+`" alt="400"></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 顺序表的存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAXSIZE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 顺序表可能达到的最大长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 ElemType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">elem;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 存储空间的基地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 当前长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}SqList;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 顺序表的结构类型为SqList</span></span></code></pre></div><ul><li><h6 id="_1-初始化" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>顺序表的初始化操作就是构造一个空的顺序表。</p><ul><li><h6 id="_2-取值" tabindex="-1">2．取值 <a class="header-anchor" href="#_2-取值" aria-label="Permalink to &quot;2．取值&quot;">​</a></h6></li></ul><p>取值操作是根据指定的位置序号 i，获取顺序表中第 i 个数据元素的值。<br> 由于顺序存储结构具有随机存取的特点，可以直接通过数组下标定位得到，<code>elem[i-1]</code> 单元存储第 i 个数据元素。</p><ul><li><h6 id="_3-查找" tabindex="-1">3．查找 <a class="header-anchor" href="#_3-查找" aria-label="Permalink to &quot;3．查找&quot;">​</a></h6></li></ul><p>查找操作是根据指定的元素值 e，查找顺序表中第 1 个值与 e 相等的元素。<br> 若查找成功，则返回该元素在表中的位置序号；若查找失败，则返回 0。</p><ul><li><h6 id="_4-插入" tabindex="-1">4．插入 <a class="header-anchor" href="#_4-插入" aria-label="Permalink to &quot;4．插入&quot;">​</a></h6></li></ul><p>线性表的插入操作是指在表的第 i 个位置插入一个新的数据元素 e，使长度为 n 的线性表：<br> $$ (a_1,…,a_{i−1},a_i,…,a_n) $$ 变成长度为 n + 1 的线性表： $$ (a_1,…,a_{i−1},e,a_i,…,a_n) $$ 一般情况下，在第 $i（1≤i≤n）$ 个位置插入一个元素时，需从最后一个元素即第 n 个元素开始，依次向后移动一个位置，直至第 i 个元素（共 $n−i + 1$ 个元素）。</p><ul><li><h6 id="_5-删除" tabindex="-1">5．删除 <a class="header-anchor" href="#_5-删除" aria-label="Permalink to &quot;5．删除&quot;">​</a></h6></li></ul><p>线性表的删除操作是指将表的第 i 个元素删去，将长度为 n 的线性表：<br> $$ (a_1,…,a_{i−1},a_i,a_{i+1},…,a_n) $$</p><p>变成长度为 n−1 的线性表：<br> $$ (a_1,…,a_{i−1},a_{i+1},…,a_n) $$ 一般情况下，删除第 $i（1≤i≤n$）个元素时需将第 $i + 1$ 个至第 n 个元素（共 $n−i$ 个元素）依次向前移动一个位置（$i = n$ 时无须移动）。</p>`,71)),n("blockquote",null,[n("p",null,[s[1]||(s[1]=i("顺序表可以随机存取表中任一元素，其存储位置可用一个简单、直观的公式来表示。然而，从另一方面来看，这个特点也造成了这种存储结构的")),e(h,{color:"#ff0000"},{default:E(()=>s[0]||(s[0]=[i("缺点：在做插入或删除操作时，需移动大量元素。")])),_:1,__:[0]}),s[2]||(s[2]=i("另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，必然导致存储空间的浪费。所有这些问题，都可以通过线性表的另一种表示方法——链式存储结构来解决。"))])]),s[4]||(s[4]=a('<h3 id="线性表的链式表示和实现" tabindex="-1">线性表的链式表示和实现 <a class="header-anchor" href="#线性表的链式表示和实现" aria-label="Permalink to &quot;线性表的链式表示和实现&quot;">​</a></h3><p>线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素 $a_i$ 与其直接后继数据元素 $a_{i+1}$ 之间的逻辑关系，对数据元素 $a_i$ 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（直接后继的存储位置）。<br> 这两部分信息组成数据元素 $a_i$ 的存储映像，称为<strong>节点（node）</strong>。<br> 它包括两个域：其中存储数据元素信息的域称为<strong>数据域</strong>；存储直接后继存储位置的域称为<strong>指针域</strong>。指针域中存储的信息称作<strong>指针</strong>或<strong>链</strong>。<br> $n$ 个节点 $[a_i (1≤i≤n)的存储映像]$ 链接成一个<strong>链表</strong>，即为线性表：<br> $$ (a1, a2,…, an) $$ 的链式存储结构。又由于此链表的每个节点中只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>。</p><p>根据链表节点所含指针个数、指针指向和指针连接方式，可将链表分为<strong>单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表</strong>等。其中单链表、循环链表和双向链表多用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。</p><h4 id="单链表" tabindex="-1">单链表 <a class="header-anchor" href="#单链表" aria-label="Permalink to &quot;单链表&quot;">​</a></h4><ul><li>单链表存储结构：</li></ul><p><img src="'+y+'" alt="500"></p><ul><li>单链表的逻辑状态：</li></ul><p><img src="'+c+`" alt="500"></p><ul><li>在 C 语言中可用“结构指针”来描述：</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 单链表的存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　LNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 ElemType　data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">　　　　　　　　 // 节点的数据域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LNode　</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">　　　　　　 //节点的指针域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}LNode,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LinkList;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">　　　　　　　　　 //LinkList 为指向结构体LNode 的指针类型</span></span></code></pre></div><p>一般情况下，为了处理方便，在单链表的第一个节点之前附设一个节点，称之为<strong>头节点</strong>。</p><p><img src="`+F+'" alt="500"></p><div class="note custom-block github-alert"><p class="custom-block-title">元节点、头节点、头指针</p><p></p><ol><li><strong>首元节点</strong>是指链表中存储第一个数据元素 a1 的节点。</li><li><strong>头节点</strong>是在首元节点之前附设的一个节点，其指针域指向首元节点。头节点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整型时，头节点的数据域中可存放该线性表的长度。</li><li><strong>头指针</strong>是指向链表中第一个节点的指针。若链表设有头节点，则头指针所指节点为线性表的头节点；若链表不设头节点，则头指针所指节点为该线性表的首元节点。</li></ol></div><ul><li>链表增加头节点的作用： <ol><li><p>便于首元节点的处理<br> 增加了头节点后，首元节点的地址保存在头节点（其“前驱”节点）的指针域中，则对链表的第一个数据元素的操作与对其他数据元素的操作相同，无须进行特殊处理。</p></li><li><p>便于空表和非空表的统一处理<br> 当链表不设头节点时，假设 $L$ 为单链表的头指针，它应该指向首元节点，则当单链表为长度 $n$ 为 0 的空表时， $L$ 指针为空（判定空表的条件可记为：$L = = NULL$）。<br> 增加头节点后，无论链表是否为空，头指针都是指向头节点的非空指针。</p></li></ol></li></ul><p><img src="'+A+'" alt="500"></p><p>单链表是非随机存取的存储结构，要取得第 i 个数据元素必须从头指针出发顺链进行寻找，也称为<strong>顺序存取</strong>的存储结构。因此，其基本操作的实现不同于顺序表。</p><ul><li><h6 id="_1-初始化-1" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化-1" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>单链表的初始化操作就是构造一个如上图所示的空表。</p><ul><li><h6 id="_2-取值-1" tabindex="-1">2．取值 <a class="header-anchor" href="#_2-取值-1" aria-label="Permalink to &quot;2．取值&quot;">​</a></h6></li></ul><p>和顺序表不同，链表中逻辑相邻的节点并没有存储在物理相邻的单元中，这样，根据给定的节点位置序号 $i$，在链表中获取该节点的值不能像顺序表那样随机访问，而只能从链表的首元节点出发，顺着链域 next 逐个节点向下访问。</p><ul><li><h6 id="_3-查找-1" tabindex="-1">3．查找 <a class="header-anchor" href="#_3-查找-1" aria-label="Permalink to &quot;3．查找&quot;">​</a></h6></li></ul><p>链表中按值查找的过程和顺序表类似，从链表的首元节点出发，依次将节点值和给定值 e 进行比较，返回查找结果。</p><ul><li><h6 id="_4-插入-1" tabindex="-1">4．插入 <a class="header-anchor" href="#_4-插入-1" aria-label="Permalink to &quot;4．插入&quot;">​</a></h6></li></ul><p>假设要在单链表的两个数据元素 a 和 b 之间插入一个数据元素 x，已知 p 为其单链表存储结构中指向节点 a 的指针，如图所示。</p><p><img src="'+u+'" alt="500"></p><ul><li><h6 id="_5-删除-1" tabindex="-1">5．删除 <a class="header-anchor" href="#_5-删除-1" aria-label="Permalink to &quot;5．删除&quot;">​</a></h6></li></ul><p>要删除单链表中指定位置的元素，同插入元素一样，首先应该找到该位置的前驱节点。如图所示，在单链表中删除元素 b 时，应该首先找到其前驱节点 a。为了在单链表中实现元素 a、b 和 c 之间逻辑关系的变化，仅需修改节点 a 中的指针域即可。<br> 假设 p 为指向节点 a 的指针，则修改指针的语句为：$p-&gt;next = p-&gt;next-&gt;next$</p><p><img src="'+b+'" alt="500"></p><p>但在删除节点 b 时，除了修改节点 a 的指针域外，还要释放节点 b 所占的空间，所以在修改指针前，应该引入另一指针 q，临时保存节点 b 的地址以备释放。</p><ul><li><h6 id="_6-创建单链表" tabindex="-1">6．创建单链表 <a class="header-anchor" href="#_6-创建单链表" aria-label="Permalink to &quot;6．创建单链表&quot;">​</a></h6></li></ul><p>初始化操作是创建一个只有一个头节点的空链表，而上面链表的其他算法都是假定链表已经存在多个节点。那么，如何建立一个包括若干个节点的链表呢？链表和顺序表不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需预先分配划定，而是由系统按需即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。即从空表的初始状态起，依次建立各元素节点，并逐个插入链表。<br> 根据节点插入位置的不同，链表的创建方法可分为<strong>前插法</strong>和<strong>后插法</strong>。<br> （1）前插法<br> 前插法是通过将新节点逐个插入链表的头部（头节点之后）来创建链表，每次申请一个新节点，读入相应的数据元素值，然后将新节点插入到头节点之后。<br> （2）后插法<br> 后插法是通过将新节点逐个插入链表的尾部来创建链表。同前插法一样，每次申请一个新节点，读入相应的数据元素值。不同的是，为了使新节点能够插入表尾，需要增加一个尾指针 r 指向链表的尾节点。</p><h4 id="循环链表" tabindex="-1">循环链表 <a class="header-anchor" href="#循环链表" aria-label="Permalink to &quot;循环链表&quot;">​</a></h4><p><strong>循环链表（Circular Linked List）</strong> 是另一种形式的链式存储结构。其特点是表中最后一个节点的指针域指向头节点，整个链表形成一个环。由此，从表中任一节点出发均可找到表中其他节点，如图所示为单链的循环链表。类似地，还可以有多重链的循环链表。</p><p><img src="'+C+'" alt="500"></p><p>循环单链表的操作和单链表基本一致，差别仅在于：当链表遍历时，判别当前指针 p 是否指向表尾节点的终止条件不同。在单链表中，判别条件为 $p!=NULL$ 或 $p-&gt;next!=NULL$，而循环单链表的判别条件为 $p!=L$ 或 $p-&gt;next!=L$。</p><h4 id="双向链表" tabindex="-1">双向链表 <a class="header-anchor" href="#双向链表" aria-label="Permalink to &quot;双向链表&quot;">​</a></h4><p>在单链表中，查找直接后继的执行时间为 $O(1)$，而查找直接前驱的执行时间为 $O(n)$。为克服单链表这种单向性的缺点，可利用<strong>双向链表（Double Linked List</strong>）。在双向链表的节点中有两个指针域，一个指向直接后继，另一个指向直接前驱，节点结构如图所示：</p><p><img src="'+D+`" alt="600"></p><p>在 C 语言中可描述如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 双向链表的存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DuLNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 ElemType data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 数据域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DuLNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prior;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指向直接前驱</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DuLNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指向直接后继</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}DuLNode,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DuLinkList;</span></span></code></pre></div><p>在双向链表中，有些操作（如 ListLength、GetElem 和 LocateElem 等）仅需涉及一个方向的指针，则它们的算法描述和线性链表相同，但在插入、删除时有很大的不同，在双向链表中进行插入、删除时需同时修改两个方向上的指针。<br><img src="`+B+'" alt="500"><br><img src="'+m+'" alt="500"></p><h3 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h3><ul><li>==顺序表和链表的比较==</li></ul><table tabindex="0"><thead><tr><th>比较项目</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>存储空间</td><td>预先分配，会出现空间闲置或溢出现象</td><td>动态分配，不会出现存储空间闲置或溢出现象</td></tr><tr><td>存储密度</td><td>不用为表示节点间的逻辑关系而增加额外的存储开销，存储密度等于 1</td><td>需要借助指针来体现元素间的逻辑关系，存储密度小于 1</td></tr><tr><td>存取元素</td><td>随机存取，按位置访问元素的时间复杂度为 $O(1)$</td><td>顺序存取，按位置访问元素时间复杂度为 $O(n)$</td></tr><tr><td>插入、删除</td><td>平均移动约表中一半元素，时间复杂度为 $O(n)$</td><td>不需移动元素，确定插入、删除位置后，时间复杂度为 $O(1)$</td></tr><tr><td>适用情况</td><td>1. 表长变化不大，且能事先确定变化的范围<br>2. 很少进行插入或删除操作，经常按元素位置序号访问数据元素</td><td>1. 长度变化较大<br>2. 频繁进行插入或删除操作</td></tr></tbody></table><ul><li>==单链表、循环链表和双向链表的比较==</li></ul><table tabindex="0"><thead><tr><th>链表名称</th><th>查找表头节点</th><th>查找表尾节点</th><th>查找节点 *p 的前驱节点</th></tr></thead><tbody><tr><td>​<strong>带头节点的单链表 L</strong></td><td>$L-&gt;next$<br>时间复杂度 $O(1)$</td><td>从 $L-&gt;next$ 依次向后遍历<br>时间复杂度 $O(n)$</td><td>通过 $p-&gt;next$ 无法找到其前驱<br>时间复杂度 $O(n)$</td></tr><tr><td><strong>带头节点仅设头指针 L<br>的循环单链表</strong></td><td>$L-&gt;next$<br>时间复杂度 $O(1)$</td><td>从 $L-&gt;next$ 向后遍历<br>时间复杂度 $O(n)$</td><td>通过 $p-&gt;next$ 查找前驱<br>时间复杂度 $O(n)$</td></tr><tr><td><strong>带头节点仅设尾指针 R<br>的循环单链表</strong></td><td>$R-&gt;next$<br>时间复杂度 $O(1)$</td><td>$R$<br>时间复杂度 $O(1)$</td><td>通过 $p-&gt;next$ 查找前驱<br>时间复杂度 $O(n)$</td></tr><tr><td><strong>带头节点的双向循环链表 L</strong></td><td>$L-&gt;next$<br>时间复杂度 $O(1)$</td><td>$L-&gt;prior$<br>时间复杂度 $O(1)$</td><td>$p-&gt;prior$<br>时间复杂度 $O(1)$</td></tr></tbody></table><h2 id="三、栈和队列" tabindex="-1">三、栈和队列 <a class="header-anchor" href="#三、栈和队列" aria-label="Permalink to &quot;三、栈和队列&quot;">​</a></h2><p>栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为具有限定性的数据结构。</p><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p><strong>栈（stack）</strong> 是限定仅在表尾进行插入或删除操作的线性表。<br> 因此，对栈来说，表尾端有其特殊含义，称为<strong>栈顶（top）</strong>，相应地，表头端称为<strong>栈底（bottom）</strong>。不含元素的空表称为<strong>空栈</strong>。<br> 假设栈 $S = (a_1, a_2, …, a_n)$，则称 $a_1$ 为栈底元素，$a_n$ 为栈顶元素。栈中元素按 $a_1$, $a_2$, …, $a_n$ 的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的。因此，栈又称为<strong>后进先出（Last In First Out，LIFO）</strong> 的线性表，它的这个特点可用铁路调度站形象地表示。</p><p><img src="'+$+`" alt="500"></p><p>栈的抽象数据类型定义：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Stack｛</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据对象：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ai|ai ∈ ElemSet,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n,n ≥ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据关系：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ ＜ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ＞ |ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ∈ D,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n｝</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　　约定an 端为栈顶，a1 端为栈底。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　基本操作：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　InitStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：构造一个空栈S。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DestroyStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：栈S被销毁。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ClearStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：将S清为空栈。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StackEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若栈S为空栈，则返回true，否则返回false。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StackLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回S的元素个数，即栈的长度。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　GetTop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在且非空。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回S的栈顶元素，不修改栈顶指针。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：插入元素e为新的栈顶元素。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在且非空。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：删除S的栈顶元素，并用e返回其值。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StackTraverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：栈S已存在且非空。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：从栈底到栈顶依次对S的每个数据元素进行访问。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Stack</span></span></code></pre></div><p>和线性表类似，栈也有两种存储表示方法，分别称为顺序栈和链栈。</p><h4 id="顺序栈" tabindex="-1">顺序栈 <a class="header-anchor" href="#顺序栈" aria-label="Permalink to &quot;顺序栈&quot;">​</a></h4><p>顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 top 指示栈顶元素在顺序栈中的位置。</p><p>顺序栈的定义如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 顺序栈的存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAXSIZE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 顺序栈存储空间的初始分配量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		SElemType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 栈底指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		SElemType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">top;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 栈顶指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stacksize;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 栈可用的最大容量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}SqStack ；</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">说明</p><p></p><ol><li>base 为栈底指针，初始化完成后，栈底指针 base 始终指向栈底的位置，若 base 的值为 NULL，则表明栈结构不存在。top 为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针 top 增 1 ；删除栈顶元素时，指针 top 减 1。因此，栈空时，top 和 base 的值相等，都指向栈底；栈非空时，top 始终指向栈顶元素的上一个位置。</li><li>stacksize 指示栈可使用的最大容量，后面算法 3.1 的初始化操作为顺序栈动态分配 MAXSIZE 大小的数组空间，将 stacksize 置为 MAXSIZE。</li></ol></div><p><img src="`+_+`" alt=""></p><ul><li><h6 id="_1-初始化-2" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化-2" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>顺序栈的初始化操作就是为顺序栈动态分配一个预定义大小的数组空间。</p><ul><li><h6 id="_2-入栈" tabindex="-1">2．入栈 <a class="header-anchor" href="#_2-入栈" aria-label="Permalink to &quot;2．入栈&quot;">​</a></h6></li></ul><p>入栈操作是指在栈顶插入新的元素。</p><ul><li><h6 id="_3-出栈" tabindex="-1">3．出栈 <a class="header-anchor" href="#_3-出栈" aria-label="Permalink to &quot;3．出栈&quot;">​</a></h6></li></ul><p>出栈操作是指将栈顶元素删除。</p><ul><li><h6 id="_4-取栈顶元素" tabindex="-1">4．取栈顶元素 <a class="header-anchor" href="#_4-取栈顶元素" aria-label="Permalink to &quot;4．取栈顶元素&quot;">​</a></h6></li></ul><p>当栈非空时，此操作返回当前栈顶元素的值，栈顶指针保持不变。</p><h4 id="链栈" tabindex="-1">链栈 <a class="header-anchor" href="#链栈" aria-label="Permalink to &quot;链栈&quot;">​</a></h4><p>链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示，链栈的节点结构与单链表的结构相同，在此用 StackNode 表示，定义如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 链栈的存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StackNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 ElemType　　data;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StackNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}StackNode,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LinkStack;</span></span></code></pre></div><p><img src="`+q+'" alt="200"></p><ul><li><h6 id="_1-初始化-3" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化-3" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>链栈的初始化操作就是构造一个空栈，因为没必要设头节点，所以直接将栈顶指针置空即可。</p><ul><li><h6 id="_2-入栈-1" tabindex="-1">2．入栈 <a class="header-anchor" href="#_2-入栈-1" aria-label="Permalink to &quot;2．入栈&quot;">​</a></h6></li></ul><p>和顺序栈的入栈操作不同的是，链栈在入栈前不需要判断栈是否满，只需要为入栈元素动态分配一个节点空间。</p><ul><li><h6 id="_3-出栈-1" tabindex="-1">3．出栈 <a class="header-anchor" href="#_3-出栈-1" aria-label="Permalink to &quot;3．出栈&quot;">​</a></h6></li></ul><p>和顺序栈一样，链栈在出栈前也需要判断栈是否为空，不同的是，链栈在出栈后需要释放出栈元素的栈顶空间。</p><ul><li><h6 id="_4-取栈顶元素-1" tabindex="-1">4．取栈顶元素 <a class="header-anchor" href="#_4-取栈顶元素-1" aria-label="Permalink to &quot;4．取栈顶元素&quot;">​</a></h6></li></ul><p>与顺序栈一样，当栈非空时，取栈顶元素操作返回当前栈顶元素的值，栈顶指针 S 保持不变。</p><h4 id="栈与递归" tabindex="-1">栈与递归 <a class="header-anchor" href="#栈与递归" aria-label="Permalink to &quot;栈与递归&quot;">​</a></h4><p>所谓递归是指，若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称其是递归的，或者是递归定义的。在以下 3 种情况下，常常使用递归的方法。</p><ol><li>定义是递归的</li><li>数据结构是递归的</li><li>问题的解法是递归的</li></ol><p>递归函数在函数的执行过程中，需多次进行自我调用。那么，递归函数是如何执行的？先看任意两个函数之间进行调用的情形。<br> 与汇编语言程序设计中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行。<br> 通常，一个函数在运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事：<br> （1）将所有的实参、返回地址等信息传递给被调用函数保存；<br> （2）为被调用函数的局部变量分配存储区；<br> （3）将控制转移到被调函数的入口。<br> 而从被调用函数返回调用函数之前，系统也应完成 3 件事：<br> （1）保存被调用函数的计算结果；<br> （2）释放被调用函数的数据区；<br> （3）依照被调用函数保存的返回地址将控制转移到调用函数。<br> 当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现。系统将整个程序运行时所需的数据空间安排在一个栈中，每调用一个函数，就为它在栈顶分配一个存储区，每从一个函数退出，就释放它的存储区。如此，当前正运行的函数的数据区必在栈顶。</p><p>时间复杂度 $T(n)=O(n)$<br> 空间复杂度 $S(n) = O(f (n))$</p><h3 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h3><p>和栈相反，<strong>队列（queue）</strong> 是一种<strong>先进先出（First In First Out，FIFO）</strong> 的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端称为<strong>队尾（rear）</strong>，允许删除的一端则称为<strong>队头（front）</strong>。假设队列为 $q = (a_1, a_2, …, a_n)$，那么，$a_1$ 就是队头元素，$a_n$ 则是队尾元素。队列中的元素是按照 $a_1, a_2, …, a_n$ 的顺序进入的，退出队列也只能按照这个次序依次退出，也就是说，只有在 $a_1, a_2, …, a_{n-1}$ 都离开队列之后，$a_n$ 才能退出队列。<br><img src="'+x+`" alt="500"><br> 队列的抽象数据类型定义：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Queue {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据对象：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ai|ai ∈ ElemSet,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n,n ≥ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据关系：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ ＜ai − </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ＞ |ai − </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ∈ D,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　　约定其中a1 端为队头，an 端为队尾。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　基本操作：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　InitQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ＆</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：构造一个空队列Q。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DestroyQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ＆</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：队列Q已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：队列Q被销毁，不再存在。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ClearQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ＆</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：队列Q已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：将Q清为空队列。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　QueueEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：队列Q已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若Q为空队列，则返回true，否则返回false。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　QueueLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：队列Q已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回Q的元素个数，即队列的长度。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　GetHead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：Q为非空队列。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回Q的队头元素。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　EnQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ＆ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：队列Q已存在。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：插入元素e为Q的新的队尾元素。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DeQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( ＆ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ＆e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：Q为非空队列。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：删除Q的队头元素，并用e返回其值。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　QueueTraverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Q</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：Q已存在且非空。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：从队头到队尾，依次对Q的每个数据元素进行访问。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Queue</span></span></code></pre></div><p>队列也有两种存储表示，顺序表示和链式表示。</p><h4 id="循环队列" tabindex="-1">循环队列 <a class="header-anchor" href="#循环队列" aria-label="Permalink to &quot;循环队列&quot;">​</a></h4><p>和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队头到队尾的元素之外，尚需附设两个整型变量 front 和 rear 分别指示队头元素及队尾元素的位置（后面分别称为头指针和尾指针）。队列的顺序存储结构表示如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 队列的顺序存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAXQSIZE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 队列可能达到的最大长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 QElemType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">base;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 存储空间的基地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> front;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 头指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rear;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 尾指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}SqQueue;</span></span></code></pre></div><p><img src="`+S+'" alt=""><br> 假设当前队列分配的最大空间为 6，则当队列处于图所示的状态时不可再继续插入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为 <strong>“假溢出”</strong>。<br> 这是由“队尾入队，队头出队”这种受限制的操作造成的。<br> 怎样解决这种“假溢出”问题呢？一个较巧妙的办法是将顺序队列变为一个环状的空间，称这样的队列为<strong>循环队列</strong>。<br><img src="'+f+`" alt="300"></p><p>头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增 1” 的操作可用 <strong>“模”运算</strong> 来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式“循环”移动。</p><p>由此可见，对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下，如何区别队满还是队空呢？</p><p>通常有以下两种处理方法。</p><ol><li><p>少用一个元素空间，即当队列空间大小为 $m$ 时，有 $m-1$ 个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加 1 后等于头指针时，则认为队满。因此，在循环队列中队空和队满的条件如下。</p><ul><li>队空的条件：$Q.front == Q.rear$</li><li>队满的条件：$(Q.rear+1)%MAXQSIZE == Q.front$</li></ul></li><li><p>另设一个标志位以区别队列是“空”还是“满”。</p></li></ol><ul><li><h6 id="_1-初始化-4" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化-4" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>循环队列的初始化操作就是动态分配一个预定义大小为 MAXQSIZE 的数组空间。</p><ul><li><h6 id="_2-求队列长度" tabindex="-1">2．求队列长度 <a class="header-anchor" href="#_2-求队列长度" aria-label="Permalink to &quot;2．求队列长度&quot;">​</a></h6></li></ul><p>对于非循环队列，尾指针和头指针的差值便是队列长度；而对于循环队列，差值可能为负数，所以需要将差值加上 MAXQSIZE，然后与 MAXQSIZE 求余。</p><ul><li><h6 id="_3-入队" tabindex="-1">3．入队 <a class="header-anchor" href="#_3-入队" aria-label="Permalink to &quot;3．入队&quot;">​</a></h6></li></ul><p>入队操作是指在队尾插入一个新的元素。</p><ul><li><h6 id="_4-出队" tabindex="-1">4．出队 <a class="header-anchor" href="#_4-出队" aria-label="Permalink to &quot;4．出队&quot;">​</a></h6></li></ul><p>出队操作是指将队头元素删除。</p><ul><li><h6 id="_5-取队头元素" tabindex="-1">5．取队头元素 <a class="header-anchor" href="#_5-取队头元素" aria-label="Permalink to &quot;5．取队头元素&quot;">​</a></h6></li></ul><p>当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。</p><h4 id="链队列" tabindex="-1">链队列 <a class="header-anchor" href="#链队列" aria-label="Permalink to &quot;链队列&quot;">​</a></h4><p>链队列是指采用链式存储结构实现的队列。通常链队列用单链表来表示，如图所示。一个链队列显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。这里和线性表的单链表一样，为了操作方便起见，给链队列添加一个头节点，并令头指针始终指向头节点。队列的链式存储结构表示如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 队列的链式存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 QElemType data;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}QNode, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QueuePtr;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 QueuePtr　front;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 队头指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 QueuePtr　rear;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 队尾指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}LinkQueue;</span></span></code></pre></div><p><img src="`+v+`" alt="300"></p><ul><li><h6 id="_1-初始化-5" tabindex="-1">1．初始化 <a class="header-anchor" href="#_1-初始化-5" aria-label="Permalink to &quot;1．初始化&quot;">​</a></h6></li></ul><p>链队的初始化操作就是构造一个只有一个头节点的空队。</p><ul><li><h6 id="_2-入队" tabindex="-1">2．入队 <a class="header-anchor" href="#_2-入队" aria-label="Permalink to &quot;2．入队&quot;">​</a></h6></li></ul><p>和循环队列的入队操作不同的是，链队列在入队前不需要判断队是否满，只需要为入队元素动态分配一个节点空间</p><ul><li><h6 id="_3-出队" tabindex="-1">3．出队 <a class="header-anchor" href="#_3-出队" aria-label="Permalink to &quot;3．出队&quot;">​</a></h6></li></ul><p>和循环队列一样，链队在出队前也需要判断队列是否为空，不同的是，链队列在出队后需要释放队头元素所占的空间。</p><ul><li><h6 id="_4-取队头元素" tabindex="-1">4．取队头元素 <a class="header-anchor" href="#_4-取队头元素" aria-label="Permalink to &quot;4．取队头元素&quot;">​</a></h6></li></ul><p>与循环队列一样，当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。</p><h3 id="比较-1" tabindex="-1">比较 <a class="header-anchor" href="#比较-1" aria-label="Permalink to &quot;比较&quot;">​</a></h3><table tabindex="0"><thead><tr><th>比较项目</th><th>栈</th><th>队列</th></tr></thead><tbody><tr><td>逻辑结构</td><td>和线性表一样，数据元素之间存在一对一的关系，后进先出</td><td>和线性表一样，数据元素之间存在一对一的关系，先进先出</td></tr><tr><td>存储结构</td><td>​<strong>​顺序存储​</strong>​：<br>空间预先分配，可能闲置/溢出，元素个数不可自由扩充<br>​<strong>​链式存储​</strong>​：<br>动态分配，无闲置/溢出，元素个数可自由扩充</td><td>​<strong>​顺序存储​</strong>​：<br>常设计为循环队列，可能闲置/溢出，元素个数不可自由扩充<br>​<strong>​链式存储​</strong>​：<br>动态分配，无闲置/溢出，元素个数可自由扩充</td></tr><tr><td>运算规则</td><td>插入和删除在表的一端（栈顶）完<br>成，后进先出</td><td>插入运算在表的一端（队尾）进行，删除运算在表的另一端（队头）进行，先进先出</td></tr></tbody></table><h2 id="四、串、数组和广义表" tabindex="-1">四、串、数组和广义表 <a class="header-anchor" href="#四、串、数组和广义表" aria-label="Permalink to &quot;四、串、数组和广义表&quot;">​</a></h2><h3 id="串" tabindex="-1">串 <a class="header-anchor" href="#串" aria-label="Permalink to &quot;串&quot;">​</a></h3><p>计算机上的非数值处理的对象大部分是字符串数据，字符串一般简称为串。==串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，串是一种内容受限的线性表。==</p><p><strong>串</strong>或<strong>字符串（string）</strong> 是由零个或多个字符组成的有限序列，一般记为 $$ s=^&quot;a_1 a_2 … a_n^&quot;　 (n≥0) $$ 其中，$s$ 是串的名，用双引号标识的字符序列是串的值；$a_i (1≤i≤n)$ 可以是字母、数字或其他字符；串中字符的数目 $n$ 称为串的长度。零个字符的串称为空串（null string），其长度为 0。<br> 串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>，包含子串的串相应地称为<strong>主串</strong>。通常称字符在序列中的序号为该字符在串中的<strong>位置</strong>。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。</p><p>当且仅当两个串的值相等，称这两个<strong>串是相等的</strong>。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时两个串才相等。</p><p>在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串“ ”称为<strong>空格串</strong>（blank string，请注意：此处不是空串），其长度为串中空格字符的个数。为清楚起见，以后我们用符号“$Ø$”来表示“空串”。</p><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，例如，在线性表中查找某个元素，求取某个元素，在某个位置上插入一个元素或删除一个元素等；而在串的基本操作中，通常以“串整体”作为操作对象，例如，在串中查找某个子串，求取一个子串，在串的某个位置上插入一个子串，以及删除一个子串等。<br> 串的抽象数据类型的定义如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String{　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据对象：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ai|ai ∈ CharacterSet,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n,n ≥ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据关系：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">R1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ ＜ ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ＞ |ai-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,ai ∈ D,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n}　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　基本操作：　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrAssign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,chars)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：chars 是字符串常量。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：生成一个其值等于chars 的串T。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrCopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：由串S复制得串T。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若S为空串，则返回true，否则返回false。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrCompare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S和T存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若S</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，则返回值</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ；若S</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，则返回值＝ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ；若S</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，则返回值</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：返回S的元素个数，称为串的长度。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　ClearString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：将S清为空串。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S1 和S2 存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：用T返回由S1 和S2 连接而成的新串。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　SubString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Sub,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,pos,len)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤pos ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 且0 ≤ len ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：用Sub 返回串S的第pos个字符起长度为len 的子串。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,pos)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S和T存在，T是非空串，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤ pos ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos 个字符之后第一次出现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">的位置；否则函数值为0。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S，T和V 存在，T是非空串。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：用V 替换主串S中出现的所有与T相等的不重叠的子串。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,pos,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S和T存在，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤ pos ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：在串S的第pos个字符之前插入串T。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　StrDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,pos,len)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　初始条件：串S存在，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤pos ≤ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">StrLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：从串S中删除第pos个字符起长度为len 的子串。　</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DestroyString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：串S存在。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：串S被销毁。　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ADT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span></code></pre></div><h4 id="串的存储结构" tabindex="-1">串的存储结构 <a class="header-anchor" href="#串的存储结构" aria-label="Permalink to &quot;串的存储结构&quot;">​</a></h4><p>与线性表类似，串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性，串多采用顺序存储结构。</p><ul><li><h6 id="_1-串的顺序存储" tabindex="-1">1．串的顺序存储 <a class="header-anchor" href="#_1-串的顺序存储" aria-label="Permalink to &quot;1．串的顺序存储&quot;">​</a></h6></li></ul><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组描述如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 串的定长顺序存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAXLEN</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 255</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 串的最大长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MAXLEN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 存储串的一维数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 串的当前长度　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}SString;</span></span></code></pre></div><p>其中，MAXLEN 表示串的最大长度，ch 是存储字符串的一维数组，每个分量存储一个字符，length 表示字符串的当前长度。</p><p>这种定义方式是静态的，在编译时刻就确定了串空间的大小。而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。==在 C 语言中，存在一个称之为“堆”（Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。==这种字符串的存储方式也称为串的堆式顺序存储结构，定义如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 串的堆式顺序存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 若是非空串，则按串长分配存储区，否则ch 为NULL　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 串的当前长度　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}HString;</span></span></code></pre></div><ul><li><h6 id="_2-串的链式存储" tabindex="-1">2．串的链式存储 <a class="header-anchor" href="#_2-串的链式存储" aria-label="Permalink to &quot;2．串的链式存储&quot;">​</a></h6></li></ul><p>顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“节点大小”的问题，即每个节点可以存放一个字符，也可以存放多个字符。</p><p><img src="`+P+`" alt="400"></p><p>为了便于进行串的操作，当以链表存储串值时，除头指针外，还可附设一个尾指针指示链表中的最后一个节点，并给出当前串的长度。称如此定义的串存储结构为块链结构，说明如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 串的链式存储结构- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CHUNKSIZE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 80</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可由用户定义的块大小　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Chunk{　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch［CHUNKSIZE］;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Chunk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next;　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}Chunk;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 Chunk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tail;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 串的头和尾指针　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 串的当前长度　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}LString;</span></span></code></pre></div><p>在链式存储方式中，节点大小的选择直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，如一本书的几百万个字符、情报资料的成千上万个条目，这就要求考虑串值的存储密度。<br> 显然，存储密度小（如节点大小为 1 时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。<br> ==串值的链式存储结构对某些串操作，如连接操作等，有一定方便之处，但总的来说，不如顺序存储结构灵活，它占用存储量大且操作复杂。==</p><h4 id="串的模式匹配算法" tabindex="-1">串的模式匹配算法 <a class="header-anchor" href="#串的模式匹配算法" aria-label="Permalink to &quot;串的模式匹配算法&quot;">​</a></h4><p>子串的定位运算通常称为串的<strong>模式匹配</strong>或<strong>串匹配</strong>。此运算的应用非常广泛，比如在搜索引擎、拼写检查、语言翻译、数据压缩等应用中，都需要进行串匹配。<br> 设有两个字符串 S 和 T，设 S 为主串，也称正文串；设 T 为子串，也称为模式。在主串 S 中查找与模式 T 相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串 S 中出现的位置。<br> 著名的模式匹配算法有 <strong>BF 算法</strong>和 <strong>KMP 算法</strong>。</p><ul><li><h6 id="bf-算法" tabindex="-1">BF 算法 <a class="header-anchor" href="#bf-算法" aria-label="Permalink to &quot;BF 算法&quot;">​</a></h6></li></ul><p>最简单直观的模式匹配算法是 BF（Brute-Force）算法。</p><p>【算法步骤】</p><ol><li>分别利用计数指针 $i$ 和 $j$ 指示主串 $S$ 和模式 $T$ 中当前正待比较的字符位置，$i$ 初值为 $pos$，$j$ 初为 $1$。</li><li>如果两个串均未比较到串尾，即 $i$ 和 $j$ 均分别小于等于 $S$ 和 $T$ 的长度时，则循环执行以下操作： <ul><li>$S.ch[i]$ 和 $T.ch[j]$ 比较，若相等，则 $i$ 和 $j$ 分别指示串中下个位置，继续比较后续字符；</li><li>若不相等，指针后退重新开始匹配，从主串的下一个字符 $（i=i−j+2）$ 起再重新和模式的第一个字符 $（j=1）$ 比较。</li></ul></li><li>如果 $j＞T.length$，说明模式 $T$ 中的每个字符依次和主串 $S$ 中的一个连续的字符序列相等，则匹配成功，返回和模式 $T$ 中第一个字符相等的字符在主串 $S$ 中的序号 $（i-T.length）$；否则称匹配不成功，返回 $0$。</li></ol><p>图展示了模式 T = &quot;abcac&quot; 和主串 S 的匹配过程（pos = 1）</p><p><img src="`+L+`" alt="300"><br> 【算法描述】</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Index_BF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> pos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//返回模式T在主串S中第pos个字符开始第一次出现的位置。若不存在，则返回0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//其中，T非空，1 ≤pos ≤ S.length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pos; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 初始化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i ≤ S.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j ≤ T.length)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 两个串均未比较到串尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(S.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j]){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 继续比较后继字符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指针后退，重新开始匹配</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 }　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j ＞ T.length) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 匹配成功</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 匹配失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>【算法分析】<br> BF 算法的匹配过程易于理解，且在某些应用场合效率也较高。在匹配成功的情况下，考虑以下两种极端情况。<br> 最好情况下，每趟不成功的匹配都发生在模式串的第一个字符与主串中相应字符的比较。最好情况下的平均时间复杂度是 $O(n + m)$<br> 最坏情况下，每趟不成功的匹配都发生在模式串的最后一个字符与主串中相应字符的比较。最坏情况下的平均时间复杂度是 $O(n × m)$。<br> BF 算法思路直观简明。但当匹配失败时，主串的指针 i 总是回溯到 i−j+2 位置，模式串的指针总是回溯到首字符位置 j = 1，因此，算法时间复杂度高。</p><ul><li><h6 id="kmp-算法" tabindex="-1">KMP 算法 <a class="header-anchor" href="#kmp-算法" aria-label="Permalink to &quot;KMP 算法&quot;">​</a></h6></li></ul><p>这种改进算法是由克努特（Knuth）、莫里斯（Morris）和普拉特（Pratt）共同设计实现的，因此简称 KMP 算法。此算法可以在 $O(n + m)$ 的时间数量级上完成串的模式匹配操作。其改进在于：每当一趟匹配过程中出现字符不等时，无须回溯主串的指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。<br> 回顾前图中的匹配过程，在第三趟匹配中，当 i = 7、j = 5 指向的字符不等时，又从 i = 4、j = 1 重新开始比较。然后，经仔细观察可发现，i = 4 和 j = 1，i = 5 和 j = 1，以及 i = 6 和 j = 1 这 3 次比较都是不必进行的。因为从第三趟部分匹配的结果就可得出，主串中第 4 个、第 5 个和第 6 个字符必然是 &quot;b&quot;&quot;c&quot; 和 &quot;a&quot;（即模式串中第 2 个、第 3 个和第 4 个字符）。因为模式中的第一个字符是 &quot;a&quot;，因此它无须再和这 3 个字符进行比较，而仅需将模式向右滑动 3 个字符的位置继续进行 i = 7、j = 2 时的字符比较即可。同理，在第一趟匹配中出现字符不等时，仅需将模式向右移动两个字符的位置继续进行 i = 3、j = 1 时的字符比较。由此，在整个匹配的过程中，主串的指针没有回溯，如下图所示。</p><p><img src="`+T+'" alt="400"></p><p>现在讨论一般情况。假设主串为 &quot;s1s2…sn&quot;，模式串为 &quot;t1t2…tm&quot;，从上例的分析可知，为了实现改进算法，需要解决下述问题：当匹配过程中产生“失配”（si≠tj）时，模式串可“向右滑动”的距离有多远，换句话说，当主串中第 i 个字符与模式中第 j 个字符“失配”（不等）时，主串中第 i 个字符（i 指针不回溯）应与模式中哪个字符再比较？</p><p>模式串的 next 函数的定义为： $$ \\text{next}[j] = \\begin{cases} 0 &amp; \\text{(当 } t_1 \\text{ 与 } s_i \\text{ 不等时，下一步进行 } t_1 \\text{ 与 } s_{i+1} \\text{ 的比较)} \\ \\max \\left{ k \\mid 1 &lt; k &lt; j \\text{ 且有 } t_1 t_2 \\cdots t_{k-1} = t_{j-k+1} t_{j-k+2} \\cdots t_{j-1} \\right} &amp; \\ 1 &amp; \\text{(不存在相同子串，下一步进行 } t_1 \\text{ 与 } s_i \\text{ 的比较)} \\end{cases} $$</p><p>由此定义可推出模式串的 next 函数值<br><img src="'+j+'" alt=""></p><p>在求得模式的 next 函数之后，匹配可按如下步骤进行。 假设以指针 i 和 j 分别指示主串和模式中正待比较的字符，令 $i$ 的初值为 $pos$，$j$ 的初值为 $1$。若在匹配过程中 $s_i$ = $t_j$，则 $i$ 和 $j$ 分别增 $1$，否则，$i$ 不变；而 $j$ 退到 $next［j］$ 的位置再比较，若相等，则指针各自增 $1$，否则 $j$ 再退到下一个 $next$ 值的位置，依次类推。直至下列两种可能：一种是 $j$ 退到某个 $next$ 值 $（next［next［…next［j］…］］）$ 时字符相等，则指针各自增 $1$，继续进行匹配；另一种是 $j$ 退到值为 $0$（模式的第一个字符“失配”），则此时需将模式继续向右滑动一个位置，即从主串的下一个字符 $s_{i + 1}$ 起和模式重新开始匹配。</p><p><img src="'+Q+`" alt="400"></p><p>【算法描述】</p><ul><li>KMP 算法</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Index_KMP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> pos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//利用模式串T的next 函数求T在主串S中第pos个字符之后的位置　</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//其中，T非空，1 ≤ pos ≤ S.length</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pos;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">S.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.length)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 两个串均未比较到串尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 {　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">‖S.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j]){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 继续比较后续字符　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 模式串向右移动　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 }　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j ＞ T.length) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 匹配成功　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 匹配失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>计算 next 函数值</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//求模式串T的next 函数值并将其存入数组next　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ；　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i ＜ T.length)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">‖T.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j]){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　}　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>计算 next 函数值的时间复杂度为 $O(m)$。通常，模式串的长度 m 比主串的长度 n 要小得多，因此，对整个匹配算法来说，所增加的这点儿运算时间是值得的。</p><p>最后，要说明以下两点。<br> （1）虽然 BF 算法的时间复杂度是 $O(n×m)$，但在一般情况下，其实际的执行时间近似于 $O(n + m)$，因此至今仍被采用。KMP 算法仅当模式与主串之间存在许多“部分匹配”的情况下，才显得比 BF 算法快得多。但是 KMP 算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾查找一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无须回头重读。<br> （2）前面定义的 next 函数在某些情况下尚有缺陷。</p><ul><li>计算 next 函数修正值</li></ul><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_nextval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SString T，</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> nextval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//求模式串T的next 函数修正值并将之存入数组nextval</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;nextval［</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">］</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i ＜ T.length)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 {　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">‖T.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　{　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　　 ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　　 if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j]) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　　 else</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">　nextval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j];　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　}　</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nextval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[j];　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h3><p>数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受 $n（n≥1）$ 个线性关系的约束，每个元素在 $n$ 个线性关系中的序号 $i_1,i_2,…,i_n$ 称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于 $n（n≥1）$ 个关系中，故称该数组为 n 维数组。数组可以看成线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型。<br> 例如，一维数组可以看成一个线性表，二维数组可以看成数据元素是线性表的线性表。</p><p><img src="`+O+`" alt=""><br> 同理，一个 $n$ 维数组类型可以定义为其数据元素为 $n−1$ 维数组类型的一维数组类型。<br> 数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。<br> 抽象数据类型数组可定义为：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ADT Array{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据对象：ji</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,bi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,…,n，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　　  D </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{aj1j2 jn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)称为数组的维数，bi 是数组第i维的长度，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　　ji是数组元素的第i维下标, aj1j2jn ∈ElemSet}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　数据关系：R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{R1,R2…，Rn}　</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　 Ri </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> aj1...j1...jn,aj1...j1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">1...jn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;|</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">　　　　　 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤ jk ≤ bk−</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤ k ≤ n　且k ≠ i,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">　　　　　 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ≤ ji ≤ bi−</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　　　 ajijijn aj1ji</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jn D i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> L n} ∈ ,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　基本操作：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　InitArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A,n,boundi,…,boundn)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若维数n 和各维长度合法，则构造相应的数组A，并返回OK。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　DestroyArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：销毁数组A。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e,indexl,…,indexn)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：A是n 维数组，e为元素变量，随后是n 个下标值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若各下标不越界，则e赋值为所指定的A的元素值，并返回OK。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　Assign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A,e,indexl,…,indexn)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　初始条件：A是n 维数组，e为元素变量，随后是n 个下标值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　操作结果：若下标不越界，则将e的值赋给所指定的A的元素，并返回OK。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ADT Array</span></span></code></pre></div><p>由于对数组一般不进行插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系一般就不再发生变动，因此，采用<strong>顺序存储结构</strong>表示数组比较合适。<br> 由于存储单元是一维的结构，而数组可能是多维的结构，则用一组连续存储单元存放数组的数据元素就有<strong>次序约定问题</strong>。<br> 对二维数组可有两种存储方式：一种是以列序为主序的存储方式，一种是以行序为主序的存储方式。<br><img src="`+N+'" alt="500"></p><p>由此，对于数组，一旦规定了其维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明。</p><h4 id="特殊矩阵的压缩存储" tabindex="-1">特殊矩阵的压缩存储 <a class="header-anchor" href="#特殊矩阵的压缩存储" aria-label="Permalink to &quot;特殊矩阵的压缩存储&quot;">​</a></h4><p>矩阵是很多科学与工程计算问题中研究的数学对象，矩阵用二维数组来表示是最自然的方法。但是，在数值分析中经常出现一些阶数很高的矩阵，同时在矩阵中有很多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储，是指为多个值相同的元只分配一个存储空间，对零元不分配空间。<br> 假若值相同的元素或者零元素在矩阵中的分布有一定规律，则称此类矩阵为特殊矩阵。特殊矩阵主要包括对称矩阵、三角矩阵和对角矩阵等。</p><ul><li><h6 id="_1-对称矩阵" tabindex="-1">1．对称矩阵 <a class="header-anchor" href="#_1-对称矩阵" aria-label="Permalink to &quot;1．对称矩阵&quot;">​</a></h6></li></ul><p>若 n 阶矩阵 $A$ 中的元满足下述性质： $$ a_{ij} = a_{ji};;;;; (1≤i,j≤n) $$ 则称为 n 阶对称矩阵。<br> 对于对称矩阵，可以为每一对对称元分配一个存储空间，则可将 $n^2$ 个元压缩存储到 $n(n + 1)/2$<br> 个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。</p><p><img src="'+I+'" alt="600"></p><ul><li><h6 id="_2-三角矩阵" tabindex="-1">2．三角矩阵 <a class="header-anchor" href="#_2-三角矩阵" aria-label="Permalink to &quot;2．三角矩阵&quot;">​</a></h6></li></ul><p>以对角线划分，三角矩阵有上三角矩阵和下三角矩阵两种。上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数 $c$ 或 $0$ 的 n 阶矩阵，下三角矩阵与之相反。对三角矩阵进行压缩存储时，除了和对称矩阵一样，只存储其上（下）三角中的元素之外，再加一个存储常数 $c$ 的存储空间即可。</p><ul><li><h6 id="_3-对角矩阵" tabindex="-1">3．对角矩阵 <a class="header-anchor" href="#_3-对角矩阵" aria-label="Permalink to &quot;3．对角矩阵&quot;">​</a></h6></li></ul><p>对角矩阵所有的非零元都集中在以对角线为中心的带状区域中，即除了对角线上和直接在对 角线上、下方若干条与对角线平行的线上的元之外，所有其他的元皆为零。对这种矩阵，也可按某个原则（或以行为主，或以线的顺序）将其压缩存储到一维数组上。</p><p><img src="'+M+'" alt="600"></p><h3 id="广义表" tabindex="-1">广义表 <a class="header-anchor" href="#广义表" aria-label="Permalink to &quot;广义表&quot;">​</a></h3><p>顾名思义，广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言 LISP 语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。<br> 广义表一般记作： $$ LS = (a_1, a_2, \\dots, a_n) $$ 其中，LS 是广义表 $(a_1, a_2, \\dots, a_n)$ 的名称，$n$ 是其长度。在线性表的定义中，$a_i（1≤i≤n）$ 只限于是单个元素。而在广义表的定义中，$a_i$ 可以是单个元素，也可以是广义表，分别称为广义表 $LS$ 的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。</p><p>广义表的 3 个重要结论：<br> （1）广义表的元素可以是子表，而子表的元素还可以是子表……由此，广义表是一个多层次的结构，可以用图形象地表示。<br> （2）广义表可为其他广义表所共享。<br> （3）广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。</p><p>由于广义表的结构比较复杂，其各种运算的实现也不如线性表简单，其中，最重要的两个运算如下。<br> （1）取表头 $GetHead(LS)$：取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。<br> （2）取表尾 $GetTail(LS)$：取出的表尾为除去表头之外由其余元素构成的表，即表尾一定是一个广义表。</p><h4 id="广义表的存储结构" tabindex="-1">广义表的存储结构 <a class="header-anchor" href="#广义表的存储结构" aria-label="Permalink to &quot;广义表的存储结构&quot;">​</a></h4><p>由于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，==通常采用链式存储结构==。常用的链式存储结构有两种，<strong>头尾链表</strong>的存储结构和<strong>扩展线性链表</strong>的存储结构。</p><ul><li><h6 id="_1-头尾链表的存储结构" tabindex="-1">1．头尾链表的存储结构 <a class="header-anchor" href="#_1-头尾链表的存储结构" aria-label="Permalink to &quot;1．头尾链表的存储结构&quot;">​</a></h6></li></ul><p>由于广义表中的数据元素可能为原子或广义表，因此需要两种结构的节点：一种是表节点，用以表示广义表；一种是原子节点，用以表示原子。若广义表不为空，则可分解成表头和表尾，因此，一对确定的表头和表尾可唯一确定广义表。一个表节点可由 3 个域组成：标志域、指示表头的指针域和指示表尾的指针域。而原子节点只需两个域：标志域和值域。如图所示，其中 tag 是标志域，值为 1 时表明节点是子表，值为 0 时表明节点是原子。<br><img src="'+K+`" alt="300"><br> 其形式定义说明如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//- - - - - 广义表的头尾链表存储表示- - - - -</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ATOM,LIST} ElemTag;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //ATOM==0 ：原子；LIST==1 ：子表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLNode</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 ElemTag tag;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 公共部分，用于区分原子节点和表节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　 union</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 原子节点和表节点的联合部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　　　AtomType atom;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //atom 是原子节点的值域，AtomType 由用户定义</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">　　　struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GLNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hp，</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tp;}ptr;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">　　　　　　　　　　　　　　　 //ptr 是表节点的指针域，ptr.hp 和ptr.tp 分别指向</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">表头和表尾</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">　 };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GList;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 广义表类型</span></span></code></pre></div><p><img src="`+V+'" alt=""></p><p>在这种存储结构中有以下几种情况。<br> （1）除空表的表头指针为空外，对任何非空广义表，其表头指针均指向一个表节点，且该节点中的 hp 域指向广义表表头（或为原子节点，或为表节点），tp 域指向广义表表尾（除非表尾为空，则指针为空，否则必为表节点）。<br> （2）容易分清列表中原子和子表所在层次。如在广义表 D 中，原子 a 和 e 在同一层次上，而 b、c 和 d 在同一层次且比 a 和 e 低一层，B 和 C 是同一层的子表。<br> （3）最高层的表节点个数即广义表的长度。以上 3 个特点在某种程度上可给广义表的操作带来方便。</p><ul><li><h6 id="_2-扩展线性链表的存储结构" tabindex="-1">2．扩展线性链表的存储结构 <a class="header-anchor" href="#_2-扩展线性链表的存储结构" aria-label="Permalink to &quot;2．扩展线性链表的存储结构&quot;">​</a></h6></li></ul><p>在这种结构中，无论是表节点还是原子节点均由 3 个域组成。</p><p><img src="'+R+'" alt=""></p><p><img src="'+G+'" alt=""></p><h2 id="五、树和二叉树" tabindex="-1">五、树和二叉树 <a class="header-anchor" href="#五、树和二叉树" aria-label="Permalink to &quot;五、树和二叉树&quot;">​</a></h2><p><strong>树（Tree）</strong> 是 $n（n≥0）$ 个节点的有限集，它或为空树 $（n = 0）$，或为非空树。对于非空树 $T$：<br> （1）有且仅有一个称之为根的节点；<br> （2）除根节点以外的其余节点可分为 $m（m＞0）$ 个互不相交的有限集 $T_1, T_2, …, T_m$，其中每一 个集合本身又是一棵树，并且称为根的<strong>子树（SubTree）</strong>。</p><h3 id="树的基本术语" tabindex="-1">树的基本术语 <a class="header-anchor" href="#树的基本术语" aria-label="Permalink to &quot;树的基本术语&quot;">​</a></h3><h3 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h3><h4 id="二叉树的存储结构" tabindex="-1">二叉树的存储结构 <a class="header-anchor" href="#二叉树的存储结构" aria-label="Permalink to &quot;二叉树的存储结构&quot;">​</a></h4><h4 id="遍历二叉树" tabindex="-1">遍历二叉树 <a class="header-anchor" href="#遍历二叉树" aria-label="Permalink to &quot;遍历二叉树&quot;">​</a></h4><h4 id="线索二叉树" tabindex="-1">线索二叉树 <a class="header-anchor" href="#线索二叉树" aria-label="Permalink to &quot;线索二叉树&quot;">​</a></h4><h3 id="树和森林" tabindex="-1">树和森林 <a class="header-anchor" href="#树和森林" aria-label="Permalink to &quot;树和森林&quot;">​</a></h3><h4 id="树的存储结构" tabindex="-1">树的存储结构 <a class="header-anchor" href="#树的存储结构" aria-label="Permalink to &quot;树的存储结构&quot;">​</a></h4><h3 id="哈夫曼树" tabindex="-1">哈夫曼树 <a class="header-anchor" href="#哈夫曼树" aria-label="Permalink to &quot;哈夫曼树&quot;">​</a></h3><h4 id="哈夫曼编码" tabindex="-1">哈夫曼编码 <a class="header-anchor" href="#哈夫曼编码" aria-label="Permalink to &quot;哈夫曼编码&quot;">​</a></h4><h2 id="六、图" tabindex="-1">六、图 <a class="header-anchor" href="#六、图" aria-label="Permalink to &quot;六、图&quot;">​</a></h2><h3 id="图的基本术语" tabindex="-1">图的基本术语 <a class="header-anchor" href="#图的基本术语" aria-label="Permalink to &quot;图的基本术语&quot;">​</a></h3><h3 id="图的存储结构" tabindex="-1">图的存储结构 <a class="header-anchor" href="#图的存储结构" aria-label="Permalink to &quot;图的存储结构&quot;">​</a></h3><h3 id="图的遍历" tabindex="-1">图的遍历 <a class="header-anchor" href="#图的遍历" aria-label="Permalink to &quot;图的遍历&quot;">​</a></h3><h4 id="深度优先搜索" tabindex="-1">深度优先搜索 <a class="header-anchor" href="#深度优先搜索" aria-label="Permalink to &quot;深度优先搜索&quot;">​</a></h4><h4 id="广度优先搜索" tabindex="-1">广度优先搜索 <a class="header-anchor" href="#广度优先搜索" aria-label="Permalink to &quot;广度优先搜索&quot;">​</a></h4><h3 id="图的应用" tabindex="-1">图的应用 <a class="header-anchor" href="#图的应用" aria-label="Permalink to &quot;图的应用&quot;">​</a></h3><h4 id="最小生成树" tabindex="-1">最小生成树 <a class="header-anchor" href="#最小生成树" aria-label="Permalink to &quot;最小生成树&quot;">​</a></h4><h4 id="最短路径" tabindex="-1">最短路径 <a class="header-anchor" href="#最短路径" aria-label="Permalink to &quot;最短路径&quot;">​</a></h4><h4 id="拓扑排序" tabindex="-1">拓扑排序 <a class="header-anchor" href="#拓扑排序" aria-label="Permalink to &quot;拓扑排序&quot;">​</a></h4><h4 id="关键路径" tabindex="-1">关键路径 <a class="header-anchor" href="#关键路径" aria-label="Permalink to &quot;关键路径&quot;">​</a></h4><h2 id="七、查找" tabindex="-1">七、查找 <a class="header-anchor" href="#七、查找" aria-label="Permalink to &quot;七、查找&quot;">​</a></h2><h3 id="线性表的查找" tabindex="-1">线性表的查找 <a class="header-anchor" href="#线性表的查找" aria-label="Permalink to &quot;线性表的查找&quot;">​</a></h3><h4 id="顺序查找" tabindex="-1">顺序查找 <a class="header-anchor" href="#顺序查找" aria-label="Permalink to &quot;顺序查找&quot;">​</a></h4><h4 id="折半查找" tabindex="-1">折半查找 <a class="header-anchor" href="#折半查找" aria-label="Permalink to &quot;折半查找&quot;">​</a></h4><h4 id="分块查找" tabindex="-1">分块查找 <a class="header-anchor" href="#分块查找" aria-label="Permalink to &quot;分块查找&quot;">​</a></h4><h3 id="树表的查找" tabindex="-1">树表的查找 <a class="header-anchor" href="#树表的查找" aria-label="Permalink to &quot;树表的查找&quot;">​</a></h3><h4 id="二叉排序树" tabindex="-1">二叉排序树 <a class="header-anchor" href="#二叉排序树" aria-label="Permalink to &quot;二叉排序树&quot;">​</a></h4><h4 id="平衡二叉树" tabindex="-1">平衡二叉树 <a class="header-anchor" href="#平衡二叉树" aria-label="Permalink to &quot;平衡二叉树&quot;">​</a></h4><h4 id="b-树" tabindex="-1">B- 树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B- 树&quot;">​</a></h4><h4 id="b-树-1" tabindex="-1">B+ 树 <a class="header-anchor" href="#b-树-1" aria-label="Permalink to &quot;B+ 树&quot;">​</a></h4><h3 id="散列表的查找" tabindex="-1">散列表的查找 <a class="header-anchor" href="#散列表的查找" aria-label="Permalink to &quot;散列表的查找&quot;">​</a></h3><h2 id="八、排序" tabindex="-1">八、排序 <a class="header-anchor" href="#八、排序" aria-label="Permalink to &quot;八、排序&quot;">​</a></h2><h3 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-label="Permalink to &quot;插入排序&quot;">​</a></h3><h4 id="直接插入排序" tabindex="-1">直接插入排序 <a class="header-anchor" href="#直接插入排序" aria-label="Permalink to &quot;直接插入排序&quot;">​</a></h4><h4 id="折半插入排序" tabindex="-1">折半插入排序 <a class="header-anchor" href="#折半插入排序" aria-label="Permalink to &quot;折半插入排序&quot;">​</a></h4><h4 id="希尔排序" tabindex="-1">希尔排序 <a class="header-anchor" href="#希尔排序" aria-label="Permalink to &quot;希尔排序&quot;">​</a></h4><h3 id="交换排序" tabindex="-1">交换排序 <a class="header-anchor" href="#交换排序" aria-label="Permalink to &quot;交换排序&quot;">​</a></h3><h4 id="冒泡排序" tabindex="-1">冒泡排序 <a class="header-anchor" href="#冒泡排序" aria-label="Permalink to &quot;冒泡排序&quot;">​</a></h4><h4 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h4><h3 id="选择排序" tabindex="-1">选择排序 <a class="header-anchor" href="#选择排序" aria-label="Permalink to &quot;选择排序&quot;">​</a></h3><h4 id="简单选择排序" tabindex="-1">简单选择排序 <a class="header-anchor" href="#简单选择排序" aria-label="Permalink to &quot;简单选择排序&quot;">​</a></h4><h4 id="树形选择排序" tabindex="-1">树形选择排序 <a class="header-anchor" href="#树形选择排序" aria-label="Permalink to &quot;树形选择排序&quot;">​</a></h4><h4 id="堆排序" tabindex="-1">堆排序 <a class="header-anchor" href="#堆排序" aria-label="Permalink to &quot;堆排序&quot;">​</a></h4><h3 id="归并排序" tabindex="-1">归并排序 <a class="header-anchor" href="#归并排序" aria-label="Permalink to &quot;归并排序&quot;">​</a></h3><h3 id="基数排序" tabindex="-1">基数排序 <a class="header-anchor" href="#基数排序" aria-label="Permalink to &quot;基数排序&quot;">​</a></h3><h3 id="外部排序" tabindex="-1">外部排序 <a class="header-anchor" href="#外部排序" aria-label="Permalink to &quot;外部排序&quot;">​</a></h3>',249))])}const ss=t(X,[["render",Z]]);export{Y as __pageData,ss as default};
