import{_ as d,c as e,o as r,ag as a}from"./chunks/framework.-ewJmwvT.js";const o="/obsidian-vitepress-docs/assets/d0fae4d90bbb4cb397f372a5783ee422~tplv-k3u1fbpfcp-z.CqB3biam.webp",i="/obsidian-vitepress-docs/assets/56b4cc008d674181a1aaf6c9f96aa8c8~tplv-k3u1fbpfcp-z.BnxIZ1IQ.webp",n="/obsidian-vitepress-docs/assets/5e0c75ecf66543c28a385beec9079798~tplv-k3u1fbpfcp-z.DyFhLSl6.webp",l="/obsidian-vitepress-docs/assets/d225058ebc3744ce843cca2d42ef42d5~tplv-k3u1fbpfcp-z.CWwaT7Pn.webp",g=JSON.parse('{"title":"HTTP 协议","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/04_HTTP协议.md","filePath":"计算机基础课程/网络/01 网络原理/04_HTTP协议.md"}'),c={name:"计算机基础课程/网络/01 网络原理/04_HTTP协议.md"};function h(T,t,s,p,b,P){return r(),e("div",null,t[0]||(t[0]=[a('<h1 id="http-协议" tabindex="-1">HTTP 协议 <a class="header-anchor" href="#http-协议" aria-label="Permalink to &quot;HTTP 协议&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>HTTP 全称<strong>HyperText Transfer Protocol</strong>，<strong>超文本传输协议</strong>。</p><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>HTTP 是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。这也是 Cookie 技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。</p><h2 id="http-版本" tabindex="-1">HTTP 版本 <a class="header-anchor" href="#http-版本" aria-label="Permalink to &quot;HTTP 版本&quot;">​</a></h2><ul><li><h6 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h6></li></ul><p>最早的 http 只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的 TCP 链接，收到响应之后立即断开连接。</p><hr><ul><li><h6 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h6></li></ul><p>HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等。<br> HTTP/1.1 允许范围请求，即在请求头中加入 <code>Range</code> 头部。<br> HTTP/1.1 的请求消息和响应消息都必须包含 <code>Host</code> 头部，以区分同一个物理主机中的不同虚拟主机的域名。<br> HTTP/1.1 默认开启持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><hr><ul><li><h6 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h6></li></ul><p>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。 帧代表数据传输的最小的单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。</p><ul><li><strong>新的二进制格式：</strong> HTTP/1.x 的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。二进制则不同，只识别 0 和 1 的组合。基于这种考虑 HTTP/2.0 的协议解析采用二进制格式，方便且强大。</li><li><strong>多路复用：</strong> HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行，极大的提高传输性能。</li><li><strong>头部压缩：</strong> HTTP/1.x 的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表，既避免了重复头部的传输，又减小了需要传输的大小。</li><li><strong>服务端推送：</strong> 这里的服务端推送指把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。</li></ul><hr><ul><li><h6 id="http-3-0" tabindex="-1">HTTP/3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP/3.0&quot;">​</a></h6></li></ul><p>HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。反而对于 HTTP/1.0 来说，可以开启多个 TCP 连接，出现丢包反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。 出现包阻塞的原因是因为底层 TCP 协议导致的问题，但是修改 TCP 协议是不现实的问题，就像 <code>typeof null === &#39;object&#39;</code> 一样，修改这个问题会导致出现更多的问题。既然不能修改你，那就另起一个协议取代你。Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。<br> QUIC 基于 UDP，但是 UDP 本身存在不稳定性等诸多问题，所以 QUIC 在 UDP 的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。优点诸多，参考 <a href="https://link.juejin.cn?target=https://www.jianshu.com/p/bb3eeb36b479" title="这里" target="_blank" rel="noreferrer">这里</a>：</p><ul><li><strong>避免包阻塞：</strong> 多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题，TCP 需要等待该包重传后，才能继续传输其它流的数据包。但在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。</li><li><strong>快速重启会话：</strong> 普通基于 tcp 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。</li></ul><h2 id="连接方式" tabindex="-1">连接方式 <a class="header-anchor" href="#连接方式" aria-label="Permalink to &quot;连接方式&quot;">​</a></h2><ul><li><strong>串行连接：</strong> HTTP 有无连接的特性，即每次连接只能处理一个请求，收到响应后立即断开连接。HTTP/1.0 版本（称为串行连接或短连接、短轮询）中每次 HTTP 通信后都要断开 TCP 连接，所以每个新的 HTTP 请求都需要建立一个新的连接。但在现在网站动则几十条 HTTP 请求的情况下，很容易达到浏览器请求上限，并且每次请求都建立新的 tcp 连接（每次都有三次握手四次挥别）极大的增加了通信开销。</li><li><strong>持久连接：</strong> 为解决这个问题，有人提出了持久连接（也叫长连接、长轮询）。一定时间内，同一域名下的 HTTP 请求，只要两端都没有提出断开连接，则持久保持 TCP 连接状态，其他请求可以复用这个连接通道。HTTP/1.1 实现并默认了所有连接都是持久连接，这样客户端发起多个 HTTP 请求时就减少了 TCP 握手造成的网络资源和通信时间的浪费。但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。</li><li><strong>管道化持久连接：</strong> 管道化则可以不用等待响应返回而发送下个请求并按顺序返回响应，现代浏览器并未默认开启管道化。（这方面收集到的资料有限不多说了）</li><li><strong>HTTP/2.0 多路复用：</strong> 每个 HTTP 请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱（ <a href="https://link.juejin.cn?target=https://segmentfault.com/q/1010000005167289" title="细节参照此文" target="_blank" rel="noreferrer">细节参照此文</a>）。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个 TCP 连接，极大增加了服务器处理并发的上限。</li><li><strong>WebSocket：</strong> WebSocket 是 HTML5 提出的一种客户端和服务端通讯的全双工协议，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，服务端可以主动向客户端推送信息。</li></ul><h2 id="http-报文" tabindex="-1">HTTP 报文 <a class="header-anchor" href="#http-报文" aria-label="Permalink to &quot;HTTP 报文&quot;">​</a></h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。客户端的 HTTP 报文叫请求报文，服务端的 HTTP 报文叫响应报文。</p><ul><li><p><strong>请求报文</strong></p><p>请求报文是由请求行（请求方法、协议版本）、请求首部（请求 URI、客户端信息等）和内容实体（用户信息和资源信息等，可为空）构成。</p><p><img src="'+o+'" alt=""></p><p><img src="'+i+'" alt=""></p></li><li><p><strong>响应报文</strong><br> 响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成。</p><p><img src="'+n+'" alt=""></p><p><img src="'+l+'" alt=""></p></li></ul><h2 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-label="Permalink to &quot;请求方法&quot;">​</a></h2><ul><li>GET：get 方法一般用于获取服务器资源</li><li>POST：post 方法一般用于传输实体主体</li><li>PUT：put 方法一般用于传输文件</li><li>DELETE：delete 方法用于删除文件</li><li>HEAD：head 方法用于获取报文首部，不返回报文主体</li><li>OPTIONS：options 方法用于询问请求 URI 资源支持的方法</li></ul><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h2><p>HTTP 状态码表示客户端 HTTP 请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p><table tabindex="0"><thead><tr><th>2XX</th><th>成功（这系列表明请求被正常处理了）</th></tr></thead><tbody><tr><td>200</td><td>OK，表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td>204</td><td>No content，表示请求成功，但响应报文不含实体的主体部分</td></tr><tr><td>206</td><td>Partial Content，进行范围请求成功</td></tr></tbody></table><table tabindex="0"><thead><tr><th>3XX</th><th>重定向（表明浏览器要执行特殊处理）</th></tr></thead><tbody><tr><td>301</td><td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td></tr><tr><td>302</td><td>found，临时性重定向，表示资源临时被分配了新的 URL</td></tr><tr><td>303</td><td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于 301/302/303 响应，几乎所有浏览器都会删除报文主体并自动用 GET 重新请求）</td></tr><tr><td>304</td><td>not modified，协商缓存，与重定向无关</td></tr><tr><td>307</td><td>temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td></tr></tbody></table><table tabindex="0"><thead><tr><th>4XX</th><th>客户端错误</th></tr></thead><tbody><tr><td>400</td><td>bad request，请求报文存在语法错误</td></tr><tr><td>401</td><td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td></tr><tr><td>403</td><td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td></tr><tr><td>404</td><td>not found，表示在服务器上没有找到请求的资源</td></tr></tbody></table><table tabindex="0"><thead><tr><th>5XX</th><th>服务器错误</th></tr></thead><tbody><tr><td>500</td><td>internal sever error，表示服务器端在执行请求时发生了错误</td></tr><tr><td>501</td><td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td></tr><tr><td>503</td><td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td></tr></tbody></table><h2 id="首部字段" tabindex="-1">首部字段 <a class="header-anchor" href="#首部字段" aria-label="Permalink to &quot;首部字段&quot;">​</a></h2><p>下面是请求首部和响应首部中的字段名称和作用</p><table tabindex="0"><thead><tr><th>通用首部</th><th>作用（请求报文和响应报文都可能使用）</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为：<code>no-cache</code>（强制向服务器再次验证）、<code>no-store</code>（不做任何缓存）、<code>max-age=111111</code>（资源可缓存最大时间 秒）、<code>public</code>（客户端、代理服务器都可利用缓存）、<code>private</code>（代理服务器不可用缓存）</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型： <code>keep-alive close</code>（开启和关闭持久连接）</td></tr><tr><td>Date</td><td>创建报文时间</td></tr><tr><td>Pragma</td><td>只用于请求报文，客户端要求中间服务器不返回缓存的资源</td></tr><tr><td>Via</td><td>代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割</td></tr><tr><td>Transfer-Encoding</td><td>传输编码方式：<code>chunked</code> 分块传输</td></tr><tr><td>Upgrade</td><td>要求客户端使用的升级协议，需配合 <code>Connection: Upgrade</code> 一起使用：<code>websocket</code></td></tr><tr><td>Warning</td><td>缓存相关问题的警告</td></tr></tbody></table><table tabindex="0"><thead><tr><th>请求首部</th><th>作用（请求报文专用）</th></tr></thead><tbody><tr><td>Accept</td><td>能正确接收的媒体类型：<code>application/json</code> <code>text/plain</code></td></tr><tr><td>Accept-Charset</td><td>能正确接收的字符集: <code>unicode-1-1</code></td></tr><tr><td>Accept-Encoding</td><td>能正确接收的编码格式列表：<code>gzip deflate</code></td></tr><tr><td>Accept-Language</td><td>能正确接收的语言列表：<code>zh-cn,zh;1=0.9,en,1=0.8</code></td></tr><tr><td>Authorization</td><td>客户端认证信息：<code>Bearer dSdSdFFlsfdjasd123</code>，一般存 token 用</td></tr><tr><td>Cookie</td><td>发送给服务器的 Cookie 信息</td></tr><tr><td>Expect</td><td>期待服务端的指定行为</td></tr><tr><td>From</td><td>请求方邮箱地址</td></tr><tr><td>Host</td><td>服务器的域名，用于区分单台服务器多个域名的虚拟主机，是 HTTP/1.1 唯一必须包含的字段。</td></tr><tr><td>If-Match</td><td>两端资源标记比较，只有判断条件为真服务端才会接受请求：<code>If-Mach: &quot;123456</code>，和服务端文件标记比较</td></tr><tr><td>If-Modified-Since</td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td>If-None-Match</td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td>User-Agent</td><td>客户端信息</td></tr><tr><td>Max-Forwards</td><td>限制可被代理及网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td>向代理服务器发送验证信息</td></tr><tr><td>Range</td><td>请求某个内容的一部分，配合 <code>If-Range</code> 使用</td></tr><tr><td>Referer</td><td>请求发起页面的原始 URI</td></tr><tr><td>TE</td><td>传输编码方式</td></tr></tbody></table><table tabindex="0"><thead><tr><th>响应首部</th><th>作用（响应报文专用）</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>告知客户端服务器是否可接受范围请求，是 <code>bytes</code>，否 <code>none</code></td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识，资源发生变化时标识也会发生改变</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>向代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字：<code>Apache Nginx</code></td></tr><tr><td>WWW-Authenticate</td><td>获取资源需要的认证方案</td></tr><tr><td>Set-Cookie</td><td>需要存在客户端的信息，一般用于识别用户身份</td></tr></tbody></table><table tabindex="0"><thead><tr><th>实体首部</th><th>作用（补充请求报文或响应报文相关信息）</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式：<code>GET HEAD POST</code></td></tr><tr><td>Content-Encoding</td><td>内容的编码格式：<code>gzip deflate</code></td></tr><tr><td>Content-Language</td><td>内容使用的语言：<code>zh-CN</code></td></tr><tr><td>Content-Length</td><td>request body 长度（即实体主体的大小）：</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64 加密格式的内容 MD5 检验值</td></tr><tr><td>Content-Range</td><td>响应主体的内容范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型（如 &#39;application/json;charset=UTF-8&#39; 则会发送预检请求）</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table>',38)]))}const f=d(c,[["render",h]]);export{g as __pageData,f as default};
