import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.-ewJmwvT.js";const p="/obsidian-vitepress-docs/assets/image_eVYWAT3xdU.B-zLv-qt.png",n="/obsidian-vitepress-docs/assets/image_nIYBf02Oqa.Ds091Y1G.png",E=JSON.parse('{"title":"依赖注入 Provide - Inject","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/07 Vue/Vue3/23 Provide - Inject.md","filePath":"前端技术/07 Vue/Vue3/23 Provide - Inject.md"}'),l={name:"前端技术/07 Vue/Vue3/23 Provide - Inject.md"};function h(r,s,k,o,d,c){return e(),a("div",null,s[0]||(s[0]=[t('<h1 id="依赖注入-provide-inject" tabindex="-1">依赖注入 Provide - Inject <a class="header-anchor" href="#依赖注入-provide-inject" aria-label="Permalink to &quot;依赖注入 Provide - Inject&quot;">​</a></h1><h2 id="prop-逐级透传问题" tabindex="-1">Prop 逐级透传问题 <a class="header-anchor" href="#prop-逐级透传问题" aria-label="Permalink to &quot;Prop 逐级透传问题&quot;">​</a></h2><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 <a href="https://cn.vuejs.org/guide/components/props.html" title="props" target="_blank" rel="noreferrer">props</a>。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：</p><p><img src="'+p+'" alt=""></p><p>注意，虽然这里的 <code>&lt;Footer&gt;</code> 组件可能根本不关心这些 props，但为了使 <code>&lt;DeepChild&gt;</code> 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。</p><p><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题。 <a href="https://cn.vuejs.org/guide/components/provide-inject.html#footnote-1%22" target="_blank" rel="noreferrer">依赖注入</a> 一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p><p><img src="'+n+`" alt=""></p><h2 id="provide-提供" tabindex="-1">Provide (提供) <a class="header-anchor" href="#provide-提供" aria-label="Permalink to &quot;Provide (提供)&quot;">​</a></h2><p>要为组件后代提供数据，需要使用到 <code>provide()</code> 函数：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script setup</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { provide } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 注入名 */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 值 */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p><code>provide()</code> 函数接收两个参数。</p><ul><li><p>第一个参数被称为<strong>注入名</strong>，可以是一个字符串或是一个 <code>Symbol</code>。后代组件会用注入名来查找期望注入的值。一个组件可以多次调用 <code>provide()</code>，使用不同的注入名，注入不同的依赖值。</p></li><li><p>第二个参数是提供的值，值可以是任意类型，包括响应式的状态。</p></li></ul><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createApp } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 注入名 */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 值 */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写 <a href="https://cn.vuejs.org/guide/reusability/plugins.html" title="插件" target="_blank" rel="noreferrer">插件</a> 时会特别有用，因为插件一般都不会使用组件形式来提供值。</p><h2 id="inject-注入" tabindex="-1">Inject (注入) <a class="header-anchor" href="#inject-注入" aria-label="Permalink to &quot;Inject (注入)&quot;">​</a></h2><p>要注入上层组件提供的数据，需使用 <code>inject()</code> 函数：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script setup</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>如果提供的值是一个 ref，注入进来的会是该 ref 对象，而<strong>不会</strong>自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。</p><ul><li>注入默认值<br> 默认情况下，<code>inject</code> 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。<br> 如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似：<code>const value = inject(&#39;message&#39;, &#39;这是默认值&#39;)</code></li></ul><h2 id="源码解析-未完成" tabindex="-1">源码解析 (未完成) <a class="header-anchor" href="#源码解析-未完成" aria-label="Permalink to &quot;源码解析 (未完成)&quot;">​</a></h2><p>provide 通过 <code>Object.create(parentProvides)</code> 函数在父节点的原型对象上对应属性，把属性挂载上去。</p><p>子节点 Inject 时一步步往原型链上找，直到找到父节点原型对象上的属性</p>`,23)]))}const y=i(l,[["render",h]]);export{E as __pageData,y as default};
