import{_ as a,c as n,o as p,ae as e}from"./chunks/framework.CIivgcbp.js";const l="/obsidian-vitepress-docs/assets/%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.vsNvbJ5K.png",i="/obsidian-vitepress-docs/assets/01%20%E4%BB%80%E4%B9%88%E6%98%AFWebGL-1.GFs5risi.png",t="/obsidian-vitepress-docs/assets/01%20%E4%BB%80%E4%B9%88%E6%98%AFWebGL-2.B23uKp-M.png",m=JSON.parse('{"title":"01 什么是 WebGL","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/07浏览器交互/WebGL入门/01 什么是WebGL.md","filePath":"前端技术/03 JavaScript/07浏览器交互/WebGL入门/01 什么是WebGL.md"}'),c={name:"前端技术/03 JavaScript/07浏览器交互/WebGL入门/01 什么是WebGL.md"};function r(b,s,o,d,h,_){return p(),n("div",null,s[0]||(s[0]=[e('<h1 id="_01-什么是-webgl" tabindex="-1">01 什么是 WebGL <a class="header-anchor" href="#_01-什么是-webgl" aria-label="Permalink to &quot;01 什么是 WebGL&quot;">​</a></h1><blockquote><p>课程来源 <a href="https://www.bilibili.com/video/BV1AS411A74T/?vd_source=4893d415f0165117c03333e63748cadf#reply1905847060" target="_blank" rel="noreferrer">2024年全网最新最详细《WebGL教程》_哔哩哔哩_bilibili</a><br> 文档来源 <a href="https://bx2eq6ulg18.feishu.cn/docx/I4hTdO95qozPBOxauPlcbDfInVd" target="_blank" rel="noreferrer">WebGL入门教程文档 - 飞书云文档 (feishu.cn)</a></p></blockquote><p>WebGL 全称叫做 Web Graphics Library，它是 JavaScript API。用于在任何兼容的 Web 浏览器中渲染交互式的 3D 图形，并且无需使用插件。它基于 OpenGL ES 2.0（一个用于嵌入式系统的图形库），并与其他 Web 标准完全集成，使开发者能够利用 GPU 加速图形处理直接在网页上实现复杂的图形效果。​</p><p>WebGL 可以在网页上开发高性能的 3D 游戏，许多现代网页游戏都利用了 WebGL 实现了丰富的图形效果和流畅的用户体验。​</p><p>在网页上实现这些丰富的图形效果，就需要在网页上有一块专门用来绘制图形的区域，这块区域叫做画布。因此在 web 网页上实现 WebGL 效果，需要使用到 canvas 画布元素。​</p><h2 id="webgl-坐标系​" tabindex="-1">WebGL 坐标系​ <a class="header-anchor" href="#webgl-坐标系​" aria-label="Permalink to &quot;WebGL 坐标系​&quot;">​</a></h2><p>在 WebGL 中，坐标系使用的是右手坐标系，手掌朝向自己大拇指与食指垂直，食指与中指垂直形成一个空间。大拇指方向是 X 轴，食指方向是 Y 轴，中指方向是 Z 轴。​</p><p><img src="'+l+'" alt=""></p><ul><li>X、Y、Z 轴正方向最大值都为 1，负方向最大值都为 -1。</li></ul><h2 id="canvas-画布上的坐标​" tabindex="-1">Canvas 画布上的坐标​ <a class="header-anchor" href="#canvas-画布上的坐标​" aria-label="Permalink to &quot;Canvas 画布上的坐标​&quot;">​</a></h2><p>Canvas 画布可以支持 2D，也可以支持 3D。但是 2D 和 3D 坐标方向是完全不同的。​</p><ul><li><p>2D，坐标原点是 canvas 画布的左顶点，水平方向向右是 X 轴，竖直方向向下是 Y 轴<br><img src="'+i+'" alt="">​</p></li><li><p>3D，坐标原点是 canvas 画布的中心点，水平方向向右是 X 轴，竖直方向向上是 Y 轴，屏幕朝外方向是 Z 轴​<br><img src="'+t+`" alt=""></p></li></ul><h2 id="webgl-渲染管线​" tabindex="-1">WebGL 渲染管线​ <a class="header-anchor" href="#webgl-渲染管线​" aria-label="Permalink to &quot;WebGL 渲染管线​&quot;">​</a></h2><p>渲染管线是指将数据从 3D 场景转换成 2D 图像，最终在屏幕上显示出来的总过程。它包含多个步骤，每个步骤处理不同的图形处理任务。​</p><ol><li><p>顶点处理：顶点着色器处理每个顶点的数据，将顶点坐标从对象空间转换到裁剪空间。<br> ​</p></li><li><p>图元装配：顶点被组合成图元（例如三角形、线段、点）。WebGL 支持的基本图元类型包括点、线段和三角形。​</p></li><li><p>光栅化：将图元转换为片段（fragments），每个片段对应一个屏幕像素。光栅化过程确定哪些像素被图元覆盖，并生成这些片段的插值属性（如颜色、深度、纹理坐标）。​</p></li><li><p>片段处理：片段着色器对每个片段执行操作，确定其最终颜色。片段着色器可以执行纹理采样、光照计算和颜色混合等操作。​</p></li><li><p>测试阶段：深度测试和模板测试​<br> a. 深度测试：确定片段是否在当前帧缓冲区的深度范围内，以决定是否绘制该片段。​<br> b. 模板测试：使用模板缓冲区进行进一步的片段筛选。​</p></li><li><p>融合阶段：将片段颜色与帧缓冲区中已有的颜色混合，以实现透明效果等。​</p></li><li><p>帧缓冲操作：最终的片段颜色被写入帧缓冲区，准备显示在屏幕上。帧缓冲区是一个存储颜色、深度和模板信息的内存区域。</p></li></ol><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 应用程序（CPU）            │​</span></span>
<span class="line"><span>│ - 提供顶点数据             │​</span></span>
<span class="line"><span>│ - 设置着色器程序            │​</span></span>
<span class="line"><span>│ - 调用绘制命令             │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 顶点着色器（Vertex Shader）│​</span></span>
<span class="line"><span>│ - 顶点变换                │​</span></span>
<span class="line"><span>│ - 顶点属性计算             │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 图元装配（Primitive Assembly） │​</span></span>
<span class="line"><span>│ - 将顶点组装成图元          │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 光栅化（Rasterization）    │​</span></span>
<span class="line"><span>│ - 将图元转换为片元（像素）   │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 片元着色器（Fragment Shader） │​</span></span>
<span class="line"><span>│ - 计算片元颜色               │​</span></span>
<span class="line"><span>│ - 应用纹理和光照效果          │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 逐片元操作（Per-fragment Operations）│​</span></span>
<span class="line"><span>│ - 深度测试                │​</span></span>
<span class="line"><span>│ - 模板测试                │​</span></span>
<span class="line"><span>│ - 混合操作                │​</span></span>
<span class="line"><span>└──────────┬───────────────┘​</span></span>
<span class="line"><span>			│​</span></span>
<span class="line"><span>			▼​</span></span>
<span class="line"><span>┌──────────────────────────┐​</span></span>
<span class="line"><span>│ 帧缓冲区（Frame Buffer）   │​</span></span>
<span class="line"><span>│ - 最终图像显示在屏幕上      │​</span></span>
<span class="line"><span>└──────────────────────────┘</span></span></code></pre></div>`,16)]))}const G=a(c,[["render",r]]);export{m as __pageData,G as default};
