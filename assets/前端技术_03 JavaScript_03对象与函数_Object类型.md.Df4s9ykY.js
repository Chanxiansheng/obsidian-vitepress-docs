import{_ as e,c as l,o as a,ae as d}from"./chunks/framework.CIivgcbp.js";const b=JSON.parse('{"title":"Object 类型","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/03对象与函数/Object类型.md","filePath":"前端技术/03 JavaScript/03对象与函数/Object类型.md"}'),i={name:"前端技术/03 JavaScript/03对象与函数/Object类型.md"};function s(n,t,o,r,c,g){return a(),l("div",null,t[0]||(t[0]=[d('<h1 id="object-类型" tabindex="-1">Object 类型 <a class="header-anchor" href="#object-类型" aria-label="Permalink to &quot;Object 类型&quot;">​</a></h1><p><strong><code>Object</code></strong> 是 JavaScript 的一种数据类型 。它用于存储各种键值集合和更复杂的实体。Objects 可以通过 Object() 构造函数或者使用 对象字面量 的方式创建。</p><p>在 JavaScript 中，几乎所有的对象都是 <code>Object</code> 类型的实例，它们都会从 <code>Object.prototype</code> 继承属性和方法，虽然大部分属性都会被覆盖（shadowed）或者说被重写了（overridden）。</p><p>通过原型链，所有的 object 都能观察到 Object 原型对象（Object prototype object）的改变，除非这些受到改变影响的属性和方法沿着原型链被进一步的重写。尽管有潜在的危险，但这为覆盖或扩展对象的行为提供了一个非常强大的机制。</p><h2 id="一、创建-object-对象" tabindex="-1">一、创建 Object 对象 <a class="header-anchor" href="#一、创建-object-对象" aria-label="Permalink to &quot;一、创建 Object 对象&quot;">​</a></h2><ol><li>使用花括号 <code>{name: &#39;John&#39;}</code></li><li>使用 Object 构造方法 <code>new Object()</code> - 如果给定值是 <code>null</code> 或 <code>undefined</code>，将会创建并返回一个空对象 - 如果传进去的是一个基本类型的值，则会构造其包装类型的对象 - 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址</li></ol><h2 id="二、成员的增删改查" tabindex="-1">二、成员的增删改查 <a class="header-anchor" href="#二、成员的增删改查" aria-label="Permalink to &quot;二、成员的增删改查&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>用 dot(点 .) 的方式访问 <code>obj.name</code>，常用于静态对象使用时来获取 obj 的属性值</p><p>用方括号 (<code>[]</code>) 的方式访问 obj[&#39;name&#39;]，用于动态存取属性</p><ol><li>增、改、查<br> 均可以使用 <code>obj.name</code> 和 <code>obj[&#39;name&#39;]</code> 的形式进行<br> 增改也可以使用 Object.defineProperty()，属性配置更加全面</li><li>删<br> 利用关键字 <code>delete obj.name</code></li></ol><h2 id="三、数据类型检测" tabindex="-1">三、数据类型检测 <a class="header-anchor" href="#三、数据类型检测" aria-label="Permalink to &quot;三、数据类型检测&quot;">​</a></h2><ul><li><code>typeof</code> 多用于原始数据类型的判断，返回一个字符串，表示未经计算的操作数的类型。</li></ul><blockquote><p><em>typeof 无法准确检测大部分引用数值类型。</em></p></blockquote><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">typeof 返回值</th><th style="text-align:left;">对象包装器</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>NaN</strong></td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;"><strong>Null</strong></td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;"><strong>Undefined</strong></td><td style="text-align:left;"><code>undefined</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;">Boolean</td><td style="text-align:left;"><code>boolean</code></td><td style="text-align:left;">Boolean</td></tr><tr><td style="text-align:left;">Number</td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;">BigInt</td><td style="text-align:left;"><code>bigint</code></td><td style="text-align:left;">BigInt</td></tr><tr><td style="text-align:left;">String</td><td style="text-align:left;"><code>string</code></td><td style="text-align:left;">String</td></tr><tr><td style="text-align:left;">Symbol</td><td style="text-align:left;"><code>symbol</code></td><td style="text-align:left;">Symbol</td></tr><tr><td style="text-align:left;">Object、Array、Function 等</td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">对应的引用数据类型</td></tr></tbody></table><ul><li><p><strong><code>toString</code></strong><br> 由于简单数值类型不能直接使用 toString 方法，因此一般使用 call 借用 <code>toString</code> 函数</p><pre><code>  ```javascript\n</code></pre><p>function Mytypeof(data){ return Object.prototype.toString.call(data) }</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span></code></pre></div></li></ul><h2 id="四、object-常用静态方法" tabindex="-1">四、Object 常用静态方法 <a class="header-anchor" href="#四、object-常用静态方法" aria-label="Permalink to &quot;四、Object 常用静态方法&quot;">​</a></h2><ul><li>拷贝相关</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">描述</th><th style="text-align:left;">返回值</th><th style="text-align:left;">参数</th><th style="text-align:left;">注意点</th></tr></thead><tbody><tr><td style="text-align:left;">Object.assign(target, ...sources)</td><td style="text-align:left;">将所有可枚举的自有属性从一个或多个源对象复制到目标对象，返回修改后的对象。</td><td style="text-align:left;">新的对象</td><td style="text-align:left;">target 目标对象;sources 源对象</td><td style="text-align:left;">此方法为为浅拷贝。常用于复制对象、合并对象</td></tr><tr><td style="text-align:left;">Object.create(proto)</td><td style="text-align:left;">创建一个新对象，使用现有的对象来作为新创建对象的原型</td><td style="text-align:left;">一个新对象，带着指定的原型对象及其属性</td><td style="text-align:left;">proto 原型对象</td><td style="text-align:left;">常用于类式继承</td></tr></tbody></table><ul><li>属性相关</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">描述</th><th style="text-align:left;">返回值</th><th style="text-align:left;">参数</th><th style="text-align:left;">注意点</th></tr></thead><tbody><tr><td style="text-align:left;">Object.defineProperties(obj, props</td><td style="text-align:left;">直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</td><td style="text-align:left;">传递给函数的对象</td><td style="text-align:left;">obj 目标对象 props 配置对象，有 configurable、enumerable、value、writable、get、set</td><td style="text-align:left;">常用于数据劫持、Polyfill、getter 和 setter</td></tr><tr><td style="text-align:left;">Object.defineProperty(obj, prop, descriptor)</td><td style="text-align:left;">同上，不过只能更改一个属性</td><td style="text-align:left;">传递给函数的对象</td><td style="text-align:left;">prop 对应属性</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">hasOwn(instance, prop)</td><td style="text-align:left;">如果指定的对象自身有指定的属性，则静态方法 Object.hasOwn() 返回 true。如果属性是继承的或者不存在，该方法返回 false。</td><td style="text-align:left;">如果指定的对象中直接定义了指定的属性，则返回 true；否则返回 false。</td><td style="text-align:left;">instance 实例对象； prop 要测试属性的 String 类型的名称或者 Symbol</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Object.is(value1, value2)</td><td style="text-align:left;">判断两个值是否为同一个值。<br></td><td style="text-align:left;">一个布尔值，表示两个参数是否是同一个值。</td><td style="text-align:left;">两个比较的值</td><td style="text-align:left;"></td></tr></tbody></table><p>Object.is() 与 == 不同。== 运算符在判断相等前对两边的变量（如果它们不是同一类型）进行强制转换（这种行为将 &quot;&quot; == false 判断为 true），而 Object.is 不会强制转换两边的值。<br> Object.is() 与 === 也不相同。差别是它们对待有符号的零和 NaN 不同，例如，=== 运算符（也包括 == 运算符）将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等。</p><ul><li>枚举相关</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">描述</th><th style="text-align:left;">返回值</th><th style="text-align:left;">参数</th><th style="text-align:left;">注意点</th></tr></thead><tbody><tr><td style="text-align:left;">Object.keys(obj)</td><td style="text-align:left;">返回一个由一个给定对象的自身可枚举<strong>属性</strong>组成的数组</td><td style="text-align:left;">一个表示给定对象的所有可枚举属性的字符串数组</td><td style="text-align:left;">obj 目标对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Object.values(obj)</td><td style="text-align:left;">返回一个给定对象自身的所有可枚举<strong>属性值</strong>的数组</td><td style="text-align:left;">一个包含对象自身的所有可枚举属性值的数组</td><td style="text-align:left;">obj 目标对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Object.entries(obj)</td><td style="text-align:left;">返回一个给定对象自身可枚举属性的<strong>键值对</strong>数组</td><td style="text-align:left;">给定对象自身可枚举属性的键值对数组</td><td style="text-align:left;">obj 目标对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Object.getOwnPropertyNames(obj)</td><td style="text-align:left;">获取到自身的<strong>所有属性</strong>的 key，<strong>包括不可枚举的属性</strong>，只包含字符串属性，不包括 Symbol 属性</td><td style="text-align:left;">在给定对象上找到的自身属性对应的字符串数组。</td><td style="text-align:left;">obj 目标对象</td><td style="text-align:left;"></td></tr></tbody></table><ul><li>其他</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">描述</th><th style="text-align:left;">返回值</th><th style="text-align:left;">参数</th><th style="text-align:left;">注意点</th></tr></thead><tbody><tr><td style="text-align:left;">Object.getOwnPropertySymbols()</td><td style="text-align:left;">获取到自身的<strong>所有 Symbol 属性</strong>的 key，如果对象没有 Symbol 属性，会返回一个空数组</td><td style="text-align:left;">要返回 Symbol 属性的对象。</td><td style="text-align:left;">obj 目标对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Object.fromEntries(Array)</td><td style="text-align:left;">将二维数组转换为对象。在每个子数组的第一个元素是 key，在每个子数组的第二个元素是 value。</td><td style="text-align:left;">一个由二维组数组合成的对象</td><td style="text-align:left;">Array 数组</td><td style="text-align:left;"></td></tr></tbody></table><h2 id="五、实例方法-原型上的方法" tabindex="-1">五、实例方法（原型上的方法） <a class="header-anchor" href="#五、实例方法-原型上的方法" aria-label="Permalink to &quot;五、实例方法（原型上的方法）&quot;">​</a></h2><ul><li>hasOwnProperty()<br> 可以判断自己身上是否有某个属性（不包含原型链上的，只是自己本身），symbol 和不可枚举的也可以判断到。</li><li>isPrototypeOf()<br> 判断对象是否在自己的原型链上，它与 <code>instanceof</code> 的区别在于，<code>instanceof</code> 只会判断某个对象的 <code>prtotype</code> 属性，而这个方法是直接可以判断对象的。</li><li>toString()<br> 判断一个对象的真实类型，因为它会返回一个对象的类型字符串</li></ul>',28)]))}const f=e(i,[["render",s]]);export{b as __pageData,f as default};
