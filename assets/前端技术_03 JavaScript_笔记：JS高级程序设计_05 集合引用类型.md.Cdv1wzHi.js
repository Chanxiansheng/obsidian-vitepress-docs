import{_ as s,c as a,o as e,ae as t}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"05 集合引用类型","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/05 集合引用类型.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/05 集合引用类型.md"}'),l={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/05 集合引用类型.md"};function n(h,i,p,k,d,r){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="_05-集合引用类型" tabindex="-1">05 集合引用类型 <a class="header-anchor" href="#_05-集合引用类型" aria-label="Permalink to &quot;05 集合引用类型&quot;">​</a></h1><h2 id="object" tabindex="-1">Object <a class="header-anchor" href="#object" aria-label="Permalink to &quot;Object&quot;">​</a></h2><p>显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，另一种方式是使用对象字面量（object literal）表示法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>==在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数。==</p><p>属性一般是通过点语法来存取的，也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式。</p><h2 id="array" tabindex="-1">Array <a class="header-anchor" href="#array" aria-label="Permalink to &quot;Array&quot;">​</a></h2><p>ECMAScript 数组是一组有序的数据，数组中每个槽位可以存储任意类型的数据。<br> ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。</p><h3 id="创建数组" tabindex="-1">创建数组 <a class="header-anchor" href="#创建数组" aria-label="Permalink to &quot;创建数组&quot;">​</a></h3><p>使用 Array 构造函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> colors1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> colors2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> colors3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值。也可以给 Array 构造函数传入要保存的元素。</p><p>数组字面量：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> colors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;green&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包含3 个元素的数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个空数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> values </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包含2 个元素的数组</span></span></code></pre></div><blockquote><p>[!example]+ from()<br><code>from()</code> 用于将类数组结构转换为数组实例。<br> 第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串会被拆分为单字符数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Matt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以使用from()将集合和映射转换为一个新数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [1, 2]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Array.from()对现有数组执行浅复制</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const a2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以使用任何可迭代对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const iter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[Symbol.iterator]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		yield</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		yield</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		yield</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		yield</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iter)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [1, 2, 3, 4]</span></span></code></pre></div><p>Array.from() 还接收第二个可选的映射函数参数。<br> 还可以接收第三个可选参数，用于指定映射函数中 this 的值。</p></blockquote><blockquote><p>[!example]+ of()<br><code>of()</code> 用于将一组参数转换为数组实例。<br><code>Array.of(1, 2, 3, 4)</code></p></blockquote><ul><li>数组空位<br> 使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。<br> ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined。<br><code>const options = [1,,,];</code></li></ul><h3 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h3><ul><li><p>数组索引<br> 要取得或设置数组的值，需要使用中括号并提供相应值的数字索引。</p></li><li><p>length<br> 数组中元素的数量保存在 length 属性中，它不是只读的，通过修改 length 属性，可以从数组末尾删除或添加元素。</p></li></ul><h3 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h3><h4 id="数组类型检测" tabindex="-1">- 数组类型检测 <a class="header-anchor" href="#数组类型检测" aria-label="Permalink to &quot;- 数组类型检测&quot;">​</a></h4><p><code>Array.isArray()</code> 方法可以确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</p><h4 id="迭代器方法" tabindex="-1">- 迭代器方法 <a class="header-anchor" href="#迭代器方法" aria-label="Permalink to &quot;- 迭代器方法&quot;">​</a></h4><p>Array 的原型上暴露了 3 个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code> 和 <code>entries()</code>。keys() 返回数组索引的迭代器，values() 返回数组元素的迭代器，而 entries() 返回索引/值对的迭代器。</p><h3 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h3><h4 id="复制和填充方法" tabindex="-1">- 复制和填充方法 <a class="header-anchor" href="#复制和填充方法" aria-label="Permalink to &quot;- 复制和填充方法&quot;">​</a></h4><blockquote><p>[!example]+ fill<br><code>fill</code> 方法用于将数组中的指定部分的所有元素填充为静态值。</p><p><code>arr.fill(value, start, end)</code></p><ul><li>value: 要填充数组的值。</li><li>start (可选): 开始填充位置的索引，默认值为 0。如果为负数，则从数组末尾开始计算位置。</li><li>end (可选): 结束填充位置之前的索引，默认值为 <code>this.length</code>。如果为负数，则从数组末尾开始计算位置。</li></ul><p><code>fill</code> 静默忽略超出数组边界、零长度及方向相反的索引范围。</p></blockquote><blockquote><p>[!example]+ copyWithin<br><code>copyWithin</code> 方法浅复制数组的一部分到同一数组中的另一个位置，并返回修改后的数组。</p><p><code>arr.copyWithin(target, start, end)</code></p><ul><li>target: 0 为基础的索引，表示要修改内容的起始位置。如果是负数，则从数组末尾开始计算。</li><li>start (可选): 0 为基础的索引，表示拷贝序列的起始位置。如果是负数，则从数组末尾开始计算。默认值是 0。</li><li>end (可选): 0 为基础的索引，表示拷贝序列的结束位置（不包括该位置）。如果是负数，则从数组末尾开始计算。默认值是 <code>this.length</code>。</li></ul><p><code>copyWithin</code> 静默忽略超出数组边界、零长度及方向相反的索引范围</p></blockquote><h4 id="扩展操作符" tabindex="-1">- 扩展操作符 <a class="header-anchor" href="#扩展操作符" aria-label="Permalink to &quot;- 扩展操作符&quot;">​</a></h4><p>使用扩展操作符可以将数组的元素逐个展开，从而更容易将元素从一个数组合并、复制或插入到另一个数组中。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originalArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> copiedArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">originalArray]</span></span></code></pre></div><h4 id="剩余操作符" tabindex="-1">- 剩余操作符 <a class="header-anchor" href="#剩余操作符" aria-label="Permalink to &quot;- 剩余操作符&quot;">​</a></h4><p>剩余操作符用于将数组的剩余元素收集到一个新数组中，通常用于函数参数或解构赋值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [first, second, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rest] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h4 id="转换方法" tabindex="-1">- 转换方法 <a class="header-anchor" href="#转换方法" aria-label="Permalink to &quot;- 转换方法&quot;">​</a></h4><p><code>valueOf()</code> 方法返回的还是数组本身。<br><code>toString()</code> 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。</p><blockquote><p>[!example]+ join<br><code>join</code> 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。</p><p><code>arr.join(separator)</code></p><ul><li>separator (可选): 指定一个字符串来分隔数组中的每个元素。默认为一个逗号 (<code>&#39;,&#39;</code>)。如果 separator 是空字符串 (<code>&#39;&#39;</code>)，则表示不使用任何分隔符直接连接元素。</li></ul><p><code>join</code> 方法不会改变原数组。<br> 如果数组只有一个元素，那么将返回该元素而不使用分隔符。<br> 如果没有提供分隔符，相邻的两个元素将会以默认的逗号作为分隔。<br> 对于非字符串类型的元素，它们将被转换成字符串再进行连接。</p></blockquote><h4 id="栈方法" tabindex="-1">- 栈方法 <a class="header-anchor" href="#栈方法" aria-label="Permalink to &quot;- 栈方法&quot;">​</a></h4><p>栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push() 和 pop() 方法，以实现类似栈的行为。</p><blockquote><p>[!example]+ push<br><code>push</code> 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</p><p><code>arr.push(element1, ..., elementN)</code></p><ul><li>element1, ..., elementN: 要添加到数组末尾的一个或多个元素。</li></ul><p><code>push</code> 方法直接修改原数组，不会创建新的数组。</p></blockquote><blockquote><p>[!example]+ pop<br><code>pop</code> 方法从数组中删除最后一个元素，并返回该元素。</p><p><code>arr.pop()</code></p><ul><li>无参数。</li></ul><p><code>pop</code> 方法会改变调用它的原数组，移除并返回数组的最后一个元素。<br> 对于空数组，调用 <code>pop</code> 方法将返回 <code>undefined</code>。</p></blockquote><h4 id="队列方法" tabindex="-1">- 队列方法 <a class="header-anchor" href="#队列方法" aria-label="Permalink to &quot;- 队列方法&quot;">​</a></h4><p>队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。</p><blockquote><p>[!example]+ unshift<br><code>unshift</code> 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。</p><p><code>arr.unshift(element1, ..., elementN)</code></p><ul><li>element1, ..., elementN: 要添加到数组开头的一个或多个元素。</li></ul><p><code>unshift</code> 方法直接修改原数组，通过在数组头部插入新元素来扩展数组。<br> 此操作会改变数组的长度。</p></blockquote><blockquote><p>[!example]+ shift<br><code>shift</code> 方法从数组中删除第一个元素，并返回该元素。</p><p><code>arr.shift()</code></p><ul><li>无参数。</li></ul><p><code>shift</code> 方法会改变调用它的原数组，移除并返回数组的第一个元素。<br> 对于空数组，调用 <code>shift</code> 方法将返回 <code>undefined</code>。</p></blockquote><h4 id="排序方法" tabindex="-1">- 排序方法 <a class="header-anchor" href="#排序方法" aria-label="Permalink to &quot;- 排序方法&quot;">​</a></h4><blockquote><p>[!example]+ reverse<br><code>reverse</code> 方法将数组中的元素颠倒顺序。第一个元素会变成最后一个，最后一个元素会变成第一个。</p><p><code>arr.reverse()</code></p><ul><li>无参数。</li></ul><p><code>reverse</code> 直接修改原数组，并返回该数组的引用。</p></blockquote><blockquote><p>[!example]+ sort<br><code>sort</code> 方法用于对数组的元素进行排序。默认情况下，它会按照字符串的 Unicode 码点来排序数组元素。可以通过提供一个比较函数来指定排序规则。</p><p><code>arr.sort([compareFunction])</code></p><ul><li>compareFunction (可选): 用来指定按某种顺序进行排列的函数。如果省略，元素会被转换成字符串，然后按照每个字符的 Unicode 码点值进行排序。 <ul><li>当比较函数 (a, b) 返回值小于 0，a 会被排到 b 之前；返回值等于 0，a 和 b 的相对位置不变；返回值大于 0，b 会被排到 a 之前。</li></ul></li></ul><p><code>sort</code> 方法直接修改原数组，并返回该数组的引用。</p></blockquote><ul><li>常用的排序模式：</li></ul><table tabindex="0"><thead><tr><th>排序类型</th><th>代码示例</th></tr></thead><tbody><tr><td>数值升序</td><td><code>arr.sort((a, b) =&gt; a - b)</code></td></tr><tr><td>数值降序</td><td><code>arr.sort((a, b) =&gt; b - a)</code></td></tr><tr><td>字符串升序</td><td><code>arr.sort((a, b) =&gt; a.localeCompare(b))</code></td></tr><tr><td>字符串降序</td><td><code>arr.sort((a, b) =&gt; b.localeCompare(a))</code></td></tr></tbody></table><h4 id="操作方法" tabindex="-1">- 操作方法 <a class="header-anchor" href="#操作方法" aria-label="Permalink to &quot;- 操作方法&quot;">​</a></h4><blockquote><p>[!example]+ concat<br><code>concat</code> 方法用于合并两个或多个数组。</p><p><code>arr.concat(value1, value2, ..., valueN)</code></p><ul><li>value1, value2, ..., valueN: 要合并的数组或值。可以是单独的元素，也可以是一个或多个数组。</li></ul><p><code>concat</code> 方法不会更改现有数组，而是返回一个新数组。<br><code>Symbol.isConcatSpreadable</code> 符号能够阻止 concat 打平参数数组。</p></blockquote><blockquote><p>[!example]+ slice<br><code>slice</code> 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。</p><p><code>arr.slice([begin[, end]])</code></p><ul><li>begin (可选): 提取起始处的索引，默认为 0。如果为负数，则从数组末尾开始计算。</li><li>end (可选): 提取终止处的索引（提取不包括该索引位置的元素），默认为到数组的末尾。如果为负数，则从数组末尾开始计算。</li></ul><p><code>slice</code> 方法不会修改原数组，它只是简单地返回所需部分的一个副本。</p></blockquote><blockquote><p>[!example]+ splice<br><code>splice</code> 方法通过删除或替换现有元素或者添加新元素来修改数组，并以数组形式返回被修改的内容。</p><p><code>arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code></p><ul><li>start: 指定修改的开始位置。如果是负数，则从数组末尾开始计算。</li><li>deleteCount (可选): 整数，表示要移除的数组元素的个数。如果不指定，则从 start 开始到数组末尾的所有元素都将被移除。如果 deleteCount 为 0 或负数，则不会移除任何元素。</li><li>item1, item2, ... (可选): 要添加进数组的元素，从 start 位置开始。如果不指定这些参数，则 splice 只会移除数组元素。</li></ul><p><code>splice</code> 方法不仅能移除数组中的元素，还可以在指定位置插入新的元素，同时这些操作都会直接作用于原数组上。</p></blockquote><h4 id="搜索和位置方法" tabindex="-1">- 搜索和位置方法 <a class="header-anchor" href="#搜索和位置方法" aria-label="Permalink to &quot;- 搜索和位置方法&quot;">​</a></h4><p>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。<br> ECMAScript 提供了 3 个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code> 和 <code>includes()</code>。</p><blockquote><p>[!example]+ indexOf<br><code>indexOf</code> 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 -1。搜索从数组的起始位置开始。</p><p><code>arr.indexOf(searchElement[, fromIndex])</code></p><ul><li>searchElement: 要查找的元素。</li><li>fromIndex (可选): 开始搜索的索引位置。默认为 0。如果该索引值大于或等于数组长度，将返回 -1；如果为负数，则按从数组末尾算起的位置计算。</li></ul><p><code>indexOf</code> 方法是从数组的开头（位置 0）开始搜索的。它不会修改原数组。</p></blockquote><blockquote><p>[!example]+ lastIndexOf<br><code>lastIndexOf</code> 方法返回在数组中可以找到一个给定元素的最高索引，如果不存在，则返回 -1。搜索从数组的结尾位置开始向开头方向进行。</p><p><code>arr.lastIndexOf(searchElement[, fromIndex])</code></p><ul><li>searchElement: 要查找的元素。</li><li>fromIndex (可选): 开始搜索的索引位置。默认为数组长度减一。如果该索引值大于或等于数组长度，整个数组都会被搜索。如果为负数，则从数组末尾开始计算。</li></ul><p><code>lastIndexOf</code> 方法是从数组的结尾开始搜索的。它不会修改原数组。</p></blockquote><blockquote><p>[!example]+ includes<br><code>includes</code> 方法用来判断一个数组是否包含一个指定的值，如果是则返回 true，否则返回 false。</p><p><code>arr.includes(searchElement[, fromIndex])</code></p><ul><li>searchElement: 要查找的元素。</li><li>fromIndex (可选): 开始搜索的索引位置。默认为 0。如果为负数，则按从数组末尾算起的位置计算。</li></ul><p><code>includes</code> 方法可用于检测数组中是否存在某个值。与 <code>indexOf</code> 不同的是，它直接返回布尔值而不是索引，并且能正确处理 NaN 的情况。</p></blockquote><p>ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p><p><code>find()</code> 和 <code>findIndex()</code> 方法使用了断言函数。</p><blockquote><p>[!example]+ find<br><code>find</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><p><code>arr.find(callback(element[, index[, array]])[, thisArg])</code></p><ul><li>callback: 用来测试数组中的每个元素的函数，接受三个参数： <ul><li>element: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>find</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 函数时，用于 this 的值。</li></ul><p><code>find</code> 方法会遍历数组直至找到一个使 callback 返回 true 的元素，然后直接返回该元素；若无任何元素满足条件，则返回 undefined。它不会修改原数组。</p></blockquote><blockquote><p>[!example]+ findIndex<br><code>findIndex</code> 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回 -1。</p><p><code>arr.findIndex(callback(element[, index[, array]])[, thisArg])</code></p><ul><li>callback: 用来测试数组中的每个元素的函数，接受三个参数： <ul><li>element: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>findIndex</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 函数时，用于 this 的值。</li></ul><p><code>findIndex</code> 方法会遍历数组直至找到一个使 callback 返回 true 的元素，然后直接返回该元素的索引；若无任何元素满足条件，则返回 -1。它不会修改原数组。</p></blockquote><h4 id="迭代方法" tabindex="-1">- 迭代方法 <a class="header-anchor" href="#迭代方法" aria-label="Permalink to &quot;- 迭代方法&quot;">​</a></h4><p>ECMAScript 为数组定义了 5 个迭代方法。<br> 每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。</p><blockquote><p>[!example]+ every<br><code>every</code> 方法测试数组的所有元素是否都通过了测试函数的实现。它返回一个布尔值。</p><p><code>arr.every(callback(element[, index[, array]])[, thisArg])</code></p><ul><li>callback: 用来测试每个元素的函数，接受三个参数： <ul><li>element: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>every</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 时使用的 this 值。</li></ul><p><code>every</code> 方法会遍历整个数组，如果所有元素都满足条件（callback 返回 true），则返回 true；否则返回 false。它不会修改原数组。</p></blockquote><blockquote><p>[!example]+ filter<br><code>filter</code> 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。</p><p><code>arr.filter(callback(element[, index[, array]])[, thisArg])</code></p><ul><li>callback: 用来测试数组中的每个元素的函数，接受三个参数： <ul><li>element: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>filter</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 函数时，用于 this 的值。</li></ul><p><code>filter</code> 方法会遍历数组，对于每个元素调用 callback 函数，如果 callback 返回 true，则该元素会被添加到新数组中。最终返回的是一个新的数组，原数组不会被改变。</p></blockquote><blockquote><p>[!example]+ forEach<br><code>forEach</code> 方法对数组的每个元素执行一次提供的函数。</p><p><code>arr.forEach(callback(currentValue[, index[, array]])[, thisArg])</code></p><ul><li>callback: 为数组中每个元素执行的函数，该函数接收一至三个参数： <ul><li>currentValue: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>forEach</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 时使用的 this 值。</li></ul><p><code>forEach</code> 方法按升序为数组中的每个元素调用一次 callback 函数。它不返回任何内容且不会修改原数组。</p></blockquote><blockquote><p>[!example]+ map<br><code>map</code> 方法创建一个新数组，其结果是对调用数组中的每个元素调用一个提供的函数。</p><p><code>arr.map(callback(currentValue[, index[, array]])[, thisArg])</code></p><ul><li>callback: 生成新数组元素的函数，使用三个参数： <ul><li>currentValue: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>map</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 函数时，用于 this 的值。</li></ul><p><code>map</code> 方法会遍历数组，并对每个元素调用 callback 函数，然后将 callback 的返回值作为新的数组中对应位置的值。它不会修改原数组，而是返回一个新的数组。</p></blockquote><blockquote><p>[!example]+ some<br><code>some</code> 方法测试数组中的某些元素是否至少有一个通过了由提供的函数实现的测试。它返回一个布尔值。</p><p><code>arr.some(callback(element[, index[, array]])[, thisArg])</code></p><ul><li>callback: 用来测试每个元素的函数，接受三个参数： <ul><li>element: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>some</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 时使用的 this 值。</li></ul><p><code>some</code> 方法会遍历数组，一旦有任意一个元素满足条件（callback 返回 true），则立即返回 true；若无任何元素满足条件，则返回 false。它不会修改原数组。</p></blockquote><h4 id="归并方法" tabindex="-1">- 归并方法 <a class="header-anchor" href="#归并方法" aria-label="Permalink to &quot;- 归并方法&quot;">​</a></h4><p>ECMAScript 为数组提供了两个归并方法：<code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce() 方法从数组第一项开始遍历到最后一项。 而 reduceRight() 从最后一项开始遍历至第一项。</p><blockquote><p>[!example]+ reduce<br><code>reduce</code> 方法对数组中的每个元素执行一个由您提供的 reducer 函数（升序执行），将其结果汇总为单个返回值。</p><p><code>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p><ul><li>callback: 一个执行数组中每个元素的 reducer 函数，包含四个参数： <ul><li>accumulator: 累加器累计回调的返回值以及初始值（如果提供）。</li><li>currentValue: 当前正在处理的数组元素。</li><li>index (可选): 当前正在处理的数组元素的索引。</li><li>array (可选): 调用了 <code>reduce</code> 的数组。</li></ul></li><li>initialValue (可选): 作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组的第一个元素。在没有初始值的空数组上调用 reduce 将报错。</li></ul><p><code>reduce</code> 方法遍历整个数组并“减少”其所有元素到一个单一的值。它非常适合用于累加、扁平化或其它需要合并数组元素的操作。</p></blockquote><blockquote><p>[!example]+ reduceRight<br><code>reduceRight</code> 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）来将其缩减为单个值。</p><p><code>arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p><ul><li>callback: 一个执行数组中每个元素的 reducer 函数，包含四个参数： <ul><li>accumulator: 累加器累计回调的返回值以及初始值（如果提供）。</li><li>currentValue: 当前正在处理的数组元素。</li><li>index (可选): 当前正在处理的数组元素的索引。</li><li>array (可选): 调用了 <code>reduceRight</code> 的数组。</li></ul></li><li>initialValue (可选): 作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组的最后一个元素。在没有初始值的空数组上调用 reduceRight 将报错。</li></ul><p><code>reduceRight</code> 方法与 <code>reduce</code> 类似，但它按降序方向（从数组末尾向开头）遍历数组元素。这在某些特定场景下特别有用，例如当操作依赖于从右至左的顺序时。</p></blockquote><h4 id="展开方法" tabindex="-1">- 展开方法 <a class="header-anchor" href="#展开方法" aria-label="Permalink to &quot;- 展开方法&quot;">​</a></h4><p>数组提供了 <code>flat()</code> 和 <code>flatMap()</code> 方法，让数组的展开操作更加容易。</p><blockquote><p>[!example]+ flat<br><code>flat</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与子数组中的元素合并为一个新数组。</p><p><code>arr.flat([depth])</code></p><ul><li>depth (可选): 指定要提取嵌套数组的结构深度，默认值是 1。如果忽略此参数或传递小于 1 的值，则被视为 1。使用 Infinity 可以展开任意深度的嵌套数组。</li></ul><p><code>flat</code> 返回的是浅拷贝，不会修改原数组。</p></blockquote><blockquote><p>[!example]+ flatMap<br><code>flatMap</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它在功能上等同于 <code>map</code> 遍历数组后再对结果调用 <code>flat</code>，但 <code>flatMap</code> 通常比单独调用两者更高效。</p><p><code>arr.flatMap(callback(currentValue[, index[, array]])[, thisArg])</code></p><ul><li>callback: 生成新数组元素的函数，接受三个参数： <ul><li>currentValue: 当前正在处理的元素。</li><li>index (可选): 当前正在处理的元素的索引。</li><li>array (可选): 调用了 <code>flatMap</code> 的数组。</li></ul></li><li>thisArg (可选): 执行 callback 函数时，用于 this 的值。</li></ul><p><code>flatMap</code> 方法首先像 <code>map</code> 一样应用回调函数到原数组的每个元素，然后将结果展平一层，返回一个新的数组。这使得 <code>flatMap</code> 成为了处理需要同时映射和展平层级的任务的理想选择。</p></blockquote><h2 id="定型数组" tabindex="-1">定型数组 <a class="header-anchor" href="#定型数组" aria-label="Permalink to &quot;定型数组&quot;">​</a></h2><p>定型数组（typed array）是 ECMAScript 新增的结构，是用于处理二进制数据的一种特殊类型的数组。它们提供了一种机制来读写内存缓冲区中的原始二进制数据，并且在性能和内存使用方面比普通数组更加高效，尤其是在处理大量数值数据时，如 WebGL 中的图形处理或音视频流的处理。</p><h3 id="arraybuffer" tabindex="-1">ArrayBuffer <a class="header-anchor" href="#arraybuffer" aria-label="Permalink to &quot;ArrayBuffer&quot;">​</a></h3><p>Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。</p><p>ArrayBuffer 是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。<br><code>const buf = new ArrayBuffer(16);</code><br> ArrayBuffer 一经创建就不能再调整大小。</p><h3 id="dataview" tabindex="-1">DataView <a class="header-anchor" href="#dataview" aria-label="Permalink to &quot;DataView&quot;">​</a></h3><p>第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。<br> 必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fullDataView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构造函数接收一个可选的字节偏移量和字节长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> firstHalfDataView</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>ECMAScript 6 支持 8 种不同的 ElementType：</p><table tabindex="0"><thead><tr><th>ElementType</th><th>字节</th><th>说明</th><th>等价的 C 类型</th><th>值的范围</th></tr></thead><tbody><tr><td>Int8</td><td>1</td><td>8 位有符号整数</td><td>signed char</td><td>-128 ~ 127</td></tr><tr><td>Uint8</td><td>1</td><td>8 位无符号整数</td><td>unsigned char</td><td>0 ~ 255</td></tr><tr><td>Int16</td><td>2</td><td>16 位有符号整数</td><td>short</td><td>-32 768 ~ 32 767</td></tr><tr><td>Uint16</td><td>2</td><td>16 位无符号整数</td><td>unsigned short</td><td>0 ~ 65 535</td></tr><tr><td>Int32</td><td>4</td><td>32 位有符号整数</td><td>int</td><td>-2 147 483 648 ~ 2 147 483 647</td></tr><tr><td>Uint32</td><td>4</td><td>32 位无符号整数</td><td>unsigned int</td><td>0 ~ 4 294 967 295</td></tr><tr><td>Float32</td><td>4</td><td>32 位 IEEE-754 浮点数</td><td>float</td><td>-3.4e+38 ~ 3.4e+38</td></tr><tr><td>Float64</td><td>8</td><td>64 位 IEEE-754 浮点数</td><td>double</td><td>-1.7e+308 ~ 1.7e+308</td></tr></tbody></table><p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个长度为16字节的ArrayBuffer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 向buffer中写入一些数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">view.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInt16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在第0个字节处写入16位整数256，使用大端字节序</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">view.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setFloat32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Math.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在第2个字节处写入32位浮点数π，使用小端字节序</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从buffer中读取数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(view.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInt16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应输出256</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(view.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getFloat32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应输出π的近似值</span></span></code></pre></div><p><code>littleEndian</code> 参数是可选的，指定了是否使用小端字节序。如果未指定，默认使用大端字节序。</p><div class="info custom-block github-alert"><p class="custom-block-title">+ 字节序</p><p>“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。<br> 大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p></div><p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError。</p><h3 id="定型数组-1" tabindex="-1">定型数组 <a class="header-anchor" href="#定型数组-1" aria-label="Permalink to &quot;定型数组&quot;">​</a></h3><p>定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的 API 和更高的性能。</p><table tabindex="0"><thead><tr><th>ElementType</th><th>构造函数</th><th>描述</th><th>字节数</th></tr></thead><tbody><tr><td>Int8</td><td><code>Int8Array</code></td><td>8 位有符号整数</td><td>1</td></tr><tr><td>Uint8</td><td><code>Uint8Array</code></td><td>8 位无符号整数</td><td>1</td></tr><tr><td>Uint8C</td><td><code>Uint8ClampedArray</code></td><td>8 位无符号整数（裁剪到 0 或 255）</td><td>1</td></tr><tr><td>Int16</td><td><code>Int16Array</code></td><td>16 位有符号整数</td><td>2</td></tr><tr><td>Uint16</td><td><code>Uint16Array</code></td><td>16 位无符号整数</td><td>2</td></tr><tr><td>Int32</td><td><code>Int32Array</code></td><td>32 位有符号整数</td><td>4</td></tr><tr><td>Uint32</td><td><code>Uint32Array</code></td><td>32 位无符号整数</td><td>4</td></tr><tr><td>Float32</td><td><code>Float32Array</code></td><td>32 位 IEEE 浮点数</td><td>4</td></tr><tr><td>Float64</td><td><code>Float64Array</code></td><td>64 位 IEEE 浮点数</td><td>8</td></tr></tbody></table><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个12 字节的缓冲</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个引用该缓冲的Int32Array</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ints</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int32Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf);</span></span></code></pre></div><p>另外，类似于创建数组通过 <code>&lt;ElementType&gt;.from()</code> 和 <code>&lt;ElementType&gt;.of()</code> 也可以创建定型数组：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 基于普通数组来创建一个Int16Array</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ints5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int16Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 基于传入的参数创建一个Float32Array</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> floats</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.718</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.618</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ol><li><p>定型数组行为<br> 从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：</p><ul><li><code>[]</code></li><li><code>copyWithin()</code></li><li><code>entries()</code></li><li><code>every()</code></li><li><code>fill()</code></li><li><code>filter()</code></li><li><code>find()</code></li><li><code>findIndex()</code></li><li><code>forEach()</code></li><li><code>indexOf()</code></li><li><code>join()</code></li><li><code>keys()</code></li><li><code>lastIndexOf()</code></li><li><code>length</code></li><li><code>map()</code></li><li><code>reduce()</code></li><li><code>reduceRight()</code></li><li><code>reverse()</code></li><li><code>slice()</code></li><li><code>some()</code></li><li><code>sort()</code></li><li><code>toLocaleString()</code></li><li><code>toString()</code></li><li><code>values()</code></li></ul></li><li><p>合并、复制和修改定型数组<br> 定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p><ul><li><code>concat()</code></li><li><code>pop()</code></li><li><code>push()</code></li><li><code>shift()</code></li><li><code>splice()</code></li><li><code>unshift()</code><br> 不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set() 和 subarray()。</li><li><code>set()</code> 从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置</li><li><code>subarray()</code> 执行与 set() 相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的</li></ul></li><li><p>下溢和上溢<br> 定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。</p></li></ol><h2 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h2><p>Map 是一种新的集合类型，它允许我们存储键值对，并且键可以是任意类型的数据。</p><p><code>const m = new Map();</code><br> 可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组。<br><code>const m = mew Map([[key1,val1],[key2,val2],...])</code></p><ul><li><strong>添加键值对</strong>：<code>set(key,value)</code></li><li><strong>获取值</strong>：<code>get(key)</code></li><li><strong>检查键的存在</strong>：<code>has(key)</code></li><li><strong>删除键值对</strong>：<code>delete(key)</code></li><li><strong>清空</strong>：<code>clear()</code></li><li><strong>获取数量 (属性)</strong>：<code>size</code></li></ul><p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键。映射的值是没有限制的。</p><p>Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等（<code>===</code>）的标准来检查键的匹配性。<br> 在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变。</p><ul><li>顺序与迭代</li></ul><p>与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序。(一种结合了哈希表和双向链表的数据结构，哈希表意味着更快的查找，双向链表意味着更快的遍历和插入)</p><p>映射实例可以提供一个迭代器（Iterator），能以插入顺序生成 <code>[key, value]</code> 形式的数组。可以通过 <code>entries()</code> 方法（或者 ==Symbol.iterator== ）取得这个迭代器。</p><p><code>keys()</code> 和 <code>values()</code> 分别返回以插入顺序生成键和值的迭代器。</p><p><code>forEach(callback, opt_thisArg)</code> 方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值。</p><h2 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h2><p>ECMAScript 6 新增的 Set 是一种新集合类型，它不允许重复的元素。</p><p><code>const s = new Set();</code><br> 可以给 Set 构造函数传入一个可迭代对象：<br><code>const s1 = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]);</code></p><ul><li>添加元素：<code>add(value)</code></li><li>查询元素：<code>has(value)</code></li><li>删除元素：<code>delete(value)</code></li><li>清空：<code>clear()</code></li><li>获取数量（属性）：<code>size</code></li></ul><p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作，基本上相当于使用严格对象相等的标准来检查值的匹配性。</p><ul><li>顺序与迭代<br> Set 会维护值插入时的顺序，因此支持按顺序迭代。(通常使用哈希表实现)</li></ul><p>集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 <code>values()</code> 方法及其别名方法 <code>keys()</code>（或者 <code>Symbol.iterator</code> 属性）取得这个迭代器。</p><h2 id="弱引用" tabindex="-1">弱引用 <a class="header-anchor" href="#弱引用" aria-label="Permalink to &quot;弱引用&quot;">​</a></h2><p>在某些情况下，我们可能希望保持对某个对象的引用，但又不阻止它被当作垃圾回收，这种引用称为“<strong>弱引用</strong>”。</p><h3 id="weakref" tabindex="-1">WeakRef <a class="header-anchor" href="#weakref" aria-label="Permalink to &quot;WeakRef&quot;">​</a></h3><p>可以通过 WeakRef 类创建对象的弱引用，只有一个参数，即需要弱引用的目标对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Matt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weakRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)</span></span></code></pre></div><p>目标对象在实例化后不能改变。<br> 要访问目标对象，使用 <code>deref()</code> 方法，这个方法返回目标对象，或者在垃圾回收后返回 undefined。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Matt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weakRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weakRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// { name: &quot;Matt&quot; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weakRef.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span></code></pre></div><h3 id="finalizationregistry" tabindex="-1">FinalizationRegistry <a class="header-anchor" href="#finalizationregistry" aria-label="Permalink to &quot;FinalizationRegistry&quot;">​</a></h3><p>==谨慎使用==<br> 当我们希望在某个对象将要被垃圾回收时做一些清理或终结操作，这时候可以使用 <code>FinalizationRegistry</code> 对象。使用需要传入一个回调函数，这个函数将在目标对象被回收之前执行。</p><p>注册和注销对象使用 <code>register()</code> 和 <code>unregister()</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Matt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> finalizationRegistry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FinalizationRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">heldValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Cleaning up obj:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,heldValue)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">finalizationRegistry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;持有值&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//注销</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">finalizationRegistry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unregister</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj)</span></span></code></pre></div><h2 id="weakmap" tabindex="-1">WeakMap <a class="header-anchor" href="#weakmap" aria-label="Permalink to &quot;WeakMap&quot;">​</a></h2><p>ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。<br> WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。</p><p><code>const wm = new WeakMap();</code><br> ==弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出 TypeError。==值的类型没有限制。</p><div class="info custom-block github-alert"><p class="custom-block-title">+ 弱键</p><p>WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;val&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>如上代码，set() 方法添加了一个空对象为键的数据，并没有指向这个对象的其他引用，这意味着，当这行代码执行完成后，这个对象键就会被垃圾回收。</p></div><p>因为 WeakMap 中的键/值对任何时候都可能被销毁，所以==没有迭代其键/值对的能力==。</p><p>使用场景：</p><ol><li>私有变量<br> 弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</li><li>DOM 节点元数据<br> 因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。</li></ol><h2 id="weakset" tabindex="-1">WeakSet <a class="header-anchor" href="#weakset" aria-label="Permalink to &quot;WeakSet&quot;">​</a></h2><p>ECMAScript 6 新增的“弱集合”（WeakSet）是一种新的集合类型。<br> WeakSet 是 Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的<br> 是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。</p><p><code>const ws = new WeakSet();</code></p><p>弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出 TypeError。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({});</span></span></code></pre></div><p>add() 方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当<br> 这行代码执行完成后，这个对象值就会被当作垃圾回收。</p><p>WeakSet 同样的不具有迭代能力。</p><p>WeakSet 可以用于给对象打标签。</p><h2 id="迭代与扩展操作" tabindex="-1">迭代与扩展操作 <a class="header-anchor" href="#迭代与扩展操作" aria-label="Permalink to &quot;迭代与扩展操作&quot;">​</a></h2><p>ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。<br> 有 4 种原生集合类型定义了默认迭代器：</p><ul><li>Array</li><li>所有定型数组</li><li>Map</li><li>Set<br> 这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环。也意味着所有这些类型都兼容扩展操作符（<code>...</code>）。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr1];</span></span></code></pre></div>`,149)]))}const E=s(l,[["render",n]]);export{c as __pageData,E as default};
