import{_ as o,c as S,o as t,ae as c}from"./chunks/framework.CIivgcbp.js";const n=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/05_HTTPS.md","filePath":"计算机基础课程/网络/01 网络原理/05_HTTPS.md"}'),T={name:"计算机基础课程/网络/01 网络原理/05_HTTPS.md"};function r(d,e,a,l,i,s){return t(),S("div",null,e[0]||(e[0]=[c('<h1 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h1><p>HTTPS，全称为 Hypertext Transfer Protocol Secure，是一种通过加密通道传输数据的安全协议。它是 HTTP 协议的安全版本，用于在 Web 浏览器和 Web 服务器之间进行安全的数据传输。HTTPS 在传输过程中使用了 <strong>SSL（Secure Sockets Layer）</strong> 或 <strong>TLS（Transport Layer Security）</strong> 协议来加密数据，确保敏感信息在传输过程中不会被窃取或篡改。</p><blockquote><p>📌<strong>HTTPS = http + TLS/SSL</strong></p></blockquote><h2 id="https-和-http-的区别" tabindex="-1">HTTPS 和 HTTP 的区别 <a class="header-anchor" href="#https-和-http-的区别" aria-label="Permalink to &quot;HTTPS 和 HTTP 的区别&quot;">​</a></h2><ol><li>HTTPS 协议需要到 CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>http 的连接很简单，是无状态的；HTTPS 协议是由 HTTP+SSL 协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比 http 协议安全。</li></ol><h2 id="tls-ssl" tabindex="-1">TLS/SSL <a class="header-anchor" href="#tls-ssl" aria-label="Permalink to &quot;TLS/SSL&quot;">​</a></h2><ul><li>TLS（Transport Layer Security）和 SSL（Secure Sockets Layer）是用于保护网络通信的安全协议。它们都提供了加密和认证机制，用于确保数据传输的机密性和完整性。</li><li>SSL 是最早的安全协议，而 TLS 是在 SSL 的基础上发展起来的。目前广泛使用的版本是 TLS 1.2 和 TLS 1.3。TLS 1.3 是最新的协议版本，在安全性、性能和功能方面有一些改进。</li><li>TLS 和 SSL 主要用于以下两个方面：<br> 1. 加密通信：TLS/SSL 使用加密算法来对数据进行加密，防止第三方截获和窃听通信内容。它可以确保数据在传输过程中的隐私性。<br> 2. 身份认证：TLS/SSL 还提供了身份验证机制，用于确认通信双方的身份，并确保数据只发送到正确的接收方。这可以防止恶意用户冒充其他用户或服务器。</li><li>SSL 是最早的用来做 https，TLS 是 SSL 升级版，提高了安全性 并解决了 SSL 存在的一些安全性问题。</li><li>SSl/TLS 工作原理类似的，在网络模型中可以看作是在<strong>应用层和传输层之间的一个安全层</strong></li></ul><h2 id="如何加密" tabindex="-1">如何加密？ <a class="header-anchor" href="#如何加密" aria-label="Permalink to &quot;如何加密？&quot;">​</a></h2><p>HTTP 本身没有任何保密性，所以 HTTP 传输的数据相当于都是在网上在以明文的方式裸奔。为了解决这个问题，出现了各种加密技术：</p><ul><li><p>对称加密：</p><p>唯一密钥 <code>key1</code> 可用来加密也可用来解密。这样的加密需要双方都拥有密钥 <code>key1</code>。</p><p>常见的算法有 AES 加密、DES 加密。<br> 举例 <code>小明-&gt;小红</code> 发消息，但是他们的消息不想被别人知道，采用了对称加密，于是他们两个协商了一段密钥 <code>key</code>。<br> 小明：<code>密钥（key）+ 明文（你好） AES加密= 密文（？？？？？）</code><br> 小红：<code>密钥（key）+ 密文（？？？？？） AES解密= 你好</code></p></li><li><p>非对称加密<br> 公钥 <code>key3</code> 和私钥 <code>key2</code> 都可用于对应的加密和解密，即可用公钥加密私钥解密，也可用私钥加密公钥解密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布供任何人使用。客户端的明文通过公钥加密后的密文需要用私钥解密。非对称密钥在加密和解密的过程的使用的密钥是不同的密钥，加密和解密是不对称的，所以称之为非对称加密。与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。</p><p>常见算法有 RSA、DSA 加密</p><p>举例 <code>小明-&gt;小红</code> 发消息，这次使用的是非对称加密，生成了公钥和私钥，公钥可以对外公开，私钥必须只能 <code>小红</code> 知道不能泄露。<br> 小明：<code>公钥（key1）+ 明文（你好） RSA加密= 密文（？？？？？）</code><br> 小红：<code>私钥（key2）+ 密文（？？？？？） RSA解密= 你好</code></p></li><li><p>混合加密<br> 服务端先用非对称加密的私钥 <code>key2</code> 加密对称加密的密钥 <code>key1</code> 并传给客户端，客户端用非对称加密的公钥 <code>key3</code> 解密出对称加密的密钥 <code>key1</code>，双方都有了密钥 <code>key1</code>，开始利用 <code>key1</code> 加密通信。缺点：中间人可以自己生成非对称加密公钥替换掉服务端公钥发送给客户端，而此时客户端并无法验证公钥的可信性。</p></li><li><p>SSL<br> 首先需要从证书认证机构申请证书（证书中含有证书签名和服务端公钥 <code>key3</code>）。在客户端发起 HTTP 请求时，服务端将证书发送给客户端。客户端认证证书的真伪，然后解密出服务端公钥 <code>key3</code>，用公钥加密自己生成的对称加密密钥 <code>key1</code> 并传给服务端，最后利用 <code>key1</code> 加密进行通话。至于安全性，由于私钥是机构的，可以避免第三方伪造证书。并且就算得到了服务端公钥，也无法解密出公钥 <code>key3</code> 加密过的对称加密密钥 <code>key1</code>。</p></li></ul>',10)]))}const L=o(T,[["render",r]]);export{n as __pageData,L as default};
