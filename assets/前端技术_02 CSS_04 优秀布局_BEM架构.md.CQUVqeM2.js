import{_ as o,c as a,o as l,ag as t}from"./chunks/framework.-ewJmwvT.js";const h=JSON.parse('{"title":"BEM 架构","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/02 CSS/04 优秀布局/BEM架构.md","filePath":"前端技术/02 CSS/04 优秀布局/BEM架构.md"}'),i={name:"前端技术/02 CSS/04 优秀布局/BEM架构.md"};function r(c,e,d,n,s,m){return l(),a("div",null,e[0]||(e[0]=[t('<h1 id="bem-架构" tabindex="-1">BEM 架构 <a class="header-anchor" href="#bem-架构" aria-label="Permalink to &quot;BEM 架构&quot;">​</a></h1><h2 id="bem-架构-1" tabindex="-1">BEM 架构 <a class="header-anchor" href="#bem-架构-1" aria-label="Permalink to &quot;BEM 架构&quot;">​</a></h2><ul><li>BEM 是一个出色的 CSS 架构，全称 BlockElementModifier 是由 Yandex（俄罗斯最著名的互联网企业）的开发团队提出的前端开发理论。通过 Block、Element、Modifier 来描述页面，通过 <code>_</code> 与 <code>--</code> 连接 ，关键就是为了解决多人协作的命名问题。 <ul><li>B 代表：Black（块）</li><li>E 代表：Element（元素）</li><li>M 代表： Modifier （修饰符）</li></ul></li></ul><h4 id="模块-block" tabindex="-1"><strong>模块 block</strong>（） <a class="header-anchor" href="#模块-block" aria-label="Permalink to &quot;**模块 block**（）&quot;">​</a></h4><p>没有前缀，多个单词用 <code>-</code> 连接，是对一个组件名抽象。</p><p><code>.block {}</code></p><h4 id="元素-element" tabindex="-1"><strong>元素 Element</strong> <a class="header-anchor" href="#元素-element" aria-label="Permalink to &quot;**元素 Element**&quot;">​</a></h4><p>元素在模块之后，可以有多个层级，以 <code>__</code>（双下划线） 连接。element 也不是死板的，是根据具体的需求演变的，中间也可以使用 <code>-</code> 来演变。</p><p><code>.block__element {}</code></p><h4 id="修饰-modifier" tabindex="-1"><strong>修饰 Modifier</strong> <a class="header-anchor" href="#修饰-modifier" aria-label="Permalink to &quot;**修饰 Modifier**&quot;">​</a></h4><p>某元素、或者某模块特别的状态，必须有一个状态名和状态值，使用 <code>--</code> 链接，也可根据具体需求而定。</p><p><code>.block—modifier {}</code></p><p>主要针对的是 Block 本身,是对于 Block 做修饰。例如有：</p><ul><li>颜色</li><li>大小</li><li>用途</li></ul>',14)]))}const p=o(i,[["render",r]]);export{h as __pageData,p as default};
