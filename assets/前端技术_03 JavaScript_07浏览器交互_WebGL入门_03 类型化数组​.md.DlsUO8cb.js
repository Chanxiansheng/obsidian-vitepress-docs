import{_ as i,c as a,o as l,ag as n}from"./chunks/framework.-ewJmwvT.js";const y=JSON.parse('{"title":"03 类型化数组​","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/07浏览器交互/WebGL入门/03 类型化数组​.md","filePath":"前端技术/03 JavaScript/07浏览器交互/WebGL入门/03 类型化数组​.md"}'),h={name:"前端技术/03 JavaScript/07浏览器交互/WebGL入门/03 类型化数组​.md"};function p(t,s,k,e,r,E){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="_03-类型化数组​" tabindex="-1">03 类型化数组​ <a class="header-anchor" href="#_03-类型化数组​" aria-label="Permalink to &quot;03 类型化数组​&quot;">​</a></h1><p>JavaScript 的类型化数组是一种用于处理和操作二进制数据的对象，类型化数组在处理 WebGL 等需要高性能和大数据量操作的应用中非常有用。​</p><p>类型化数组和普通的 JavaScript 数组不同，类型化数组的每一个元素都是同一类型的二进制数据，这种类型在创建数组时就已经确定了。​</p><p><strong>作用</strong>：常用在处理图像数据、音频数据、视频数据这些方向。对应的 API 有：WebGL、Canvas API、WebRTC、File API。</p><h2 id="和普通数组的区别​" tabindex="-1">和普通数组的区别​ <a class="header-anchor" href="#和普通数组的区别​" aria-label="Permalink to &quot;和普通数组的区别​&quot;">​</a></h2><p>内存管理方面​</p><ul><li>类型化数组：类型化数组直接在一个连续的内存块上操作。这意味着所有的数据都紧密地存储在一个固定大小的缓冲区中，数据访问和修改非常高效，因为它们不需要像普通数组那样进行额外的内存引用或分配。​</li><li>普通数组：普通数组是动态的，可以容纳不同类型的数据。这使得它们非常灵活，但由于需要动态调整大小和存储多种类型的数据，它们的内存管理和访问速度比类型化数组要慢。​</li></ul><p>数据类型方面​</p><ul><li>类型化数组：类型化数组是强类型的，数组中的每个元素都必须是特定类型的值（如 Int8、Uint8、Float32 等）。这种类型的严格性确保了数据的一致性和高效的内存使用。​</li><li>普通数组：普通数组是弱类型的，可以包含任意类型的值（如数字、字符串、对象等）。这种灵活性虽然方便，但会导致在进行大量数据处理时效率较低。​</li></ul><p>操作方法方面​</p><ul><li>类型化数组：类型化数组支持一组专门的方法，用于在二进制数据块上进行高效操作。它们不继承自 Array.prototype，因此不具备一些普通数组的方法（如 push、pop、splice 等）。​</li><li>普通数组：普通数组继承自 Array.prototype，拥有丰富的数组操作方法，可以灵活地添加、删除、修改和遍历数组元素。​</li></ul><h2 id="类型化数组有哪些​" tabindex="-1">类型化数组有哪些​ <a class="header-anchor" href="#类型化数组有哪些​" aria-label="Permalink to &quot;类型化数组有哪些​&quot;">​</a></h2><ul><li><p>Int8Array：8 位有符号整数，每个元素占 1 字节​</p></li><li><p>Uint8Array：8 位无符号整数，每个元素占 1 字节。 ​</p></li><li><p>Uint8ClampedArray：8 位无符号整数（固定值，溢出时值被截断），每个元素占 1 字节。​</p></li><li><p>Int16Array：16 位有符号整数，每个元素占 2 字节。​</p></li><li><p>Uint16Array：16 位无符号整数，每个元素占 2 字节。​</p></li><li><p>Int32Array：32 位有符号整数，每个元素占 4 字节。​</p></li><li><p>Uint32Array：32 位无符号整数，每个元素占 4 字节。​</p></li><li><p>Float32Array：32 位 IEEE 754 浮点数，每个元素占 4 字节。​</p></li><li><p>Float64Array：64 位 IEEE 754 浮点数，每个元素占 8 字节。</p></li></ul><blockquote><p>有符号整数和无符号整数是在计算机中存储整数数据时使用的两种表示方式，它们的区别在于如何解释存储在内存种的二进制数据的最高位。(通俗讲就是是否可为负数)​</p><p>==32 位有符号整数==</p><ul><li>最高位可以为 0 或者 1，为 0 则表示非负数，为 1 则表示负数​</li><li>范围：-2^31 到 2^31 - 1​</li><li>示例：例如 01111111 11111111 11111111 11111111 表示的是最大的正数，而 10000000 00000000 00000000 00000000 表示的是最小的负数。​</li></ul><p>==32 位无符号整数==</p><ul><li>始终表示一个非负整数​</li><li>范围：0 到 2^32 - 1​</li><li>示例：例如 11111111 11111111 11111111 11111111 表示的是最大的无符号整数</li></ul></blockquote><h2 id="创建和使用类型化数组​" tabindex="-1">创建和使用类型化数组​ <a class="header-anchor" href="#创建和使用类型化数组​" aria-label="Permalink to &quot;创建和使用类型化数组​&quot;">​</a></h2><p>类型化数组每一种都有对应的构造函数，要创建类型化数组实例就需要使用 new 操作符实例化构造函数​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包含10个32位整数的类型化数组​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int32Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 向类型化数组中填充数据​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	intArray[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 计算所有元素的总和​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> intArray[i];​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;类型化数组中的元素:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, intArray); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 类型化数组中的元素: Int32Array(10) [ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18 ]​</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;总和:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sum); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 总和: 90</span></span></code></pre></div><p>这些类型化数组在 WebGL 得到了广泛的作用，使用也是非常频繁的。比如在定义几何图形的顶点，可以使用类型化数组定义，如下:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vertices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Float32Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个顶点的坐标 (x=0.0, y=1.0)​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二个顶点的坐标 (x=-1.0, y=-1.0)​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 第三个顶点的坐标 (x=1.0, y=-1.0)​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><p>内部项两两一组作为一个点的 x 坐标和 y 坐标，上面代码是定义了一个三角形的三个顶点的坐标</p>`,20)]))}const g=i(h,[["render",p]]);export{y as __pageData,g as default};
