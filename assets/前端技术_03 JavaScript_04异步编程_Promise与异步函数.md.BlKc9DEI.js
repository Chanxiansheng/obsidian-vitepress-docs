import{_ as i,c as a,o as l,ag as e}from"./chunks/framework.-ewJmwvT.js";const E=JSON.parse('{"title":"Promise 与异步函数","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/04异步编程/Promise与异步函数.md","filePath":"前端技术/03 JavaScript/04异步编程/Promise与异步函数.md"}'),n={name:"前端技术/03 JavaScript/04异步编程/Promise与异步函数.md"};function h(t,s,p,k,r,o){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="promise-与异步函数" tabindex="-1">Promise 与异步函数 <a class="header-anchor" href="#promise-与异步函数" aria-label="Permalink to &quot;Promise 与异步函数&quot;">​</a></h1><h2 id="异步编程" tabindex="-1">异步编程 <a class="header-anchor" href="#异步编程" aria-label="Permalink to &quot;异步编程&quot;">​</a></h2><div class="info custom-block github-alert"><p class="custom-block-title">+ 理解 Promise</p><p>==Promise 中定义的异步回调只是对事件循环抽象的一种应用，与网络请求、定时器等需要借助底层静候触发的回调任务有着本质区别==</p><h3 id="promise-中的异步回调" tabindex="-1">Promise 中的异步回调 <a class="header-anchor" href="#promise-中的异步回调" aria-label="Permalink to &quot;Promise 中的异步回调&quot;">​</a></h3><ul><li><p><strong>抽象层面上的异步</strong>：<code>Promise</code> 提供了一种高层次的抽象，使得我们可以以一种更加直观和结构化的方式来处理异步操作。它通过 <code>.then()</code> 和 <code>.catch()</code> 方法注册的回调函数实际上是在微任务队列中排队等待执行的。这意味着这些回调函数会在当前的宏任务完成后，但在下一个宏任务开始之前被执行。</p></li><li><p><strong>状态驱动</strong>：<code>Promise</code> 的状态（pending、fulfilled 或 rejected）是在内部同步管理的，并且一旦从 pending 变为其他两种状态之一，就不会再改变。这种状态的变化直接决定了何时调用相应的回调函数。因此，虽然 <code>Promise</code> 可以用来封装任何类型的异步操作，但其核心在于如何管理和响应状态变化，而不是具体的操作类型。</p></li></ul><h3 id="网络请求、定时器等底层触发的回调" tabindex="-1">网络请求、定时器等底层触发的回调 <a class="header-anchor" href="#网络请求、定时器等底层触发的回调" aria-label="Permalink to &quot;网络请求、定时器等底层触发的回调&quot;">​</a></h3><ul><li><strong>事件驱动</strong>：对于像网络请求（如 <code>fetch</code> 或 <code>XMLHttpRequest</code>）、定时器（<code>setTimeout</code>、<code>setInterval</code>）这样的异步任务，它们通常依赖于外部事件的发生来触发回调。例如，一个 HTTP 请求的成功完成会触发一个事件，该事件会被添加到宏任务队列中，然后在适当的时候由 JavaScript 引擎执行相应的回调函数</li><li><strong>底层实现</strong>：这些操作往往涉及到操作系统级别的 API 或者浏览器提供的特定接口，它们能够监听 I/O 完成、计时器到期等事件，并在事件发生时通知 JavaScript 运行时环境。因此，这类异步操作的回调触发机制与 <code>Promise</code> 的纯软件层面的状态变化机制有着根本的不同。</li></ul><h3 id="宏任务微任务" tabindex="-1">宏任务微任务？ <a class="header-anchor" href="#宏任务微任务" aria-label="Permalink to &quot;宏任务微任务？&quot;">​</a></h3><p>==宏任务与微任务只是事件循环的一种表征结果，真正理解异步机制需要深入事件循环的运作原理和不同异步任务的实现机理。==</p><ol><li><strong>调度维度</strong>：</li></ol><ul><li>==宏任务是<strong>跨线程协作</strong>的结果，需要<strong>事件循环的阶段调度</strong>==</li><li>==微任务是<strong>主线程自管理</strong>的即时调度==</li></ul><ol><li><strong>性能本质</strong>：</li></ol><ul><li>微任务的延迟来源于<strong>调用栈清空速度</strong></li><li>宏任务的延迟来源于<strong>系统调度精度</strong>和<strong>队列竞争</strong></li></ul><ol><li><strong>设计哲学</strong>：</li></ol><ul><li>宏任务：处理<strong>需要与外部系统协调</strong>的异步操作</li><li>微任务：实现<strong>原子操作后的即时响应</strong></li></ul></div><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。</p><p>异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。</p><p>在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。随着代码越来越复杂，回调策略是不具有扩展性的，称为“回调地狱”。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><p>Promise 描述的都是一种异步程序执行的机制，可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数。</p><p><code>let p = new Promise(() =&gt; {});</code></p><p>因为如果不提供执行器函数，就会抛出 SyntaxError。</p><ol><li><p>期约状态机<br> Promise 是一个有状态的对象，可能处于如下 3 种状态之一：</p><ul><li>待定（pending）</li><li>兑现（fulfilled，有时候也称为“解决”，resolved）</li><li>拒绝（rejected）</li></ul><p>待定（pending）是 Promise 的最初始状态。在待定状态下，Promise 可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。<br> ==无论落定为哪种状态都是不可逆的。==只要从待定转换为兑现或拒绝，Promise 的状态就不再改变。</p></li><li><p>解决值、拒绝理由<br> 期约主要有两大用途：</p><ul><li>一是抽象地表示一个异步操作，Promise 的状态代表期约是否完成。</li><li>二是封装的异步操作会实际生成某个值，而程序期待 Promise 状态改变时可以访问这个值。<br> 为了支持这两种用例，每个 Promise 只要状态切换为兑现，就会有一个私有的内部<strong>值</strong>（value）。类似地，每个 Promise 只要状态切换为拒绝，就会有一个私有的<strong>内部理由</strong>（reason）。</li></ul></li><li><p>通过执行函数控制期约状态<br> 由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。<br> ==执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。==<br> 其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve() 和 reject()。<br> ==调用 resolve() 会把状态切换为兑现，调用 reject() 会把状态切换为拒绝。==另外，调用 reject() 也会抛出错误。</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(condition){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h3><h4 id="promise-resolve" tabindex="-1">Promise.resolve() <a class="header-anchor" href="#promise-resolve" aria-label="Permalink to &quot;Promise.resolve()&quot;">​</a></h4><p>通过调用 <code>Promise.resolve()</code> 静态方法，可以实例化一个解决的期约</p><blockquote><p>[!example]+ Promise.resolve</p><p><code>Promise.resolve(value)</code> 方法返回一个以给定值解析（fulfilled）的 Promise 对象。</p><ul><li>value: 要解析的值。可以是任何类型，包括 Promise 实例或其他对象。</li></ul><p>返回值: 一个新的 Promise 对象，该对象会被解析为提供的值。</p><p>注意点：</p><ul><li>如果传入的 value 是一个 Promise 实例，则直接返回这个实例。<strong>（幂等性）</strong></li><li>如果传入的是一个非 Promise 的 thenable 对象，<code>Promise.resolve</code> 会将它转换成一个 Promise 并立即执行。</li></ul></blockquote><h4 id="promise-reject" tabindex="-1">Promise.reject() <a class="header-anchor" href="#promise-reject" aria-label="Permalink to &quot;Promise.reject()&quot;">​</a></h4><blockquote><p>[!example]+ Promise.reject</p><p><code>Promise.reject(reason)</code> 方法返回一个以给定原因拒绝（rejected）的 <code>Promise</code> 对象。</p><ul><li>reason: 拒绝的原因。通常是一个错误对象，但可以是任何类型。</li></ul><p>返回值: 一个新的 Promise 对象，该对象会被拒绝并携带提供的拒绝原因。</p><p>注意点：</p><ul><li>Promise.reject() 并没有照搬 Promise.resolve() 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由</li></ul></blockquote><p>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。</p><h3 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h3><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p><h4 id="thenable-接口" tabindex="-1">Thenable 接口 <a class="header-anchor" href="#thenable-接口" aria-label="Permalink to &quot;Thenable 接口&quot;">​</a></h4><p>在 ECMAScript 暴露的异步结构中，任何对象都有一个 then() 方法。这个方法被认为实现了 Thenable 接口。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThenable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>ECMAScript 的 Promise 类型实现了 Thenable 接口。</p><h4 id="promise-prototype-then" tabindex="-1">Promise.prototype.then() <a class="header-anchor" href="#promise-prototype-then" aria-label="Permalink to &quot;Promise.prototype.then()&quot;">​</a></h4><blockquote><p>[!example]+ Promise.prototype.then</p><p><code>promise.then(onFulfilled, onRejected)</code> 方法用于注册在 Promise 状态变为 fulfilled 或 rejected 时应调用的处理函数，并返回一个新的 Promise 对象。</p><ul><li>onFulfilled（可选）: 当 Promise 被 fulfilled 时调用的函数。该函数接收 Promise 的结果作为其唯一的参数。</li><li>onRejected（可选）: 当 Promise 被 rejected 时调用的函数。该函数接收 Promise 的拒绝原因作为其唯一的参数。</li></ul><p>返回值:<br> 一个新的 Promise 对象，其行为取决于 <code>onFulfilled</code> 或 <code>onRejected</code> 函数的返回值：</p><ul><li>==如果 onFulfilled 或 onRejected 返回一个值或没有返回值（undefined），都会被 Promise.resolve() 包装。==</li><li>如果它们抛出异常，新的 Promise 将被 rejected 并携带该异常。</li><li>如果返回的是另一个 Promise，则新 Promise 将采用该 Promise 的状态</li></ul><p>注意点：</p><ul><li>传给 then() 的任何非函数类型的参数都会被静默忽略。</li><li>可以链式调用多个 then 方法来处理一系列异步任务，每个 then 方法都可以返回一个新的 Promise，从而实现复杂的异步流程控制。</li><li>==then 方法中的回调函数会在当前事件循环结束时异步执行==，这意味着即使 Promise 已经被 resolved 或 rejected，回调也会在下一个事件循环中执行。</li></ul></blockquote><h4 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch() <a class="header-anchor" href="#promise-prototype-catch" aria-label="Permalink to &quot;Promise.prototype.catch()&quot;">​</a></h4><blockquote><p>[!example]+ Promise.prototype.catch</p><p><code>promise.catch(onRejected)</code> 方法用于注册一个处理函数，当 Promise 被拒绝（rejected）时调用该函数。它是 <code>Promise.prototype.then(null, onRejected)</code> 的语法糖。</p><ul><li>onRejected: 当 Promise 被 rejected 时调用的函数。该函数接收 Promise 的拒绝原因作为其唯一的参数。</li></ul><p>返回值: 一个新的 Promise 对象，其行为取决于 <code>onRejected</code> 函数的返回值：</p><ul><li>如果 <code>onRejected</code> 返回一个值或没有返回值（undefined），新的 Promise 将被 fulfilled。</li><li>如果它抛出异常，新的 Promise 将被 rejected 并携带该异常。</li><li>如果返回的是另一个 Promise，则新 Promise 将采用该 Promise 的状态（fulfilled 或 rejected）。</li></ul></blockquote><h4 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally() <a class="header-anchor" href="#promise-prototype-finally" aria-label="Permalink to &quot;Promise.prototype.finally()&quot;">​</a></h4><blockquote><p>[!example]+ Promise.prototype.finally</p><p><code>promise.finally(onFinally)</code> 方法用于指定一个无论 Promise 是被 fulfilled 还是 rejected 都会执行的处理函数。这提供了一种机制来执行清理操作，而无需关心 Promise 的最终状态。</p><ul><li>onFinally: 一个不接受任何参数的函数，在 Promise 完成（无论是成功还是失败）后执行。该函数不应返回值，如果它返回了一个 Promise，则后续链中的 Promise 将等待这个 Promise 完成。</li></ul><p>返回值: 一个新的 Promise 对象，其结果与原始 Promise 相同。</p><p>注意点：</p><ul><li><code>finally</code> 方法通常用于执行一些清理工作，例如关闭数据库连接、取消网络请求或释放资源等，不论操作是否成功。</li></ul></blockquote><h3 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h3><h4 id="非重入" tabindex="-1">非重入 <a class="header-anchor" href="#非重入" aria-label="Permalink to &quot;非重入&quot;">​</a></h4><p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被<strong>排期</strong>，而非立即执行。<br> ==跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。==这个特性由 JavaScript 运行时保证，被称为“<strong>非重入</strong>”（non-reentrancy）特性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直觉上，这个处理程序会等期约一解决就执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;onResolved handler&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;then() returns&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实际的输出：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// then() returns</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// onResolved handler</span></span></code></pre></div><h4 id="邻近顺序执行" tabindex="-1">邻近顺序执行 <a class="header-anchor" href="#邻近顺序执行" aria-label="Permalink to &quot;邻近顺序执行&quot;">​</a></h4><p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。</p><h4 id="传递值" tabindex="-1">传递值 <a class="header-anchor" href="#传递值" aria-label="Permalink to &quot;传递值&quot;">​</a></h4><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reason)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar</span></span></code></pre></div><h4 id="拒绝错误处理" tabindex="-1">拒绝错误处理 <a class="header-anchor" href="#拒绝错误处理" aria-label="Permalink to &quot;拒绝错误处理&quot;">​</a></h4><p>拒绝期约类似于 throw() 表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); });</span></span></code></pre></div><p>在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令。异步错误只能通过异步的 onRejected 处理程序捕获。</p><h4 id="期约连锁" tabindex="-1">期约连锁 <a class="header-anchor" href="#期约连锁" aria-label="Permalink to &quot;期约连锁&quot;">​</a></h4><p>因为每个期约实例的方法（then()、catch() 和 finally()）都会返回一个新的 Promise 对象，而这个新期约又有自己的实例方法，因此，可以把 Promise 逐个地串联起来，这样连缀方法调用就可以构成所谓的“<strong>期约连锁</strong>”。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;second&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;third&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fourth&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h4 id="期约图" tabindex="-1">期约图 <a class="header-anchor" href="#期约图" aria-label="Permalink to &quot;期约图&quot;">​</a></h4><p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建<strong>有向非循环图</strong>的结构。<br> 期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。</p><h4 id="promise-all" tabindex="-1">Promise.all <a class="header-anchor" href="#promise-all" aria-label="Permalink to &quot;Promise.all&quot;">​</a></h4><blockquote><p>[!example]+ Promise.all</p><p><code>Promise.all(iterable)</code> 方法返回一个 Promise，该 Promise 在给定的 iterable 参数（通常是数组）中的所有 Promise 都被 fulfilled 后才会被 fulfilled。如果其中任何一个 Promise 被 rejected，则立即以该 Promise 的拒绝原因作为新 Promise 的拒绝原因。</p><ul><li>iterable: 一个可迭代对象（如数组），包含多个 Promise 实例或其他值。</li></ul><p>返回值: 一个新的 Promise 对象，==在所有输入的 Promise 都成功完成时被 fulfilled，并将每个 Promise 结果作为数组传递给回调函数；如果有任何 Promise 被 rejected，则新的 Promise 立即被 rejected。==</p><p>注意点：</p><ul><li>所有 Promise 都成功完成时，结果数组中的值与输入的 Promise 数组顺序一致，即使某些 Promise 完成得更晚。</li><li>如果传入的不是 Promise 的值，则被视为已 resolved 的 Promise。</li><li>适用于需要等待多个异步操作全部完成的场景。</li></ul></blockquote><h4 id="promise-allsettled" tabindex="-1">Promise.allSettled <a class="header-anchor" href="#promise-allsettled" aria-label="Permalink to &quot;Promise.allSettled&quot;">​</a></h4><blockquote><p>[!example]+ Promise.allSettled</p><p><code>Promise.allSettled(iterable)</code> 方法返回一个 Promise，该 Promise 在给定的 iterable 参数（通常是数组）中的所有 Promise 都已 settled（无论是 fulfilled 还是 rejected）后才会被 fulfilled。</p><ul><li>iterable: 一个可迭代对象（如数组），包含多个 Promise 实例或其他值。</li></ul><p>返回值: 一个新的 Promise 对象，在所有输入的 Promise 都已 settled 后被 fulfilled。这个 Promise 被 fulfilled 时会传递一个数组，其中每个元素描述了相应的 Promise 的结果状态，包括 status（字符串 &quot;fulfilled&quot; 或 &quot;rejected&quot;）和对应的值或原因。</p><p>注意点：</p><ul><li>与 <code>Promise.all</code> 不同的是，它不会在遇到 rejection 时短路，而是等待所有输入的 Promise 完成，并提供每个 Promise 的结果状态。</li><li>适用于需要知道一组异步操作的所有结果（无论是成功还是失败）的场景。</li></ul></blockquote><h4 id="promise-race" tabindex="-1">Promise.race <a class="header-anchor" href="#promise-race" aria-label="Permalink to &quot;Promise.race&quot;">​</a></h4><blockquote><p>[!example]+ Promise.race</p><p><code>Promise.race(iterable)</code> 方法返回一个 Promise，该 Promise 在给定的 iterable 参数（通常是数组）中的任意一个 Promise 被 settled（无论是 fulfilled 还是 rejected）后立即 settled，并采用最先 settled 的 Promise 的状态。</p><ul><li>iterable: 一个可迭代对象（如数组），包含多个 Promise 实例或其他值。</li></ul><p>返回值: 一个新的 Promise 对象，它会在第一个输入的 Promise settled 后立即 settled，并带有该 Promise 的结果或错误。</p><p>注意点：</p><ul><li>适用于实现超时机制或竞争条件等场景，其中一个异步操作的结果决定了整个流程的结果。</li></ul></blockquote><h4 id="promise-any" tabindex="-1">Promise.any <a class="header-anchor" href="#promise-any" aria-label="Permalink to &quot;Promise.any&quot;">​</a></h4><blockquote><p>[!example]+ Promise.any</p><p><code>Promise.any(iterable)</code> 方法接收一个可迭代对象（如数组），包含多个 Promise 实例或其他值，并返回一个新的 Promise。</p><ul><li>iterable: 一个可迭代对象（如数组），包含多个 <code>Promise</code> 实例或其他值。</li></ul><p>返回值: 一个新的 Promise 对象，在任何一个输入的 Promise 被 fulfilled 后立即被 fulfilled，并带有最先 fulfilled 的 Promise 的结果；如果所有的 Promise 都被 rejected，则新的 Promise 会以 <code>AggregateError</code> 错误被 rejected。</p><p>注意点：</p><ul><li>如果所有提供的 Promise 都被 rejected，则返回的 Promise 会以 <code>AggregateError</code> 形式的错误被 rejected，该错误包含了所有拒绝原因的列表。</li><li>这个方法适用于你想要获取最快成功的结果而不在乎其他尝试的情况，或者当你希望至少有一个异步操作能够成功完成。</li></ul></blockquote><h4 id="微任务队列" tabindex="-1">微任务队列 <a class="header-anchor" href="#微任务队列" aria-label="Permalink to &quot;微任务队列&quot;">​</a></h4><p>当 Promise 落定之后，所有等待处理其结果的函数都会被添加到一个<strong>微任务队列</strong>。这个微任务队列用于存储需要在当前同步代码运行完成后执行的所有函数。</p><h3 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h3><h4 id="期约取消" tabindex="-1">期约取消 <a class="header-anchor" href="#期约取消" aria-label="Permalink to &quot;期约取消&quot;">​</a></h4><p>ES6 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。<br> 可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。这可以用到 Kevin Smith 提到的“取消令牌”（cancel token）。<br> 生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CancelToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cancelFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.promise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		  cancelFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个类包装了一个期约，把解决方法暴露给了 cancelFn 参数。这样，外部代码就可以向构造函数中传入一个函数，从而控制什么情况下可以取消期约。</p><h4 id="进度追踪" tabindex="-1">进度追踪 <a class="header-anchor" href="#进度追踪" aria-label="Permalink to &quot;进度追踪&quot;">​</a></h4><p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期约的执行进度会很有用。ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。<br> 实现方式是扩展 Promise 类，为它添加 notify() 方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TrackablePromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> notifyHandlers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, reject, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        notifyHandlers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(status));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.notifyHandlers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> notifyHandlers;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  notify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">notifyHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.notifyHandlers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(notifyHandler);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="异步函数" tabindex="-1">异步函数 <a class="header-anchor" href="#异步函数" aria-label="Permalink to &quot;异步函数&quot;">​</a></h2><p>异步函数，也称为“<code>async/await</code>”（语法关键字）<br> 这个特性从行为和语法上都增强了 JavaScript，让以同步方式写的代码能够异步执行。</p><h3 id="async" tabindex="-1">async <a class="header-anchor" href="#async" aria-label="Permalink to &quot;async&quot;">​</a></h3><p>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。<br> 使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。</p><p>异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 <code>Promise.resolve()</code> 包装成一个期约对象。==异步函数始终返回期约对象==。</p><p>==异步函数的返回值期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以==。<br> 如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then() 的处理程序“解包”。<br> 如果不是，则返回值就被当作已经解决的期约。</p><h3 id="await" tabindex="-1">await <a class="header-anchor" href="#await" aria-label="Permalink to &quot;await&quot;">​</a></h3><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await<br> 关键字可以暂停异步函数代码的执行，等待期约解决。</p><p>==await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。==这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p><p>==await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。==如<br> 果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作<br> 已经解决的期约。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="停止和恢复执行" tabindex="-1">停止和恢复执行 <a class="header-anchor" href="#停止和恢复执行" aria-label="Permalink to &quot;停止和恢复执行&quot;">​</a></h3><p>要完全理解 await 关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript 运行时在碰到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</p><p>==因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。==</p><p>如果 await 后面是一个 Promise，则问题会稍微复杂一些。此时，为了执行异步函数，==实际上会有两个任务被添加到消息队列并被异步求值。==</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//实际有两个异步任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 7</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 9</span></span></code></pre></div><h3 id="异步函数策略" tabindex="-1">异步函数策略 <a class="header-anchor" href="#异步函数策略" aria-label="Permalink to &quot;异步函数策略&quot;">​</a></h3><h4 id="实现-sleep" tabindex="-1">实现 sleep() <a class="header-anchor" href="#实现-sleep" aria-label="Permalink to &quot;实现 sleep()&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, delay));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="利用平行执行" tabindex="-1">利用平行执行 <a class="header-anchor" href="#利用平行执行" aria-label="Permalink to &quot;利用平行执行&quot;">​</a></h4><p>如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> randomDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p0;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p3;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p4;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(console.log, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}ms elapsed\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="串行执行期约" tabindex="-1">串行执行期约 <a class="header-anchor" href="#串行执行期约" aria-label="Permalink to &quot;串行执行期约&quot;">​</a></h4><p>串行执行期约并把值传给后续的期约。类似<strong>异步传染性</strong></p>`,91)]))}const g=i(n,[["render",h]]);export{E as __pageData,g as default};
