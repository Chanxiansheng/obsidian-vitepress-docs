import{_ as i,c as a,o as t,ae as l}from"./chunks/framework.CIivgcbp.js";const S=JSON.parse('{"title":"CSS 语义化与原子化","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/02 CSS/02 CSS进阶/高级机制/CSS 语义化与原子化.md","filePath":"前端技术/02 CSS/02 CSS进阶/高级机制/CSS 语义化与原子化.md"}'),n={name:"前端技术/02 CSS/02 CSS进阶/高级机制/CSS 语义化与原子化.md"};function p(h,s,e,k,r,o){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="css-语义化与原子化" tabindex="-1">CSS 语义化与原子化 <a class="header-anchor" href="#css-语义化与原子化" aria-label="Permalink to &quot;CSS 语义化与原子化&quot;">​</a></h1><h2 id="语义化" tabindex="-1">语义化 <a class="header-anchor" href="#语义化" aria-label="Permalink to &quot;语义化&quot;">​</a></h2><blockquote><p><strong>CSS 语义化</strong><br> Semantic CSS，指在 html 或 jsx 结构中添加赋有语义化的 class 类名，随后在 css 中写入对应类的样式的一种行为规范。</p></blockquote><p>但这样一来，在很多场景下也面临着许多痛点，比如：</p><ul><li><p><strong>取名痛苦：</strong> 在给标签添加 class，甚至添加一个小小的样式时，我们都得绞尽脑汁想出一个类名，既要求有语义化、符合代码规范，还要和与它作用相似的标签类名有区分；</p></li><li><p><strong>难以复用：</strong> 每个类中往往会有很多个样式规则，在结构的语义、样式完全相同时才能做到真正的复用，若存在一点差异，就难以实现样式复用；</p></li><li><p><strong>样式污染：</strong> 针对样式污染，社区上已经具备了相当多成熟的方案，主要分为了两大类：</p><ul><li><p>CSS Modules<br> 利用了计算 Hash 值的方式将你书写的 CSS 类名更改成全局唯一的值，虽然有效的解决了样式污染问题，但是需要使用全局样式时，需要额外的定义 <code>:global</code> 的书写方式，以及每个模块都需要单独的引入 CSS 文件。</p></li><li><p>CSS In JS<br> 开辟了一条新的道路，利用 JS 的模块化能力、解决样式污染问题，这样的优势非常明显，CSS 代码书写起来非常灵活，可以有效的利用 JS 的逻辑，比如函数和变量等，但劣势也同样非常明显，CSS in JS 需要在运行时层面上去动态计算每个组件的样式 hash，以及动态插入到 html 文档中，最终造成性能上的损失。</p></li></ul></li><li><p><strong>迁移困难：</strong> 如果将 html 或 jsx 结构做迁移，我们还要将相应 CSS 同时迁移，即使这样，迁移后的样式也可能会根据上下文环境变得错乱。</p></li></ul><h2 id="原子化" tabindex="-1">原子化 <a class="header-anchor" href="#原子化" aria-label="Permalink to &quot;原子化&quot;">​</a></h2><blockquote><p><strong>CSS 原子化</strong><br> Atomic/Utility-First CSS 与 Semantic CSS 相对，Utility-First CSS（功能类优先 css）不像 Semantic CSS（语义化 css）那样将组件样式放在一个类中，而是为我们提供一个由不同功能类组成的工具箱，我们可以将它们混合在一起应用在 html 元素上。对于 Atomic CSS（原子 css）来说，在物理世界中， 原子构成一般物质的最小单位，而在 CSS 世界中，则是一个类中只有唯一的 CSS 规则。</p></blockquote><p>Tailwind CSS 和 UnoCSS 都是 CSS 原子化规范的代表框架。</p><p>听起来厉害，但实现的最终方式很简单，核心就是预置大量的 class 样式，尽量将这些 class 样式简单化、单一化，在开发过程中，可以直接在 DOM 中写预置好的 class 名快速实现样式，而不需要每次写简单枯燥大量的 css 样式，如下代码所示：</p><ol><li><p>先预置一组 class 列表</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.m-10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">margin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.p-5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.text-red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> // ....</span></span></code></pre></div></li><li><p>编码时在 dom 中直接写 class 名，快速实现样式</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;m-10 p-5 text-red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  测试dom</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ol><p>而预置的 class 列表中的样式，有着一定的规律，开发者可以通过学习快速掌握，利用多个 class 在 dom 中的<strong>组合</strong>快速实现效果。</p>`,11)]))}const c=i(n,[["render",p]]);export{S as __pageData,c as default};
