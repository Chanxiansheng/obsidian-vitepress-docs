import{_ as s,c as a,o as t,ag as h}from"./chunks/framework.-ewJmwvT.js";const c=JSON.parse('{"title":"this 指向及其方法","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/03对象与函数/this指向及其方法.md","filePath":"前端技术/03 JavaScript/03对象与函数/this指向及其方法.md"}'),n={name:"前端技术/03 JavaScript/03对象与函数/this指向及其方法.md"};function l(p,i,e,k,d,r){return t(),a("div",null,i[0]||(i[0]=[h(`<h1 id="this-指向及其方法" tabindex="-1">this 指向及其方法 <a class="header-anchor" href="#this-指向及其方法" aria-label="Permalink to &quot;this 指向及其方法&quot;">​</a></h1><p><strong>this 是在执行上下文创建时确定的一个在执行过程中不可更改的变量。</strong></p><h2 id="一、this-指向问题" tabindex="-1">一、this 指向问题 <a class="header-anchor" href="#一、this-指向问题" aria-label="Permalink to &quot;一、this 指向问题&quot;">​</a></h2><p>es5 中，<strong>this 永远指向最后调用它的那个对象</strong>。<br> 非严格模式时：this 指向 window<br> 严格模式时：this 指向 undefined<br> es6 中，顶层的 this 指向 undefined，因此不应该在顶层代码中使用 this。</p><h3 id="数种函数调用时的-this-指向总结表" tabindex="-1">数种函数调用时的 this 指向总结表 <a class="header-anchor" href="#数种函数调用时的-this-指向总结表" aria-label="Permalink to &quot;数种函数调用时的 this 指向总结表&quot;">​</a></h3><table tabindex="0"><thead><tr><th>函数调用模式</th><th>this 指向</th></tr></thead><tbody><tr><td>DOM 事件回调函数 -- 箭头函数</td><td>Window</td></tr><tr><td>字面量对象中的函数</td><td>该对象</td></tr><tr><td>全局环境下的普通函数</td><td>Window（严格 undefined）</td></tr><tr><td>Class 对象中的函数 -- 静态方法</td><td>对象原型</td></tr><tr><td>DOM 事件回调函数 -- 普通函数</td><td>DOM 元素</td></tr><tr><td>Class 对象中的函数 -- 实例方法</td><td>实例对象</td></tr></tbody></table><h2 id="二、改变-this-指向的方法" tabindex="-1">二、改变 this 指向的方法 <a class="header-anchor" href="#二、改变-this-指向的方法" aria-label="Permalink to &quot;二、改变 this 指向的方法&quot;">​</a></h2><ol><li>箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li>new 实例化一个对象</li></ol><h3 id="_1-箭头函数" tabindex="-1">1. 箭头函数 <a class="header-anchor" href="#_1-箭头函数" aria-label="Permalink to &quot;1. 箭头函数&quot;">​</a></h3><p><strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong></p><p>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p><h3 id="_2-在函数内部使用-this-this" tabindex="-1">2. 在函数内部使用 <code>_this = this</code> <a class="header-anchor" href="#_2-在函数内部使用-this-this" aria-label="Permalink to &quot;2. 在函数内部使用 \`_this = this\`&quot;">​</a></h3><p>先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。</p><h3 id="_3-使用-apply、call、bind" tabindex="-1">3. 使用 apply、call、bind <a class="header-anchor" href="#_3-使用-apply、call、bind" aria-label="Permalink to &quot;3. 使用 apply、call、bind&quot;">​</a></h3><p>它们均是 Function 原型链上的实例方法</p><h4 id="apply" tabindex="-1">apply <a class="header-anchor" href="#apply" aria-label="Permalink to &quot;apply&quot;">​</a></h4><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数</p><p><code>funtion.apply(thisArg, [argsArray])</code></p><p><code>thisArg</code> ：指定的 this 对象</p><p><code>[argsArray]</code> ：数组形式的参数列表</p><p>返回值：使用调用者提供的 <code>this</code> 值和参数调用该函数的返回值。</p><h4 id="call" tabindex="-1">call <a class="header-anchor" href="#call" aria-label="Permalink to &quot;call&quot;">​</a></h4><p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><p><code>function.call(thisArg, arg1, arg2, ...)</code></p><p><code>thisArg</code> ：指定的 this 对象</p><p><code>arg1, arg2, ...</code>：参数列表</p><p>返回值：使用调用者提供的 <code>this</code> 值和参数调用该函数的返回值。若该方法没有返回值，则返回 <code>undefined</code>。</p><h4 id="bind" tabindex="-1">bind <a class="header-anchor" href="#bind" aria-label="Permalink to &quot;bind&quot;">​</a></h4><p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p><code>function.bind(thisArg, [arg1[, arg2[, ...]]])</code></p><p><code>thisArg</code> ：指定的 this 对象</p><p><code>arg1, arg2, ...</code>：参数列表，可选</p><p>返回值：返回一个原函数的拷贝，并拥有指定的 <strong><code>this</code></strong> 值和初始参数。</p><h2 id="三、应用场景" tabindex="-1">三、应用场景 <a class="header-anchor" href="#三、应用场景" aria-label="Permalink to &quot;三、应用场景&quot;">​</a></h2><p><strong>call/apply/bind 的核心理念：借用方法/方法复用</strong></p><h4 id="call-和-apply-的应用场景" tabindex="-1">call 和 apply 的应用场景： <a class="header-anchor" href="#call-和-apply-的应用场景" aria-label="Permalink to &quot;call 和 apply 的应用场景：&quot;">​</a></h4><ol><li>判断数据类型</li><li>类数组借用数组的方法</li><li>apply 获取数组最大值最小值</li><li>继承父类的方法/属性</li></ol><ul><li><strong>参数数量/顺序确定就用 call，参数数量/顺序不确定的话就用 apply</strong>。</li></ul><h4 id="bind-的应用场景" tabindex="-1">bind 的应用场景： <a class="header-anchor" href="#bind-的应用场景" aria-label="Permalink to &quot;bind 的应用场景：&quot;">​</a></h4><ol><li>保存函数参数</li><li>回调函数 this 丢失问题</li></ol><h2 id="四、手写" tabindex="-1">四、手写 <a class="header-anchor" href="#四、手写" aria-label="Permalink to &quot;四、手写&quot;">​</a></h2><h3 id="call-的手写" tabindex="-1">call 的手写 <a class="header-anchor" href="#call-的手写" aria-label="Permalink to &quot;call 的手写&quot;">​</a></h3><p>思路：</p><ol><li>根据 call 的规则设置上下文对象,也就是 <code>this</code> 的指向。</li><li>通过设置 <code>context</code> 的属性,将函数的 this 指向 <a href="https://juejin.cn/post/6844903630592540686#heading-4" title="隐式绑定" target="_blank" rel="noreferrer">隐式绑定</a> 到 context 上</li><li>通过隐式绑定执行函数并传递参数。</li><li>删除临时属性，返回函数执行结果。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myCall</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        context </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> specialPrototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;特殊属性Symbol&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于临时储存函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    context[specialPrototype] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数的this指向隐式绑定到context上</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context[specialPrototype](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过隐式绑定执行函数并传递参数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context[specialPrototype]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除上下文对象的属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回函数执行结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="bind-的手写" tabindex="-1">bind 的手写 <a class="header-anchor" href="#bind-的手写" aria-label="Permalink to &quot;bind 的手写&quot;">​</a></h3><p>思路：</p><ol><li>拷贝源函数: <ul><li>通过变量储存源函数</li><li>使用 <code>Object.create</code> 复制源函数的 prototype 给 fToBind</li></ul></li><li>返回拷贝的函数</li><li>调用拷贝的函数： <ul><li>new 调用判断：通过 <code>instanceof</code> 判断函数是否通过 <code>new</code> 调用，来决定绑定的 <code>context</code></li><li>绑定 this+ 传递参数</li><li>返回源函数的执行结果</li></ul></li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myBind</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">objThis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> thisFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存储源函数以及上方的params(函数参数)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 对返回的函数 secondParams 二次传参</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fToBind</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">secondParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isNew</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fToBind</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // this是否是fToBind的实例 也就是返回的fToBind是否通过new调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isNew </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(objThis) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// new调用就绑定到this上,否则就绑定到传入的objThis上</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thisFn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">params, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secondParams); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用call调用源函数绑定this的指向并传递参数,返回执行结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">thisFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 复制源函数的prototype给fToBind 一些情况下函数没有prototype，比如箭头函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        fToBind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">thisFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fToBind; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回拷贝的函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div>`,49)]))}const E=s(n,[["render",l]]);export{c as __pageData,E as default};
