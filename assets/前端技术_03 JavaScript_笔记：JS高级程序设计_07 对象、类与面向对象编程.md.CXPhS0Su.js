import{_ as i}from"./chunks/07 对象、类与面向对象编程-1.5ykjXqya.js";import{_ as a}from"./chunks/07 对象、类与面向对象编程-2.Cz-nz9Gz.js";import{_ as n,c as t,o as l,ae as h}from"./chunks/framework.CIivgcbp.js";const F=JSON.parse('{"title":"07 对象、类与面向对象编程","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/07 对象、类与面向对象编程.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/07 对象、类与面向对象编程.md"}'),p={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/07 对象、类与面向对象编程.md"};function e(k,s,r,E,d,o){return l(),t("div",null,s[0]||(s[0]=[h(`<h1 id="_07-对象、类与面向对象编程" tabindex="-1">07 对象、类与面向对象编程 <a class="header-anchor" href="#_07-对象、类与面向对象编程" aria-label="Permalink to &quot;07 对象、类与面向对象编程&quot;">​</a></h1><h2 id="一、理解对象" tabindex="-1">一、理解对象 <a class="header-anchor" href="#一、理解对象" aria-label="Permalink to &quot;一、理解对象&quot;">​</a></h2><p>可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><h3 id="一-定义属性" tabindex="-1">（一）定义属性 <a class="header-anchor" href="#一-定义属性" aria-label="Permalink to &quot;（一）定义属性&quot;">​</a></h3><p>ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的，不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 <code>[[Enumerable]]</code>。</p><p>==属性分两种：数据属性和访问器属性。==</p><h4 id="_1-数据属性" tabindex="-1">1. 数据属性 <a class="header-anchor" href="#_1-数据属性" aria-label="Permalink to &quot;1. 数据属性&quot;">​</a></h4><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特性描述它们的行为。</p><ul><li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。直接定义在对象上的属性默认为 true。</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。直接定义在对象上的属性默认为 true。</li><li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认为 true。</li><li><code>[[Value]]</code>：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。默认为 undefined。</li></ul><p>要修改属性的默认特性，就必须使用 <code>Object.defineProperty()</code> 方法。</p><h4 id="_2-访问器属性" tabindex="-1">2. 访问器属性 <a class="header-anchor" href="#_2-访问器属性" aria-label="Permalink to &quot;2. 访问器属性&quot;">​</a></h4><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，它们不是必须的。访问器属性有 4 个特性描述它们的行为。</p><ul><li><code>[[Configurable]]</code>：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。直接定义在对象上的属性默认为 true。</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过 for-in 循环返回。直接定义在对象上的属性默认为 true。</li><li><code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为 undefined。</li><li><code>[[Set]]</code>：设置函数，在写入属性时调用。默认值为 undefined。</li></ul><p>==访问器属性是不能直接定义的==，必须使用 <code>Object.defineProperty()</code> 方法。（字面量 getter/setter 是一种语法糖）</p><p>==数据属性和访问器属性不能直接相互转换。==<code>[[Configurable]]</code> 特性为 true 的情况下，可以通过删除现有的属性并重新定义它来实现从一种类型到另一种类型的变更。</p><h4 id="_3-defineproperty" tabindex="-1">3. defineProperty <a class="header-anchor" href="#_3-defineproperty" aria-label="Permalink to &quot;3. defineProperty&quot;">​</a></h4><blockquote><p>[!example]+ defineProperty<br><code>defineProperty</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。它允许精确地添加或修改对象上的属性。</p><p><code>Object.defineProperty(obj, prop, descriptor)</code></p><ul><li>obj: 要在其上定义属性的对象。</li><li>prop: 一个字符串或 Symbol，指定了要定义或修改的属性键。</li><li>descriptor: 将定义或修改的属性描述符。</li></ul><p>属性描述符有两种主要类型：数据描述符和访问器描述符。它们共享以下可选键：</p><ul><li>configurable: 默认值为 false。</li><li>enumerable: 默认值为 false。</li></ul><p>数据描述符还具有以下可选键：</p><ul><li>value: 默认值为 undefined。</li><li>writable: 默认值为 false。</li></ul><p>访问器描述符还具有以下可选键：</p><ul><li>get: 默认值为 undefined。</li><li>set: 默认值为 undefined。</li></ul><p>==通过 <code>Object.defineProperty</code> 定义的属性的描述符默认值与直接定义的属性是不一样的，configurable、enumerable、writable 默认均为 false。==</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字面量创建数据属性和访问器属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key1:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    return </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 数据属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  configurable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  enumerable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  writable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  value:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问器属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  configurable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  enumerable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h4 id="_4-defineproperties" tabindex="-1">4. defineProperties <a class="header-anchor" href="#_4-defineproperties" aria-label="Permalink to &quot;4. defineProperties&quot;">​</a></h4><p><code>Object.defineProperties()</code> 方法可以通过多个描述符一次性定义多个属性。</p><blockquote><p>[!example]+ Object.defineProperties</p><p><code>Object.defineProperties(obj, props)</code> 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p><ul><li>obj: 要在其上定义或修改属性的对象。</li><li>props: 一个对象，其键是属性名称，值是描述符对象，用于指定每个属性的特性。</li></ul><p>描述符对象可以包含以下可选键：</p><ul><li>configurable: 当设置为 true 时，表示该属性的类型可以被改变，并且该属性可以从对象中删除。默认值为 false。</li><li>enumerable: 当设置为 true 时，表示该属性将在枚举相应对象的属性时出现（例如在 for...in 循环中）。默认值为 false。</li><li>value: 属性相关的值。它可以是任何有效的 JavaScript 值（数字、对象、函数等）。默认值为 undefined。</li><li>writable: 如果设置为 true，则表示可以通过赋值运算符更改与属性关联的值。默认值为 false。</li><li>get: 用作属性 getter 的函数，如果没有 getter 则为 undefined。当访问该属性时将调用此函数，并将 <code>this</code> 设置为通过该属性访问的对象。默认值为 undefined。</li><li>set: 用作属性 setter 的函数，如果没有 setter 则为 undefined。当属性被赋值时会调用此函数，并带有一个参数（要赋给该属性的新值），并将 <code>this</code> 设置为通过该属性分配的对象。默认值为 undefined。</li></ul><p>注意点：</p><ul><li>如果描述符没有 value、writable、get 和 set 键中的任何一个，它将被视为数据描述符。</li><li>如果描述符同时具有 value 或 writable 和 get 或 set 键，则会抛出异常。</li></ul></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key5: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    configurable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enumerable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    writable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key6: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    configurable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enumerable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="二-访问属性" tabindex="-1">（二）访问属性 <a class="header-anchor" href="#二-访问属性" aria-label="Permalink to &quot;（二）访问属性&quot;">​</a></h3><p>要读取对象的属性，可以使用点号（<code>person.name</code>）或方括号语法 (<code>person[&quot;name&quot;]</code>)。方括号语法适合属性名需要动态确定或包含特殊字符的情形。</p><h4 id="_1-连缀属性" tabindex="-1">1. 连缀属性 <a class="header-anchor" href="#_1-连缀属性" aria-label="Permalink to &quot;1. 连缀属性&quot;">​</a></h4><p>从父对象访问子对象的属性，只需连续写出属性名即可，这称为属性链。<code>a.b.c.d</code></p><p>如果中间某个对象不存在就会抛出错误。这时候，可以使用<strong>可选连缀操作符</strong>，即问号加点号的形式。<br><code>a?.b?.c?.d</code><br> 这是一种短路机制。</p><h4 id="_2-读取属性的特性" tabindex="-1">2. 读取属性的特性 <a class="header-anchor" href="#_2-读取属性的特性" aria-label="Permalink to &quot;2. 读取属性的特性&quot;">​</a></h4><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符。</p><blockquote><p>[!example]+ Object.getOwnPropertyDescriptor</p><p><code>Object.getOwnPropertyDescriptor(obj, prop)</code> 方法返回指定对象上一个自有属性的描述符，如果属性存在于继承链上或不存在，则返回 undefined。</p><ul><li>obj: 要查询其属性描述符的对象。</li><li>prop: 要获取其描述符的属性名称。</li></ul><p>返回值: 如果指定的属性存在于给定对象中，则返回该属性的描述符对象；否则返回 undefined。描述符对象可能包含以下键：</p><ul><li>configurable: 当且仅当该属性的类型可以被改变，并且该属性可以从对应对象中删除时为 true。</li><li>enumerable: 当且仅当在枚举相应对象的属性时该属性显现时为 true。</li><li>value: 该属性对应的值。可以是任何有效的 JavaScript 值（数值、对象、函数等）。</li><li>writable: 当且仅当可以使用赋值运算符改变该属性的值时为 true。</li><li>get: 属性的 getter 函数，如果没有 getter 则为 undefined。当访问该属性时将调用此函数，并将 <code>this</code> 设置为通过该属性访问的对象。</li><li>set: 属性的 setter 函数，如果没有 setter 则为 undefined。当属性被赋值时会调用此函数，并带有一个参数（要赋给该属性的新值），并将 <code>this</code> 设置为通过该属性分配的对象。</li></ul><p>注意点：==此方法只适用于自身属性，不会查找原型链上的属性==。</p></blockquote><p>ECMAScript 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code> 静态方法。这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们。</p><h3 id="三-对象静态方法" tabindex="-1">（三）对象静态方法 <a class="header-anchor" href="#三-对象静态方法" aria-label="Permalink to &quot;（三）对象静态方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>分类</th><th>方法</th><th>行为</th></tr></thead><tbody><tr><td><strong>枚举相关</strong></td><td>Object.keys()</td><td>返回对象自有可枚举属性名的数组</td></tr><tr><td></td><td>Object.values()</td><td>返回对象自有可枚举属性值的数组</td></tr><tr><td></td><td>Object.entries()</td><td>返回对象自有可枚举字符串属性的键 - 值对数组</td></tr><tr><td></td><td>Object.getOwnPropertyNames()</td><td>返回对象所有自有属性名（包括不可枚举属性）的数组</td></tr><tr><td></td><td>Object.getOwnPropertySymbols()</td><td>返回对象所有自有符号属性（包括不可枚举属性）的数组</td></tr><tr><td><strong>属性相关</strong></td><td>Object.defineProperties()</td><td>使用多个属性描述符定义或修改对象的多个属性</td></tr><tr><td></td><td>Object.defineProperty()</td><td>使用属性描述符定义或修改对象的属性</td></tr><tr><td></td><td>Object.getOwnPropertyDescriptor()</td><td>返回描述对象上指定属性配置的描述符</td></tr><tr><td></td><td>Object.getOwnPropertyDescriptors()</td><td>返回描述对象上多个指定属性配置的描述符对象</td></tr><tr><td></td><td>Object.hasOwn()</td><td>确定对象是否拥有指定的自有属性</td></tr><tr><td><strong>对象控制相关</strong></td><td>Object.freeze()</td><td>冻结对象，防止再添加新属性及修改或删除已有属性</td></tr><tr><td></td><td>Object.seal()</td><td>封存对象，防止再添加新属性及删除或配置已有属性</td></tr><tr><td></td><td>Object.preventExtensions()</td><td>将对象设置为不可扩展，即不能添加新属性</td></tr><tr><td></td><td>Object.isFrozen()</td><td>确定对象是否被冻结，即是否不可扩展且所有属性都不可配置</td></tr><tr><td></td><td>Object.isSealed()</td><td>确定对象是否被封存，即是否不可扩展且所有属性都不可配置</td></tr><tr><td></td><td>Object.isExtensible()</td><td>确定对象是否可以扩展，即是否可以添加新属性</td></tr><tr><td></td><td>Object.setPrototypeOf()</td><td>将对象的原型（即内部的 <code>[[Prototype]]</code> 属性）设置为指定对象或 null</td></tr><tr><td></td><td>Object.getPrototypeOf()</td><td>返回指定对象的原型（即内部的 <code>[[Prototype]]</code> 属性）</td></tr><tr><td><strong>对象操作相关</strong></td><td>Object.create()</td><td>基于指定的原型对象和属性创建新对象</td></tr><tr><td></td><td>Object.assign()</td><td>从一个或多个源对象向目标对象复制所有可枚举属性的值</td></tr><tr><td></td><td>Object.fromEntries()</td><td>基于传入的键 - 值对可迭代对象（如数组或映射）返回一个新对象</td></tr><tr><td></td><td>Object.is()</td><td>确定两个值是不是同一个值，考虑边界情形 NaN 和 -0</td></tr></tbody></table><h4 id="_1-冻结对象" tabindex="-1">1. 冻结对象 <a class="header-anchor" href="#_1-冻结对象" aria-label="Permalink to &quot;1. 冻结对象&quot;">​</a></h4><p><code>Object.freeze()</code> 方法用于冻结对象，把对象变成完全不可修改的状态，不能扩展属性，也不能配置已有属性，不能改变对象的原型。</p><blockquote><p>[!example]+ Object.freeze</p><p><code>Object.freeze(obj)</code> 方法冻结对象：其他代码不能删除或添加属性，也不能修改现有属性的可枚举性、可配置性或可写性。因此，它本质上是不可变的。</p><ul><li>obj: 要冻结的对象。</li></ul><p>返回值: 被冻结的对象本身。</p><p>注意点：</p><ul><li>冻结的对象不能被修改；尝试添加、删除或修改属性（包括它们的描述符）将会失败，无论是直接操作还是通过反射 API 。</li><li><code>Object.freeze</code> 只会浅冻结对象自身的属性。如果需要深度冻结，则必须递归地对每个嵌套对象调用 <code>Object.freeze</code>。</li></ul></blockquote><p>可以使用 <code>Object.isFrozen()</code> 检测对象是否被冻结。</p><h4 id="_2-封存对象" tabindex="-1">2. 封存对象 <a class="header-anchor" href="#_2-封存对象" aria-label="Permalink to &quot;2. 封存对象&quot;">​</a></h4><blockquote><p>[!example]+ Object.seal</p><p><code>Object.seal(obj)</code> 方法封存一个对象，阻止添加新属性并使现有属性不可配置。但是，允许对现有属性的值进行修改（除非属性是不可写的）。</p><ul><li>obj: 要封存的对象。</li></ul><p>返回值: 被封存的对象本身。</p></blockquote><p>使用 <code>Object.isSealed()</code> 可以检查一个对象是否已被密封。</p><h4 id="_3-阻止扩展对象" tabindex="-1">3. 阻止扩展对象 <a class="header-anchor" href="#_3-阻止扩展对象" aria-label="Permalink to &quot;3. 阻止扩展对象&quot;">​</a></h4><blockquote><p>[!example]+ Object.preventExtensions</p><p><code>Object.preventExtensions(obj)</code> 方法防止新属性被添加到对象中，使其不可扩展。这意味着不能再向对象中添加新的自有属性；然而，现有属性可以被修改或删除。</p><ul><li>obj: 要阻止扩展的对象。</li></ul><p>返回值: 被阻止扩展的对象本身。</p><p>注意点：</p><ul><li>此方法不会影响对象原型链上的属性。</li></ul></blockquote><p>使用 <code>Object.isExtensible()</code> 可以检查一个对象是否是可扩展的。</p><h4 id="_4-合并对象" tabindex="-1">4. 合并对象 <a class="header-anchor" href="#_4-合并对象" aria-label="Permalink to &quot;4. 合并对象&quot;">​</a></h4><p>合并（merge）对象就是把源对象所有的本地属性一起复制到目标对象上，从功能的增强来说也被称为混入（mixin）</p><p>ECMAScript 6 专门为合并对象提供了 <code>Object.assign()</code> 方法。</p><blockquote><p>[!example]+ Object.assign</p><p><code>Object.assign(target, ...sources)</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><ul><li>target: 目标对象，即接收属性的对象。</li><li>sources: 源对象，其可枚举属性将被复制到目标对象中。</li></ul><p>返回值: 目标对象，已经接收了源对象的属性。</p><p>注意点：</p><ul><li>此方法只拷贝源对象的可枚举和自有属性到目标对象。</li><li>==访问器属性（getter 和 setter）会被调用并执行，得到一个数据属性。==</li><li>原型链上的属性不会被复制。</li><li>对于属性的值为对象的情况，<code>Object.assign</code> 执行的是==浅拷贝==，这意味着嵌套对象并不会被深度复制。</li><li>属性复制是按顺序进行的，==后面的源对象属性会覆盖前面的属性==，以最后一个源对象中的属性为准。</li><li>如果目标对象是 null 或 undefined，将会抛出 TypeError。</li></ul></blockquote><h4 id="_5-相等判断" tabindex="-1">5. 相等判断 <a class="header-anchor" href="#_5-相等判断" aria-label="Permalink to &quot;5. 相等判断&quot;">​</a></h4><p>ECMAScript 6 规范新增了 <code>Object.is()</code>，这个方法与 <code>===</code> 很像。</p><blockquote><p>[!example]+ Object.is</p><p><code>Object.is(value1, value2)</code> 方法判断两个值是否相同。它提供了一种不同于严格相等运算符（<code>&#39;===&#39;</code>）的方式比较两个值，特别处理了 NaN、-0 和 +0 的情况。</p><ul><li>value1: 第一个待比较的值。</li><li>value2: 第二个待比较的值。</li></ul><p>返回值: 一个布尔值，如果两值相同则为 true；否则为 false。</p><p>注意点：</p><ul><li><code>Object.is</code> 对于两个 NaN 值返回 true，而使用 <code>&#39;===&#39;</code> 比较时 NaN !== NaN。</li><li><code>Object.is</code> 能区分 -0 和 +0，而 <code>&#39;===&#39;</code> 运算符认为 -0 和 +0 是相同的。</li></ul></blockquote><h3 id="四-对象的增强语法" tabindex="-1">（四）对象的增强语法 <a class="header-anchor" href="#四-对象的增强语法" aria-label="Permalink to &quot;（四）对象的增强语法&quot;">​</a></h3><ol><li><p>属性值简写<br> 当属性名和变量名是一样的适合，简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Matt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p>可计算属性<br> 可计算属性，就可以在对象字面量中完成动态属性赋值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nameKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uniqueToken </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUniqueKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}_\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">uniqueToken</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUniqueKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nameKey)]: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Matt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p>简写方法名</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	sayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`My name is \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p>对象解构</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Matt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name, age } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person;</span></span></code></pre></div><p>如果引用的属性不存在，则该变量的值就是 undefined。<br> 也可以在解构赋值的同时定义默认值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person;</span></span></code></pre></div></li><li><p>剩余操作符<br> 在重新构造对象时，可以使用剩余操作符把所有未明确的可枚举属性都收集到一个对象中。==执行的是浅拷贝。==</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Matt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	job:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Engineer&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">elseArg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person</span></span></code></pre></div></li><li><p>扩展操作符<br> 扩展操作符可以把两个对象类似数组拼接的方式组合在一起。（类似 Object.assign）会把内部对象的所有==可枚举的自有属性== ==浅拷贝==到外部对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {a:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {b:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foobar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar, c:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><h2 id="二、构建对象" tabindex="-1">二、构建对象 <a class="header-anchor" href="#二、构建对象" aria-label="Permalink to &quot;二、构建对象&quot;">​</a></h2><h3 id="一-工厂模式" tabindex="-1">（一）工厂模式 <a class="header-anchor" href="#一-工厂模式" aria-label="Permalink to &quot;（一）工厂模式&quot;">​</a></h3><p>工厂模式，就是通过函数的方式接受参数，每次调用工厂函数，就返回一个独立的对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createPerson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	o.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	o.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	o.job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	o.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createPerson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Software Engineer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createPerson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Greg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doctor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="二-构造函数模式" tabindex="-1">（二）构造函数模式 <a class="header-anchor" href="#二-构造函数模式" aria-label="Permalink to &quot;（二）构造函数模式&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Software Engineer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Greg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doctor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>Person()</code> 构造函数代替了 <code>createPerson()</code> 工厂函数，它们有如下区别：</p><ul><li>没有显式地创建对象。</li><li>属性和方法直接赋值给了 this。</li><li>没有 return。</li></ul><p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的 <code>[[Prototype]]</code> 特性被赋值为构造函数的 <code>prototype</code> 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。</p><p>构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此，内部的方法可以使用变量引用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sayName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sayName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法， 那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p><h3 id="三-原型模式" tabindex="-1">（三）原型模式 <a class="header-anchor" href="#三-原型模式" aria-label="Permalink to &quot;（三）原型模式&quot;">​</a></h3><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">job</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.job </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> job;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Software Engineer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Greg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doctor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h4 id="_1-理解原型" tabindex="-1">1. 理解原型 <a class="header-anchor" href="#_1-理解原型" aria-label="Permalink to &quot;1. 理解原型&quot;">​</a></h4><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。<br><img src="`+i+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/07 对象、类与面向对象编程-1.png"><br> 每次调用构造函数创建一个新实例，这个实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象，通过 <code>__proto__</code> 这个属性可以访问对象的原型。</p><p>一个对象的原型对象通常没有直接显式的引用变量名，这意味着你不能直接通过一个变量名来访问对象的原型对象。然而，确实可以通过两种主要方式间接访问或修改原型对象：<br><strong>通过构造函数的 <code>prototype</code> 属性</strong>：<code>Person.prototype</code><br><strong>通过实例对象的 <code>__proto__</code> 属性</strong>：<code>person1.__proty__</code> 、<code>person2.__proty__</code></p><h4 id="_2-原型链检查工具" tabindex="-1">2. 原型链检查工具 <a class="header-anchor" href="#_2-原型链检查工具" aria-label="Permalink to &quot;2. 原型链检查工具&quot;">​</a></h4><p>构造函数和其实例之间没有直接的属性联系，可以使用 <code>instanceof</code> 操作符来判断一个对象是否是由特定构造函数创建的实例。</p><blockquote><p>[!example]+ instanceof</p><p><code>object instanceof constructor</code> 运算符用于检测某个对象是否是特定构造函数的实例。</p><ul><li>object: 要检测的对象。</li><li>constructor: 某个构造函数，用来测试与对象的关系。</li></ul><p>返回值: 一个布尔值，如果对象是构造函数的实例则为 true；否则为 false。</p><p>注意点：</p><ul><li><code>instanceof</code> 不仅检查直接继承，还会沿着对象的原型链进行检查。如果在原型链中找到了构造函数的 prototype 属性，则返回 true。</li></ul></blockquote><p><code>instanceof</code> 的工作过程如下：</p><ol><li>首先，检查 <code>person.__proto__</code> 是否严格等于 <code>Person.prototype</code>。如果是，则返回 <code>true</code>。</li><li>如果没有找到匹配，继续检查 <code>person.__proto__.__proto__</code> 是否等于 <code>Person.prototype</code> 的原型（即 <code>Object.prototype</code>），依此类推。</li><li>这个过程持续进行，直到找到匹配的原型或达到原型链的末尾（<code>null</code>）。如果整个原型链都没有匹配，则返回 <code>false</code>。</li></ol><p>如果需要判断一个对象是否在是一个原型对象原型链上，可以使用 <code>isPrototpeOf()</code>，它是 Object.prototype 上的方法，所有的对象都能使用。</p><blockquote><p>[!example]+ isPrototypeOf</p><p><code>constructor.isPrototypeOf(object)</code> 方法用于测试某个构造函数的原型对象是否存在于给定对象的原型链上。</p><ul><li>constructor: 某个构造函数或对象，其原型属性将被检查是否存在于对象的原型链中。</li><li>object: 要检测的对象。</li></ul><p>返回值: 一个布尔值，如果调用此方法的构造函数的原型对象存在于给定对象的原型链上，则为 true；否则为 false。</p><p>注意点：</p><ul><li><code>isPrototypeOf</code> 方法不同于 <code>instanceof</code> 运算符，它直接使用构造函数的原型对象进行比较，而不是通过构造函数本身。</li><li>可以用来确认两个对象之间的继承关系。如果一个对象的原型链中包含另一个对象，那么后者就是前者的原型。</li><li>该方法对于验证对象间的继承关系非常有用，特别是在复杂的继承结构中确定对象之间是否存在直接或间接的原型关联。<br> ECMAScript</li></ul></blockquote><p>ECMAScript 的 Object 类型有一个方法叫 <code>Object.getPrototypeOf()</code>，返回参数的内部特性 <code>[[Prototype]]</code> 的值。</p><blockquote><p>[!example]+ Object.getPrototypeOf</p><p><code>Object.getPrototypeOf(object)</code> 方法返回指定对象的原型（即内部的 <code>[[Prototype]]</code> 属性的值）。</p><ul><li>object: 要获取其原型的对象。</li></ul><p>返回值: 给定对象的原型。如果该对象没有继承任何属性（即它的原型是 null），则返回 null。</p><p>注意点：</p><ul><li>此方法提供了一种标准的方式来访问对象的原型，取代了早期使用的 <code>__proto__</code> 属性，后者虽然在一些环境中可用，但并不推荐使用。</li></ul></blockquote><p>Object 还有一个 <code>setPrototypeOf()</code> 方法，可以向实例的私有特性 <code>[[Prototype]]</code> 写入一<br> 个新值。这样就可以重写一个对象的原型继承关系。</p><blockquote><p>[!example]+ Object.setPrototypeOf</p><p><code>Object.setPrototypeOf(obj, prototype)</code> 方法设置对象的原型（即内部的 <code>[[Prototype]]</code> 属性）为另一个对象或 null。</p><ul><li>obj: 要设置其原型的对象。</li><li>prototype: 该对象的新原型，可以是一个对象或者 null。如果传入非 null 非对象值，会强制转换成对象；如果传入 null，则表示没有原型。</li></ul><p>返回值: 修改后的对象本身。</p><p>注意点：</p><ul><li>更改现有对象的原型是一个相对低级别的操作，可能会影响性能，尤其是在对大量对象进行操作时。因此，应谨慎使用。</li><li>对于创建具有特定原型的对象，更推荐的做法是使用 <code>Object.create()</code> 方法，它提供了一种更加高效且安全的方式来实现相同的效果。</li></ul></blockquote><h4 id="_3-读取对象属性" tabindex="-1">3. 读取对象属性 <a class="header-anchor" href="#_3-读取对象属性" aria-label="Permalink to &quot;3. 读取对象属性&quot;">​</a></h4><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。</p><p>如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会<strong>遮蔽（shadow）</strong> 原型对象上的同名属性。</p><p><code>hasOwnProperty()</code> 方法用于确定某个属性是在实例上还是在原型对象上。它是 Object.prototype 上的方法，所有的对象都能使用。</p><blockquote><p>[!example]+ hasOwnProperty</p><p><code>object.hasOwnProperty(prop)</code> 方法用于判断对象是否具有指定名称的自有属性（即直接定义在该对象上的属性，而不是通过原型链继承来的）。</p><ul><li>prop: 要检测的属性名（字符串类型），也可以是能转换为字符串的值。</li></ul><p>返回值: 一个布尔值，如果对象具有指定名称的自有属性，则返回 true；否则返回 false。</p></blockquote><p>有两种方式使用 <code>in</code> 操作符：单独使用和在 <code>for-in</code> 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。</p><blockquote><p>[!example]+ in 操作符</p><p><code>prop in object</code> 操作符用于检查对象是否具有指定名称的属性（包括自身属性和原型链上的属性）。</p><ul><li>prop: 要检测的属性名（字符串或符号类型），也可以是能转换为字符串的值。</li><li>object: 要在其上进行属性查找的对象。</li></ul><p>返回值: 一个布尔值，如果对象及其原型链中存在指定名称的属性，则返回 true；否则返回 false。</p><p>注意点：</p><ul><li><code>in</code> 操作符不仅会检查对象本身的属性，还会沿着对象的原型链向上查找。这意味着它也能检测到从父类或原型继承下来的属性。</li><li>使用 <code>in</code> 操作符时要注意，即使是不可枚举的属性也会被检测到，这与 <code>for...in</code> 循环不同，后者只迭代可枚举的属性。</li></ul></blockquote><p>要获得对象上所有可枚举的实例属性，可以使用 <code>Object.keys()</code> 方法。</p><blockquote><p>[!example]+ Object.keys</p><p><code>Object.keys(obj)</code> 方法返回一个包含给定对象所有可枚举属性名称（字符串类型）的数组。这些属性是对象自身的属性，不包括继承自原型链上的属性。</p><ul><li>obj: 要获取其可枚举自身属性名称的对象。</li></ul><p>返回值: 一个数组，包含了给定对象的所有可枚举属性的名称。</p></blockquote><p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 <code>Object.getOwnPropertyNames()</code></p><blockquote><p>[!example]+ Object.getOwnPropertyNames</p><p><code>Object.getOwnPropertyNames(obj)</code> 方法返回一个数组，包含对象自身的所有属性名称（包括不可枚举属性，但不包括符号类型的属性名称）。</p><ul><li>obj: 要获取其所有自身属性名称的对象。</li></ul><p>返回值: 一个数组，包含了给定对象的所有自身属性名称（字符串类型），包括不可枚举属性。</p><p>注意点：</p><ul><li>与 <code>Object.keys</code> 不同，<code>Object.getOwnPropertyNames</code> 还会列出不可枚举属性。</li></ul></blockquote><p>在 ECMAScript 6 新增符号类型之后，<code>Object.getOwnPropertySymbols()</code> 方法就出现。</p><blockquote><p>[!example]+ Object.getOwnPropertySymbols</p><p><code>Object.getOwnPropertySymbols(obj)</code> 方法返回一个数组，包含对象自身的所有符号类型的属性名称。</p><ul><li>obj: 要获取其所有符号类型属性名称的对象。</li></ul><p>返回值: 一个数组，包含了给定对象的所有自身属性名称（仅限符号类型）。</p><p>注意点：</p><ul><li>此方法专门用于检索对象中使用 <code>Symbol</code> 定义的属性名称，这在普通属性枚举中通常不会被包括（如通过 <code>for...in</code> 循环或 <code>Object.keys</code>）。</li><li>如果对象没有符号类型的属性，则返回一个空数组。</li></ul></blockquote><ul><li>属性枚举顺序<br><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。<br><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</li></ul><h4 id="_4-对象迭代" tabindex="-1">4. 对象迭代 <a class="header-anchor" href="#_4-对象迭代" aria-label="Permalink to &quot;4. 对象迭代&quot;">​</a></h4><p><code>Object.values()</code> 返回对象值的数组</p><blockquote><p>[!example]+ Object.values</p><p><code>Object.values(obj)</code> 方法返回一个给定对象自身所有可枚举属性的值组成的数组。</p><ul><li>obj: 要获取其所有可枚举属性值的对象。</li></ul><p>返回值: 一个数组，包含对象自身所有可枚举属性的值。属性按照它们在对象中定义的顺序排列。</p></blockquote><p><code>Object.entries()</code> 返回键/值对的数组。</p><blockquote><p>[!example]+ Object.entries</p><p><code>Object.entries(obj)</code> 方法返回一个给定对象自身所有可枚举属性的键值对数组。每个元素是一个具有两个元素的数组，第一个元素是属性名，第二个元素是属性值。</p><ul><li>obj: 要获取其所有可枚举属性键值对的对象。</li></ul><p>返回值: 一个数组，其中包含对象自身所有可枚举属性的键值对（即 <code>[key, value]</code> 形式的数组）。属性按照它们在对象中定义的顺序排列。</p></blockquote><p>ECMAScript 也提供了 <code>Object.fromEntries()</code>，可以基于键 - 值对的集合构建对象，与 entries 是相反的操作</p><h3 id="四-原型的继承" tabindex="-1">（四）原型的继承 <a class="header-anchor" href="#四-原型的继承" aria-label="Permalink to &quot;（四）原型的继承&quot;">​</a></h3><p>继承是面向对象编程的重要特性。</p><h4 id="_1-原型链" tabindex="-1">1. 原型链 <a class="header-anchor" href="#_1-原型链" aria-label="Permalink to &quot;1. 原型链&quot;">​</a></h4><p>ECMA-262 把<strong>原型链</strong>定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p><p><img src="'+a+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/07 对象、类与面向对象编程-2.png"></p><p>如上图所示，如果 Man 需要实现继承 Person，就需要把原型设置父类构造函数的一个新的实例。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;male&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 <code>Object.prototype</code>。</p><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 <code>instanceof</code> 操作符，第二种方式是使用 <code>isPrototypeOf()</code> 方法。</p><p>原型链虽然是实现继承的强大工具，但它也有问题：</p><ol><li><p>主要问题出现在原型中包含引用值的时候。原型中包含的引用值会在所有实例间共享。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。而通过 <code>Man.prototype = new Person()</code> 继承，会造成引用类型的共用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.ability.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sing&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b.ability) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[&#39;speak&#39;, &#39;walk&#39;, &#39;eat&#39;, &#39;sing&#39;]</span></span></code></pre></div></li><li><p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。</p></li></ol><h4 id="_2-盗用构造函数" tabindex="-1">2. 盗用构造函数 <a class="header-anchor" href="#_2-盗用构造函数" aria-label="Permalink to &quot;2. 盗用构造函数&quot;">​</a></h4><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来。基本思路很简单：在子类构造函数中调用父类构造函数。</p><p>盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;william&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//调用</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;male&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>从上代码可以看出，==盗用构造函数只是执行了父类的构造函数==，父类的构造函数上定义的属性和方法重新定义到子类中，并没有形成原型链。因此盗用构造函数的主要缺点，就是无法访问父类原型上定义的方法。因此，盗用构造函数基本上也不能单独使用。</p><h4 id="_3-组合继承" tabindex="-1">3. 组合继承 <a class="header-anchor" href="#_3-组合继承" aria-label="Permalink to &quot;3. 组合继承&quot;">​</a></h4><p><strong>组合继承</strong>（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，name)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 继承属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;male&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 继承方法</span></span></code></pre></div><h4 id="_4-原型式继承" tabindex="-1">4. 原型式继承 <a class="header-anchor" href="#_4-原型式继承" aria-label="Permalink to &quot;4. 原型式继承&quot;">​</a></h4><p>2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个 object() 函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。==本质上，object() 是对传入的对象执行了一次浅复制。==</p><p>ECMAScript 5 通过增加 <code>Object.create()</code> 方法将原型式继承的概念规范化了。</p><blockquote><p>[!example]+ Object.create</p><p><code>Object.create(proto[, propertiesObject])</code> 方法创建一个新对象，使用现有的对象来提供新创建对象的 <strong>proto</strong>。</p><ul><li>proto: 新创建对象的原型对象。可以是 null 或者任何对象，如果为 null，则新对象不具有原型，并且不能继承任何属性或方法。</li><li>propertiesObject（可选）: 如果指定了该参数，它是一个对象，其自身可枚举属性（即它的名称不是以符号开头的属性）将被定义为新创建对象的同名属性，这些属性会根据描述符（包括数据描述符或存取描述符）进行定义。例如，您可以指定属性是否可写、可枚举和可配置等。</li></ul><p>返回值: 一个新的对象，其原型设置为第一个参数提供的对象。</p><p>注意点：</p><ul><li>使用 <code>Object.create</code> 是一种实现基于原型继承的有效方式，允许您直接指定新对象的原型，而不是通过构造函数。</li><li>当第二个参数 <code>propertiesObject</code> 被省略时，新对象仅继承原型上的属性，而没有任何自身的属性。</li></ul></blockquote><p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，==属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。==</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="_5-寄生式继承" tabindex="-1">5. 寄生式继承 <a class="header-anchor" href="#_5-寄生式继承" aria-label="Permalink to &quot;5. 寄生式继承&quot;">​</a></h4><p>与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createAnother</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">original</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clone </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(original); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过调用函数创建一个新对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	clone.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以某种方式增强这个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clone; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回这个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createAnother</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>==通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。==</p><h4 id="_6-寄生式组合继承" tabindex="-1">6. 寄生式组合继承 <a class="header-anchor" href="#_6-寄生式组合继承" aria-label="Permalink to &quot;6. 寄生式组合继承&quot;">​</a></h4><p>==寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。==基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inheritPrototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">subType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">superType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prototype </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">superType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	prototype.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> subType; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重建原型与构造函数的关系</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	subType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prototype; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重建原型与构造函数的关系</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>==寄生式组合继承可以算是引用类型继承的最佳模式。==<br> 这种方法避免了传统组合继承中两次调用父类构造函数的问题，==有效地将原本可能存在的多次（O(n)）对父类构造函数的调用简化为仅需调用一次（O(1)）==，从而提高了性能和效率。同时，它保持了属性的独立性（每个实例都有自己的属性副本）和方法的共享性（所有实例共享同一个方法集合）。</p><h2 id="三、类" tabindex="-1">三、类 <a class="header-anchor" href="#三、类" aria-label="Permalink to &quot;三、类&quot;">​</a></h2><p>ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是 ECMAScript 中新的基础性语法糖结构。</p><h3 id="一-类定义" tabindex="-1">（一）类定义 <a class="header-anchor" href="#一-类定义" aria-label="Permalink to &quot;（一）类定义&quot;">​</a></h3><p>类声明：<code>class Person { }</code><br> 类表达式：<code>const Animal = class { };</code></p><p>而类受块作用域限制</p><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法</p><h3 id="二-类构造函数" tabindex="-1">（二）类构造函数 <a class="header-anchor" href="#二-类构造函数" aria-label="Permalink to &quot;（二）类构造函数&quot;">​</a></h3><p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。<br> 构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){ }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用 new 调用类的构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的 <code>[[Prototype]]</code> 指针被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><blockquote><p>[!tips]+ 手写 new</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myNew</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">O</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 创建一个新的空对象，其原型指向构造函数的原型对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">O</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 调用构造函数，绑定新对象为 this 上下文，并传入参数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> O</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 如果构造函数返回的是一个对象，则返回该对象；否则返回新创建的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。调用类构造函数时如果忘了使用 new 则会抛出错误。</p><p>ECMAScript 类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符。<br><code>typeof class Person{} //function</code></p><p>与普通构造函数一样，可以使用 <code>instanceof</code> 操作符检查构造函数原型是否存在于实例的原型链中。</p><h3 id="三-实例、原型和类成员" tabindex="-1">（三）实例、原型和类成员 <a class="header-anchor" href="#三-实例、原型和类成员" aria-label="Permalink to &quot;（三）实例、原型和类成员&quot;">​</a></h3><h4 id="_1-实例成员" tabindex="-1">1. 实例成员 <a class="header-anchor" href="#_1-实例成员" aria-label="Permalink to &quot;1. 实例成员&quot;">​</a></h4><p>每次通过 new 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;william&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_2-类字段声明" tabindex="-1">2. 类字段声明 <a class="header-anchor" href="#_2-类字段声明" aria-label="Permalink to &quot;2. 类字段声明&quot;">​</a></h4><p>ECMAScript 增加了类字段声明作为快捷方式。这样就可以直接在类体而非构造函数中初始化实例成员。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;william&quot;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	ability</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3-原型方法与访问器" tabindex="-1">3. 原型方法与访问器 <a class="header-anchor" href="#_3-原型方法与访问器" aria-label="Permalink to &quot;3. 原型方法与访问器&quot;">​</a></h4><p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p><p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据。</p><p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;william&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ability </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;speak&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;walk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex_ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;male&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 原型方法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	speak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;speak&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 访问器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex_</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	set</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sex_ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_4-私有类成员" tabindex="-1">4. 私有类成员 <a class="header-anchor" href="#_4-私有类成员" aria-label="Permalink to &quot;4. 私有类成员&quot;">​</a></h4><p>要声明私有类成员，需要在成员名前面加上 <code>#</code>，以防止在类外部直接访问和修改。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	#name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;william&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.#name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>私有成员的特殊规则如下：</p><ol><li><strong>私有成员只能在定义它们的类中访问</strong>，不能在类外部访问和修改</li><li><strong>私有成员不能被子类继承</strong>，仅限于定义它们的类使用。</li><li><strong>私有成员不能由派生类中的同名方法和属性访问或覆盖</strong>。</li><li><strong>构造函数不能私有</strong></li><li><strong>私有成员必须在类体内声明</strong>，不能在构造函数被调用期间或调用之后添加。</li></ol><p>字段、方法、get、set、异步函数和静态成员都可以设置成私有。</p><h4 id="_5-静态类方法" tabindex="-1">5. 静态类方法 <a class="header-anchor" href="#_5-静态类方法" aria-label="Permalink to &quot;5. 静态类方法&quot;">​</a></h4><p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。静态类成员在类定义中使用 <code>static</code> 关键字作为前缀。在静态成员中，this 引用类自身。<br> 静态类方法非常适合作为实例工厂。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_6-静态初始化块" tabindex="-1">6. 静态初始化块 <a class="header-anchor" href="#_6-静态初始化块" aria-label="Permalink to &quot;6. 静态初始化块&quot;">​</a></h4><p>在静态初始化比较重要的时候，类也支持通过静态初始化块来编写复杂代码以初始化静态成员。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;william&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>注意点：</p><ol><li>可以在类中使用任意多个初始化块，多个块按出现顺序求值</li><li>初始化块必须同步求值</li><li>初始化块的作用域按正常词法作用域对待</li><li>初始化块中的 this 引用类的构造函数</li></ol><h4 id="_7-迭代器与生成器方法" tabindex="-1">7. 迭代器与生成器方法 <a class="header-anchor" href="#_7-迭代器与生成器方法" aria-label="Permalink to &quot;7. 迭代器与生成器方法&quot;">​</a></h4><p>类定义语法支持在原型和类本身上定义生成器方法。<br> 因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.nicknames </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Jack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Jake&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;J-Dog&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[Symbol.iterator]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		yield</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.nicknames.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="四-类继承" tabindex="-1">（四）类继承 <a class="header-anchor" href="#四-类继承" aria-label="Permalink to &quot;（四）类继承&quot;">​</a></h3><p>ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有 <code>[[Construct]]</code> 和原型的对象。</p><p><code>class Man extends Person { }</code></p><h4 id="_1-super" tabindex="-1">1. super <a class="header-anchor" href="#_1-super" aria-label="Permalink to &quot;1. super&quot;">​</a></h4><p>派生类的方法可以通过 super 关键字引用它们的原型。<br> 在静态方法中可以通过 super 调用继承的类上定义的静态方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> speak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	  super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">speak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block github-alert"><p class="custom-block-title">+ \`[[HomeObject]]\`</p><p>ES6 给类构造函数和静态方法添加了内部特性 <code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为 <code>[[HomeObject]]</code> 的原型。</p></div><p>在使用 super 时要注意几个问题：</p><ol><li>super 只能在派生类构造函数和静态方法中使用。</li><li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。</li><li>调用 super() 会调用父类构造函数，并将返回的实例赋值给 this。</li><li>super() 的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</li><li>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数。</li><li>在类构造函数中，不能在调用 super() 之前引用 this。</li><li>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</li></ol><h4 id="_2-抽象类" tabindex="-1">2. 抽象类 <a class="header-anchor" href="#_2-抽象类" aria-label="Permalink to &quot;2. 抽象类&quot;">​</a></h4><p>虽然 ECMAScript 没有专门支持<strong>抽象类</strong>的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化。<br> 另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抽象基类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vehicle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vehicle) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vehicle cannot be directly instantiated&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.foo) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Inheriting class must define foo()&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;success!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 派生类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bus</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vehicle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 派生类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Van</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vehicle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// success!</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Van</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Inheriting class must define foo()</span></span></code></pre></div><h4 id="_3-继承内置类型" tabindex="-1">3. 继承内置类型 <a class="header-anchor" href="#_3-继承内置类型" aria-label="Permalink to &quot;3. 继承内置类型&quot;">​</a></h4><p>ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型<br> 有些内置类型的方法会返回新实例，如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SuperArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Symbol.species]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_4-类混入" tabindex="-1">4. 类混入 <a class="header-anchor" href="#_4-类混入" aria-label="Permalink to &quot;4. 类混入&quot;">​</a></h4><p>extends 关键字后面是一个 JavaScript 表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vehicle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getParentClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;evaluated expression&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vehicle;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bus</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getParentClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。</p><p>很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：==“组合胜过继承（composition over inheritance）。”==</p>`,202)]))}const u=n(p,[["render",e]]);export{F as __pageData,u as default};
