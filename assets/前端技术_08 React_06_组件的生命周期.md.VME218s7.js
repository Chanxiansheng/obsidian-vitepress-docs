import{_ as t,c as o,o as l,ae as r}from"./chunks/framework.CIivgcbp.js";const n="/obsidian-vitepress-docs/assets/Pasted%20image%2020231221163418.Bqcnp8of.png",i="/obsidian-vitepress-docs/assets/Pasted%20image%2020231221172430.BsdjGb7l.png",b=JSON.parse('{"title":"06_ 组件的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/08 React/06_组件的生命周期.md","filePath":"前端技术/08 React/06_组件的生命周期.md"}'),a={name:"前端技术/08 React/06_组件的生命周期.md"};function p(s,e,c,d,m,u){return l(),o("div",null,e[0]||(e[0]=[r('<h1 id="_06-组件的生命周期" tabindex="-1">06_ 组件的生命周期 <a class="header-anchor" href="#_06-组件的生命周期" aria-label="Permalink to &quot;06_ 组件的生命周期&quot;">​</a></h1><ul><li>组件从创建到死亡它会经历一些特定的阶段。</li><li>React 组件中包含一系列勾子函数 (生命周期回调函数), 会在特定的时刻调用。</li><li>我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。</li></ul><h2 id="生命周期流程图-旧" tabindex="-1">生命周期流程图（旧） <a class="header-anchor" href="#生命周期流程图-旧" aria-label="Permalink to &quot;生命周期流程图（旧）&quot;">​</a></h2><p><img src="'+n+'" alt="Pasted image 20231221163418.png"></p><ul><li>生命周期的三个阶段（旧)</li></ul><ol><li>初始化阶段: 由 ReactDOM.render() 触发 --- 初次渲染 <ol><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ol></li><li>更新阶段: 由组件内部 this.setSate()、this.forceUpdate() 或父组件重新 render 触发 <ol><li>shouldComponentUpdate()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ol></li><li>卸载组件: 由 ReactDOM.unmountComponentAtNode() 触发<br> componentWillUnmount()</li></ol><blockquote><p>注意：</p><ol><li>forceUpdate 可以执行强制更新，不过会跳过 shouldComponentUpdate 的触发。</li><li>父组件重新 render 会先触发 componentWillReceiveProps</li></ol></blockquote><ul><li>说明：<br> constructor：构造器<br> componentWillMount：组件将要挂载<br> render：初始化渲染或更新渲染调用<br> componentDidMount：组件挂载完毕，开启监听, 发送 ajax 请求<br> componentWillReceiveProps：组件将要从父组件接收新的 props<br> shouldComponentUpdate：组件是否应该被更新，必须返回一个 true 或者 false<br> componentWillUpdate：组件将要更新<br> componentDidUpdate：组件完成更新<br> componentWillUnmount：组件卸载前，通常用于停止计时器、结束 websocket</li></ul><h2 id="生命周期流程图-新-16-3-版本后" tabindex="-1">生命周期流程图（新）16.3 版本后 <a class="header-anchor" href="#生命周期流程图-新-16-3-版本后" aria-label="Permalink to &quot;生命周期流程图（新）16.3 版本后&quot;">​</a></h2><p><img src="'+i+'" alt="Pasted image 20231221172430.png"></p><ul><li>生命周期的三个阶段（新）</li></ul><ol><li>初始化阶段: 由 ReactDOM.render() 触发 --- 初次渲染<br> constructor()<br> ==getDerivedStateFromProps()==<br> render()<br> componentDidMount()</li><li>更新阶段: 由组件内部 this.setSate() 或父组件重新 render 触发<br> ==getDerivedStateFromProps()==<br> shouldComponentUpdate()<br> render()<br> ==getSnapshotBeforeUpdate()==<br> componentDidUpdate()</li><li>卸载组件: 由 ReactDOM.unmountComponentAtNode() 触发<br> componentWillUnmount()</li></ol><blockquote><p>[!hint]+ React 更新<br> 从 16.3 版本之后，componentWillMount、componentWillUpdate、componentWillReceiveProps 需要额外添加 <code>UNSAFE_</code> 前缀使用，意味着未来版本有可能被废弃。</p></blockquote><ul><li>两个新的生命钩子 <ul><li><code>getDerivedStateFromProps(props,state)</code><br> 语义：从 Props 中获得一个派生的 state。<br> React 会在初始挂载和后续更新时调用 render 之前调用它。它应该返回一个对象来更新 state，或者返回 null 就不更新任何内容。<br><strong>此方法适用于少数罕见用例，适用于 state 在任何时候都取决于 props 的情况。</strong><br> 派生 state 会导致代码冗长，并使你的组件难以理解。</li><li><code>getSnapshotBeforeUpdate(preProps, proState)</code><br> 语义：在组件更新之前获取快照。<br> React 会在 React 更新 DOM 之前时直接调用它。它使你的组件能够在 DOM 发生更改之前捕获一些信息（例如滚动的位置）。此生命周期方法返回的任何值都将作为参数传递给 <code>componentDidUpdate(props,state,snapshot?)</code>。<br> 此用法也较为罕见</li></ul></li></ul>',14)]))}const h=t(a,[["render",p]]);export{b as __pageData,h as default};
