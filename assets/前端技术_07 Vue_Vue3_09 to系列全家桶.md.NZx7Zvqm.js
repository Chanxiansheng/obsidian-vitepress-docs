import{_ as a,c as i,o as e,ae as t}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"to 系列全家桶","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/07 Vue/Vue3/09 to系列全家桶.md","filePath":"前端技术/07 Vue/Vue3/09 to系列全家桶.md"}'),l={name:"前端技术/07 Vue/Vue3/09 to系列全家桶.md"};function n(h,s,p,r,o,k){return e(),i("div",null,s[0]||(s[0]=[t(`<h1 id="to-系列全家桶" tabindex="-1">to 系列全家桶 <a class="header-anchor" href="#to-系列全家桶" aria-label="Permalink to &quot;to 系列全家桶&quot;">​</a></h1><h2 id="_1-toref" tabindex="-1">1. toRef <a class="header-anchor" href="#_1-toref" aria-label="Permalink to &quot;1. toRef&quot;">​</a></h2><ul><li>基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步，改变源属性的值将更新 ref 的值，反之亦然。</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  foo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  bar: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fooRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更改该 ref 会更新源属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fooRef.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state.foo) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更改源属性也会更新该 ref</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fooRef.value) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span></code></pre></div><ul><li><code>toRef()</code> 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用。</li><li>理解了 ref 就能理解 toRef，本质还是处理简单数据类型丢失引用的问题。</li></ul><h2 id="_2-torefs" tabindex="-1">2. toRefs <a class="header-anchor" href="#_2-torefs" aria-label="Permalink to &quot;2. toRefs&quot;">​</a></h2><ul><li><p>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 <code>toRef()</code> 创建的。<br><code>const stateAsRefs = toRefs(state)</code></p></li><li><p>适用于响应式对象的解构赋值</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {foo,bar} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div></li></ul><h2 id="_3-toraw" tabindex="-1">3. toRaw <a class="header-anchor" href="#_3-toraw" aria-label="Permalink to &quot;3. toRaw&quot;">​</a></h2><ul><li>根据一个 Vue 创建的代理返回其原始对象。</li><li><code>toRaw()</code> 可以返回由 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive" title="reactive()" target="_blank" rel="noreferrer">reactive()</a>、<a href="https://cn.vuejs.org/api/reactivity-core.html#readonly" title="readonly()" target="_blank" rel="noreferrer">readonly()</a>、<a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive" title="shallowReactive()" target="_blank" rel="noreferrer">shallowReactive()</a> 或者 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly" title="shallowReadonly()" target="_blank" rel="noreferrer">shallowReadonly()</a> 创建的代理对应的原始对象。</li><li>这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</li></ul>`,9)]))}const E=a(l,[["render",n]]);export{c as __pageData,E as default};
