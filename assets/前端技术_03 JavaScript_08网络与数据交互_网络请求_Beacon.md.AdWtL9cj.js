import{_ as s,c as e,o as i,ag as n}from"./chunks/framework.-ewJmwvT.js";const k=JSON.parse('{"title":"Beacon","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/08网络与数据交互/网络请求/Beacon.md","filePath":"前端技术/03 JavaScript/08网络与数据交互/网络请求/Beacon.md"}'),t={name:"前端技术/03 JavaScript/08网络与数据交互/网络请求/Beacon.md"};function o(l,a,p,c,r,d){return i(),e("div",null,a[0]||(a[0]=[n(`<h1 id="beacon" tabindex="-1">Beacon <a class="header-anchor" href="#beacon" aria-label="Permalink to &quot;Beacon&quot;">​</a></h1><p>为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想的情况下是通过浏览器的 unload 事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。<br> 在 unload 事件触发时，分析工具要停止收集信息并把收集到的数据发给服务器。这时候有一个问题，因为 unload 事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了）。例如，==在 unload 事件处理程序中创建的任何异步请求都会被浏览器取消。==为此，异步 <code>XMLHttpRequest</code> 或 <code>fetch()</code> 不适合这个任务。</p><p>为解决这个问题，W3C 引入了补充性的 Beacon API。这个 API 给 navigator 对象增加了一个 <code>sendBeacon()</code> 方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST 请求。</p><p>可选的数据有效载荷参数有 ArrayBufferView、Blob、DOMString、FormData 实例。如果请求成功进入了最终要发送的任务队列，则这个方法返回 true，否则返回 false。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送POST 请求</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// URL: &#39;https://example.com/analytics-reporting-url&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 请求负载：&#39;{foo: &quot;bar&quot;}&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sendBeacon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://example.com/analytics-reporting-url&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;{foo: &quot;bar&quot;}&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>这个方法虽然看起来只不过是 POST 请求的一个语法糖，但它有几个重要的特性。</p><ul><li><code>sendBeacon()</code> 并不是只能在页面生命周期末尾使用，而是任何时候都可以使用。</li><li>调用 <code>sendBeacon()</code> 后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。</li><li>浏览器保证在原始页面已经关闭的情况下也会发送请求。</li><li>状态码、超时和其他网络原因造成的失败完全是不透明的，不能通过编程方式处理。</li><li>信标（beacon）请求会携带调用 <code>sendBeacon()</code> 时所有相关的 cookie。</li></ul>`,7)]))}const u=s(t,[["render",o]]);export{k as __pageData,u as default};
