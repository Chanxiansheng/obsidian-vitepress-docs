import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.-ewJmwvT.js";const h="/obsidian-vitepress-docs/assets/Prototype%20(3).CdZy-F6A.png",p="/obsidian-vitepress-docs/assets/%E5%8E%9F%E5%9E%8B%E9%93%BE.excalidraw.DDw9VMCK.svg",l="/obsidian-vitepress-docs/assets/v2-2e8ec703287854d174483ba5f9f937cf_1440w_9rzskeke.Dvz0aihW.jpg",y=JSON.parse('{"title":"JS 面向对象与原型链","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/03对象与函数/JS面向对象与原型链.md","filePath":"前端技术/03 JavaScript/03对象与函数/JS面向对象与原型链.md"}'),e={name:"前端技术/03 JavaScript/03对象与函数/JS面向对象与原型链.md"};function k(r,s,d,E,o,c){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="js-面向对象与原型链" tabindex="-1">JS 面向对象与原型链 <a class="header-anchor" href="#js-面向对象与原型链" aria-label="Permalink to &quot;JS 面向对象与原型链&quot;">​</a></h1><p><a href="https://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></p><p><a href="https://juejin.cn/post/6844904082210045965#comment" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904082210045965#comment</a></p><p><a href="https://zhuanlan.zhihu.com/p/35790971" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/35790971</a></p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>Javascript 是一种基于对象（<code>object-based</code>）的编程语言，你遇到的所有东西几乎都是对象。与 Java、C++、C#等语言不同，它不是一种真正的面向对象编程（OOP）语言，但是，它是支持面向对象编程的。</p><p>同时，正因为 JS 基于对象的特点，每个对象都有它的原型对象（<code>prototype</code>），简称 <code>原型</code>。而原型正是 JS 能够支持面向对象的重要原因。</p><h2 id="一、创建对象" tabindex="-1">一、创建对象 <a class="header-anchor" href="#一、创建对象" aria-label="Permalink to &quot;一、创建对象&quot;">​</a></h2><p>创建对象，就是面向对象中<strong>封装</strong>的实现，即是把属性（property）和方法（method）结合成一个整体。</p><h3 id="原始方式" tabindex="-1">原始方式 <a class="header-anchor" href="#原始方式" aria-label="Permalink to &quot;原始方式&quot;">​</a></h3><p>在 JS 中，Object 对象就是<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。我们通过 Object 可以实现一种最基本的封装，我们可以通过字面量的方式进行创建。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但是，这种封装方式只能生成对应的一个实例，当我们需要创建多个时就会非常麻烦。因此，可以写一个函数，解决代码重复的问题。</p><h3 id="工厂函数方式" tabindex="-1">工厂函数方式 <a class="header-anchor" href="#工厂函数方式" aria-label="Permalink to &quot;工厂函数方式&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name:name,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>可以看出，通过函数就实现了复用，但是，&#39; 张三 &#39; 与 &#39; 李四 &#39; 之间并没有内在的联系，不能反映出它们是同一个原型的实例。</p><h3 id="构造函数方式" tabindex="-1">构造函数方式 <a class="header-anchor" href="#构造函数方式" aria-label="Permalink to &quot;构造函数方式&quot;">​</a></h3><p>为了解决从原型对象生成实例的问题，Javascript 提供了一个构造函数（Constructor）模式。</p><p>所谓 &quot; 构造函数 &quot;**，其实就是一个普通函数，但是内部使用了 this 变量。对构造函数使用 <code>new</code> 运算符，就能生成实例，并且 <code>this</code> 变量会绑定在实例对象上。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>与直接调用函数不同，<code>new</code> 关键字帮我们做了很多事情，后面会进行讲解。</p><p>通过观察，每个实例都有一个自己的 showName 方法，但是，这个方法应该需要被不同实例所复用的。那么，如何处理这个问题呢？</p><p>一个思路：我们可以把这些共用的属性和方法用一个[单独对象] 所维护，[单独对象] 是构造函数的一个属性。并且我们构造出来的所有实例需要都能访问到这个[单独对象] 的属性和方法。</p><p><code>Prototype原型对象</code> 就是 JS 为我们所设计的这个[单独对象]。</p><h2 id="二、原型对象" tabindex="-1">二、原型对象 <a class="header-anchor" href="#二、原型对象" aria-label="Permalink to &quot;二、原型对象&quot;">​</a></h2><p>Javascript 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p><p>这意味着，我们可以把那些不变的属性和方法，直接定义在 <code>prototype</code> 对象上。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><img src="`+h+'" alt=""></p><h3 id="构造函数、实例、原型三者之间的关系" tabindex="-1">构造函数、实例、原型三者之间的关系 <a class="header-anchor" href="#构造函数、实例、原型三者之间的关系" aria-label="Permalink to &quot;构造函数、实例、原型三者之间的关系&quot;">​</a></h3><ul><li>构造函数都具有一个 <code>prototype</code> 属性，该属性是一个对象（Object 或其他构造函数的实例）。</li><li>原型对象默认都有一个 <code>constructor</code> 属性，指向构造函数。</li><li>通过构造函数得到的实例对象内部会包含一个指向原型对象的指针 <code>__proto__</code>。</li><li>所有实例都直接或间接继承了原型对象的成员。</li></ul><h3 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-label="Permalink to &quot;原型链&quot;">​</a></h3><p>我们知道，Person 原型对象是 Object 或其他构造函数的实例，那么 Person 原型对象的原型对象的属性和方法也应该可以被 Person 的实例所访问，由此就产生了原型链。</p><p><img src="'+p+'" alt="D-学习笔记/前端技术/03 JavaScript/03对象与函数/image/原型链.excalidraw.svg"></p><p>显而易见，原型链是具有继承的特点，具体在第三部分讲诉。</p><p>同时，<strong>属性成员的搜索原则</strong>遵循原型链依次往上搜索：</p><ul><li>首先从对象实例本身搜索</li><li>原型对象上搜索</li><li>原型对象的原型对象上搜索</li><li>....</li><li>有则返回，无则返回 undefined</li></ul><h3 id="new-做了什么" tabindex="-1">new 做了什么？ <a class="header-anchor" href="#new-做了什么" aria-label="Permalink to &quot;new 做了什么？&quot;">​</a></h3><p>根据前面的内容铺垫，我们已经可以总结出 new 的实质过程：</p><ol><li>创建一个空对象 p <code>{}</code></li><li>将新创建的对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code><br><code>p.__proto__ = Person.prototype</code></li><li>重新绑定 this，使构造函数的 this 指向新对象<br><code>Person.call(this)</code></li><li>为新对象属性赋值 <code>p.name</code></li><li>返回 this <code>return this</code></li></ol><h2 id="三、如何实现继承" tabindex="-1">三、如何实现继承 <a class="header-anchor" href="#三、如何实现继承" aria-label="Permalink to &quot;三、如何实现继承&quot;">​</a></h2><p><img src="'+l+`" alt=""></p><h3 id="构造函数继承" tabindex="-1">构造函数继承 <a class="header-anchor" href="#构造函数继承" aria-label="Permalink to &quot;构造函数继承&quot;">​</a></h3><p>利用 call/apply 改变 this 指向，调用父类的构造函数，以实现继承父类的私有属性。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但该方法只是借用了父类的构造函数，把 this 绑到自身，因此无法将父类构造函数的原型对象上的共用属性和方法进行继承。</p><h3 id="原型继承" tabindex="-1">原型继承 <a class="header-anchor" href="#原型继承" aria-label="Permalink to &quot;原型继承&quot;">​</a></h3><p>上文提到，原型对象可以由 Object 构造，也可以由其他的构造函数构造，当子类构造函数的原型对象为父类构造函数构造的实例时，即为原型继承。可参照原型链图。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>此方法利用原型链，实现了父类原型对象属性和方法的继承，但当某些方法需要访问私有属性，会出现 undefined。</p><h3 id="组合继承" tabindex="-1">组合继承 <a class="header-anchor" href="#组合继承" aria-label="Permalink to &quot;组合继承&quot;">​</a></h3><p>组合继承就是结合使用构造函数继承与原型继承。</p><h2 id="四、es6-class-语法糖" tabindex="-1">四、ES6 Class 语法糖 <a class="header-anchor" href="#四、es6-class-语法糖" aria-label="Permalink to &quot;四、ES6 Class 语法糖&quot;">​</a></h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。</p><p>基本上，ES6 的 <code>class</code> 可以看作只是一个语法糖，相当于把构造函数和其原型对象写成一个整体。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Man</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h3><p><code>constructor()</code> 方法相当于构造函数，是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有 <code>constructor()</code> 方法，如果没有显式定义，一个空的 <code>constructor()</code> 方法会被默认添加。</p><p>而 class 中其余的属性和方法会被自动添加到原型对象上，如果没有继承，默认原型对象是 Object 构造的。</p><h3 id="静态方法-static" tabindex="-1">静态方法 Static <a class="header-anchor" href="#静态方法-static" aria-label="Permalink to &quot;静态方法 Static&quot;">​</a></h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><h3 id="私有方法和私有属性-es2022" tabindex="-1">私有方法和私有属性 (ES2022) <a class="header-anchor" href="#私有方法和私有属性-es2022" aria-label="Permalink to &quot;私有方法和私有属性 (ES2022)&quot;">​</a></h3><p>私有属性/方法是在属性名之前使用 <code>#</code> 表示。私有属性只能在类的内部使用，如果在类的外部使用，就会报错。</p><h3 id="class-继承" tabindex="-1">Class 继承 <a class="header-anchor" href="#class-继承" aria-label="Permalink to &quot;Class 继承&quot;">​</a></h3><p>Class 可以通过 <code>extends</code> 关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的继承，要清晰和方便很多。</p><p>ES6 规定，子类必须在 <code>constructor()</code> 方法中调用 <code>super()</code>，否则就会报错。</p><p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p><h3 id="类的-prototype-属性和-proto-属性" tabindex="-1">类的 prototype 属性和__proto__ 属性 <a class="header-anchor" href="#类的-prototype-属性和-proto-属性" aria-label="Permalink to &quot;类的 prototype 属性和\\_\\_proto\\_\\_ 属性&quot;">​</a></h3><p>大多数浏览器的 ES5 实现之中，每一个对象都有 <code>__proto__</code> 属性，指向对应的构造函数的 <code>prototype</code> 属性。Class 作为构造函数的语法糖，同时有 <code>prototype</code> 属性和 <code>__proto__</code> 属性，因此同时存在两条继承链。</p><p>（1）子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性。</p><h3 id="取值函数-getter-和存值函数-setter" tabindex="-1">取值函数（getter）和存值函数（setter） <a class="header-anchor" href="#取值函数-getter-和存值函数-setter" aria-label="Permalink to &quot;取值函数（getter）和存值函数（setter）&quot;">​</a></h3><p>从 ES5 开发，提供了 <code>getter</code> 和 <code>setter</code> 可以将属性值的获取和设置分别绑定到方法上，称之为“存取器”。有了 getter 和 setter 我们就能够在属性值的变更和获取时实现一些操作。</p><p>getter: 一个无参有返回的函数，用于读取属性</p><p>setter: 一个有参无返回的函数，用于存取或者修改属性</p><p>如何在已有的对象上添加 getter 和 setter 呢？</p><ul><li><p>方法一：使用 defineProperty<br> Object.defineProperty(obj, prop, descriptor) ，obj 为将要操作的对象，prop 是将要定义或者修改的属性名，descriptor 是将要被修改或者定义的描述符。</p></li><li><p>方法二 (ES5)：<br> 在“类”的内部可以使用 <code>get</code> 和 <code>set</code> 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;getter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  set</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setter: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul>`,77)]))}const F=i(e,[["render",k]]);export{y as __pageData,F as default};
