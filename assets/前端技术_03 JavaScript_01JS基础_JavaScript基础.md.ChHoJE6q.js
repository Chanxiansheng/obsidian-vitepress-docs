import{_ as i,c as s,o as a,ag as e}from"./chunks/framework.-ewJmwvT.js";const c=JSON.parse('{"title":"JavaScript 基础","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/01JS基础/JavaScript基础.md","filePath":"前端技术/03 JavaScript/01JS基础/JavaScript基础.md"}'),l={name:"前端技术/03 JavaScript/01JS基础/JavaScript基础.md"};function n(d,t,h,r,p,o){return a(),s("div",null,t[0]||(t[0]=[e(`<h1 id="javascript-基础" tabindex="-1">JavaScript 基础 <a class="header-anchor" href="#javascript-基础" aria-label="Permalink to &quot;JavaScript 基础&quot;">​</a></h1><h2 id="基础语法" tabindex="-1">基础语法 <a class="header-anchor" href="#基础语法" aria-label="Permalink to &quot;基础语法&quot;">​</a></h2><ul><li><p>区分大小写</p></li><li><p>标识符（变量、函数、属性或函数参数的名称）的组成遵循以下规则：</p><ul><li>第一个字符必须是一个字母、下划线（<code>_</code>）或美元符号（<code>$</code>）；</li><li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li><li>标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符。</li><li>按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，如 <code>firstSecond</code>、<code>myCar</code></li></ul></li><li><p>ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。</p><ul><li>单行注释以两个斜杠字符开头，如： <code>// 单行注释</code></li><li>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：<br><code>/* 这是多行</code><br><code>注释 */</code></li></ul></li><li><p>ECMAScript 5 增加了严格模式（strict mode）的概念，如需开启，需要在脚本开头添加 <code>&quot;use strict&quot;</code></p></li><li><p>ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p></li><li><p>关键字</p></li></ul><table tabindex="0"><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>break</td><td>do</td><td>in</td><td>typeof</td></tr><tr><td>case</td><td>else</td><td>instanceof</td><td>var</td></tr><tr><td>catch</td><td>export</td><td>new</td><td>void</td></tr><tr><td>class</td><td>extends</td><td>return</td><td>while</td></tr><tr><td>const</td><td>finally</td><td>super</td><td>with</td></tr><tr><td>continue</td><td>for</td><td>switch</td><td>yield</td></tr><tr><td>debugger</td><td>function</td><td>this</td><td></td></tr><tr><td>default</td><td>if</td><td>throw</td><td></td></tr><tr><td>delete</td><td>import</td><td>try</td><td></td></tr></tbody></table><ul><li>保留字 <ul><li>始终保留: <code>enum</code></li><li>严格模式下保留:<code>implements</code> 、<code>package</code> 、<code>publicinterface</code> 、<code>protected</code> 、<code>static</code>、 <code>let</code>、 <code>private</code></li><li>模块代码中保留: <code>await</code></li></ul></li></ul><h2 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-label="Permalink to &quot;变量声明&quot;">​</a></h2><p><strong>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。</strong> 每个变量只不过是一<br> 个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：<code>var</code>、<code>const</code> 和 <code>let</code>。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</p><h3 id="var-声明" tabindex="-1">var 声明 <a class="header-anchor" href="#var-声明" aria-label="Permalink to &quot;var 声明&quot;">​</a></h3><p><code>var message</code><br> var 操作符定义的变量会成为包含它的函数的局部变量。（函数作用域）<br> var 声明的变量会自动提升到函数作用域顶部，这会导致无法检测出变量的重复声明。</p><h3 id="let-声明" tabindex="-1">let 声明 <a class="header-anchor" href="#let-声明" aria-label="Permalink to &quot;let 声明&quot;">​</a></h3><p><code>let message</code></p><ul><li>let 声明的范围是块作用域。</li><li>let 声明的变量不会在作用域中被提升。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。</li><li>let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</li><li>使用 var 的 for 循环定义的迭代变量会渗透到循环体外部；改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部。</li></ul><h3 id="const-声明" tabindex="-1">const 声明 <a class="header-anchor" href="#const-声明" aria-label="Permalink to &quot;const 声明&quot;">​</a></h3><p><code>const message</code><br> const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。</p><h3 id="typeof-操作符" tabindex="-1">typeof 操作符 <a class="header-anchor" href="#typeof-操作符" aria-label="Permalink to &quot;typeof 操作符&quot;">​</a></h3><p><code>typeof(x)</code> <code>typeof x</code><br> typeof 可以用于确定任意变量的数据类型。</p><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">typeof 返回值</th><th style="text-align:left;">对象包装器</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>NaN</strong></td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;"><strong>Null</strong></td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;"><strong>Undefined</strong></td><td style="text-align:left;"><code>undefined</code></td><td style="text-align:left;">N/A</td></tr><tr><td style="text-align:left;">Boolean</td><td style="text-align:left;"><code>boolean</code></td><td style="text-align:left;">Boolean</td></tr><tr><td style="text-align:left;">Number</td><td style="text-align:left;"><code>number</code></td><td style="text-align:left;">Number</td></tr><tr><td style="text-align:left;">BigInt</td><td style="text-align:left;"><code>bigint</code></td><td style="text-align:left;">BigInt</td></tr><tr><td style="text-align:left;">String</td><td style="text-align:left;"><code>string</code></td><td style="text-align:left;">String</td></tr><tr><td style="text-align:left;">Symbol</td><td style="text-align:left;"><code>symbol</code></td><td style="text-align:left;">Symbol</td></tr><tr><td style="text-align:left;">Function</td><td style="text-align:left;"><code>function</code></td><td style="text-align:left;">Function</td></tr><tr><td style="text-align:left;">Object、Array 等</td><td style="text-align:left;"><code>object</code></td><td style="text-align:left;">对应的引用数据类型</td></tr></tbody></table><p>注意：null 返回的是 object；函数返回的是 function，即使是一种特殊的 object。</p><h3 id="undefined-类型" tabindex="-1">Undefined 类型 <a class="header-anchor" href="#undefined-类型" aria-label="Permalink to &quot;Undefined 类型&quot;">​</a></h3><p>Undefined 类型只有一个值，就是特殊值 undefined。<br> 当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值</p><h3 id="null-类型" tabindex="-1">Null 类型 <a class="header-anchor" href="#null-类型" aria-label="Permalink to &quot;Null 类型&quot;">​</a></h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给<br> typeof 传一个 null 会返回 &quot;object&quot; 的原因。</p><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查<br> 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p><p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为<strong>表面上相等</strong>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">trueconsole.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span></code></pre></div><h3 id="boolean-类型" tabindex="-1">Boolean 类型 <a class="header-anchor" href="#boolean-类型" aria-label="Permalink to &quot;Boolean 类型&quot;">​</a></h3><p>Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。</p><div class="tip custom-block github-alert"><p class="custom-block-title">+ 注意</p><p>布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False 是有效的标识符，但不是布尔值。</p></div><p>所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。<code>Boolean()</code> 函数可以将其他类型转为布尔类型。不同类型与布尔值之间的转换规则：</p><table tabindex="0"><thead><tr><th>数据类型</th><th>转换为 true 的值</th><th>转换为 false 的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>&quot;&quot;（空字符串）</td></tr><tr><td>Number</td><td>非零数值（包括无穷值）</td><td>0、NaN</td></tr><tr><td>Object</td><td>任意对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A（不存在）</td><td>undefined</td></tr></tbody></table><h3 id="number-类型" tabindex="-1">Number 类型 <a class="header-anchor" href="#number-类型" aria-label="Permalink to &quot;Number 类型&quot;">​</a></h3><p>Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><ul><li>十进制：最基本的数值字面量格式是十进制整数，直接写出来即可。</li><li>八进制：前缀 0o、0，然后是相应的八进制数字（数值 0~7）。前缀 0 在严格模式不可用。</li><li>十六进制：前缀 0x，然后是十六进制数字（0~9 以及 A~F）。十六进制数字中的字母大小写均可。</li></ul><ol><li><p>浮点值<br> 定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。<br> 对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> floatNum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.125e7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等于31250000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> floatNumSmall </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3e-17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等于0.000 000 000 000 000 03</span></span></code></pre></div></li><li><p>值的范围<br> 最小数值：Number.MIN_VALUE ，多数浏览器中是 5e-324；<br> 最大数值：Number.MAX_VALUE，多数浏览器中是 1.797 693 134 862 315 7e+308。</p><p>如果超过最大或小于最小值，则会用 -Infinity（负无穷大）、Infinity（正无穷大）表示。</p><p>要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 <code>isFinite()</code> 函数。</p></li><li><p>数字分隔符<br> 可以使用下划线（_）作为数字分隔符以增加可读性，解释器会忽略它们。如 <code>1_000_000_000</code></p></li><li><p>NaN<br> NaN，意思是“不是数值”（Not a Number）用于表示本来要返回数值的操作失败了（而不是抛出错误）。<br> 任何涉及 NaN 的操作始终返回 NaN。<br> NaN 不等于包括 NaN 在内的任何值。<code>NaN == NaN //false</code>。为此，<code>isNaN()</code> 函数可用于判断一个数是否为 NaN。</p></li><li><p>数值转换<br> 有 3 个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code> 和 <code>parseFloat()</code>。</p></li></ol><blockquote><p>[!hint]+ Number 函数<br><code>Number()</code> 是转型函数，可用于任何数据类型，基于如下规则执行转换：</p><ul><li>布尔值，true 转换为 1，false 转换为 0。</li><li>数值，直接返回。</li><li>null，返回 0。</li><li>undefined，返回 NaN。</li><li>字符串，应用以下规则： <ul><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。</li><li>如果字符串包含有效的浮点值格式如 &quot;1.1&quot;，则会转换为相应的浮点值。</li><li>如果字符串包含有效的十六进制格式如 &quot;0xf&quot;，则会转换对应的十进制整数值。</li><li>如果是空字符串（不包含字符），则返回 0。</li><li>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</li></ul></li><li>对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString() 方法，再按照转换字符串的规则转换。</li></ul></blockquote><blockquote><p>[!hint]+ parseInt 函数<br><code>parseInt()</code> 函数更专注于字符串是否包含数值模式。</p><ul><li>字符串最前面的空格会被忽略，从第一个非空格字符开始转换。</li><li>如果第一个字符不是数值字符、加号或减号，parseInt() 立即返回 NaN。这意味着空字符串也会返回 NaN。</li><li>如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</li><li><strong>parseInt() 也接收第二个参数，用于指定底数（进制数）</strong>。因此在配合 Map 函数时需要特别注意参数。</li></ul></blockquote><blockquote><p>[!hint]+ parseFloat 函数<br><code>parseFloat()</code> 函数的工作方式跟 parseInt() 函数类似，都是从位置 0 开始检测每个字符。<br> 同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。<br> parseFloat() 只解析十进制值。</p></blockquote><h3 id="bigint-类型" tabindex="-1">BigInt 类型 <a class="header-anchor" href="#bigint-类型" aria-label="Permalink to &quot;BigInt 类型&quot;">​</a></h3><p>BigInt 这种原始数据类型用于处理超过 Number.MAX_SAFE_INTEGER 的大整数。引擎会在内存中分配一个对象来表示，而不再使用 IEEE75464 位格式。BigInt 都是有符号整数。</p><p>要创建 BigInt 数值，可以在任意数值字面量末尾添加“n”，也可以使用 <code>BigInt()</code> 函数，BigInt() 函数接收一个数值字面量（或数字字符串），可以是不同进制的数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bigintA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123456</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bigintB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BigInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123456</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>普通整数值与 BigInt 格式可以相互转换，但是会丢失精度。</p><p>BigInt 支持几乎所有 Number 类型使用的算术、一元和位操作符。</p><p>BigInt 有两个静态方法：asIntN 和 asUintN，用于限制整数不越界。<br><code>BigInt.asIntN(bits, bigint)</code> 截短到有符号整数<br><code>BigInt.asUintN(bits, bigint)</code> 截短到无符号整数</p><p>BigInt 不支持 JSON 序列化，但可以使用 JSON 的全局方法接受 replacer 和 reviver 参数，实现序列化。</p><h3 id="string-类型" tabindex="-1">String 类型 <a class="header-anchor" href="#string-类型" aria-label="Permalink to &quot;String 类型&quot;">​</a></h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（&quot;）、单引号（&#39;）或反引号（\`）标示。<br> 字符串的长度可以通过其 length 属性获取。</p><ol><li><p>字符字面量<br> 字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table tabindex="0"><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\\n</td><td>换行</td></tr><tr><td>\\t</td><td>制表</td></tr><tr><td>\\b</td><td>退格</td></tr><tr><td>\\r</td><td>回车</td></tr><tr><td>\\f</td><td>换页</td></tr><tr><td>\\</td><td>反斜杠（\\）</td></tr><tr><td>&#39;</td><td>单引号（&#39;）</td></tr><tr><td>&quot;</td><td>双引号（&quot;）</td></tr><tr><td>\`</td><td>反引号（\`）</td></tr><tr><td>\\xnn</td><td>以十六进制编码 nn 表示的字符</td></tr><tr><td>\\unnnn</td><td>以十六进制编码 nnnn 表示的 Unicode 字符</td></tr></tbody></table></li><li><p>字符串的特点<br><strong>字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。</strong> 要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p></li><li><p>转换为字符串<br> 方法一：<code>toString()</code>：返回当前值的字符串等价物。toString() 方法可见于数值、布尔值、对象和字符串值。null 返回 &quot;null&quot;，undefined 返回“undefined”。<br> 方法二：用加号操作符给一个值加上一个空字符串 &quot;&quot; 也可以将其转换为字符串。</p></li><li><p>模板字面量<br> ES6 的用法，反引号（\`）包裹。<br> 模板字面量支持字符串插值，通过在 <code>\${}</code> 嵌入任何 JavaScript 表达式。</p></li></ol><blockquote><p>[!tips]+ 标签函数<br> 模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。<br> 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">strings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">aValExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">bValExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sumExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(strings);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(aValExpression);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bValExpression);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sumExpression);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foobar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> untaggedResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> } + \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> } = \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> taggedResult </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simpleTag</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> } + \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> } = \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> }\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 9</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 15</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(untaggedResult); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;6 + 9 = 15&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(taggedResult); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;foobar&quot;</span></span></code></pre></div><p>可以使用默认的 <code>String.raw</code> 标签函数获取原始的模板字面量内容。</p></blockquote><h3 id="symbol-类型" tabindex="-1">Symbol 类型 <a class="header-anchor" href="#symbol-类型" aria-label="Permalink to &quot;Symbol 类型&quot;">​</a></h3><p>Symbol（符号）是 ECMAScript 6 新增的数据类型。Symbol 是原始数据类型，且 Symbol 实例是唯一、不可变的。 Symbol 的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><ol><li><p>基本用法<br> 使用 <code>Symbol()</code> 函数初始化，可以传入一个字符串参数作为对符号的描述，两个同样的参数生成的 Symbol 仍然是不一样的。<br><strong>为了避免创建符号包装对象，Symbol() 函数不能与 new 关键字一起作为构造函数使用。</strong></p></li><li><p>使用全局符号注册表<br> 使用 <code>Symbol.for()</code> 可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br> 第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。<br> 使用 <code>Symbol.keyFor()</code> 来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 undefined。</p></li><li><p>作为属性<br> 凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 <code>Object.defineProperty()</code>/<code>Object.defineProperties()</code> 定义的属性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">o[s] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo val&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o, s, {value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar val&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [s]: {value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;baz val&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p>常用内置符号<br> ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。所有内置符号属性都是不可写、不可枚举、不可配置的。</p></li></ol><table tabindex="0"><thead><tr><th>Symbol</th><th>描述</th><th>关联方法/操作</th></tr></thead><tbody><tr><td><code>Symbol.iterator</code></td><td>对象默认的迭代器</td><td><code>for-of</code></td></tr><tr><td><code>Symbol.asyncIterator</code></td><td>对象默认的异步迭代器</td><td><code>for-await-of</code></td></tr><tr><td><code>Symbol.hasInstance</code></td><td>决定一个构造器对象是否认可一个对象是它的实例</td><td><code>instanceof</code> 操作符</td></tr><tr><td><code>Symbol.isConcatSpreadable</code></td><td>能否打平其数组元素</td><td><code>Array.prototype.concat()</code></td></tr><tr><td><code>Symbol.match</code></td><td>用正则表达式去匹配字符串。</td><td><code>String.prototype.match()</code></td></tr><tr><td><code>Symbol.replace</code></td><td>替换一个字符串中匹配的子串。</td><td><code>String.prototype.replace()</code></td></tr><tr><td><code>Symbol.search</code></td><td>返回字符串中匹配正则表达式的索引</td><td><code>String.prototype.search()</code></td></tr><tr><td><code>Symbol.split</code></td><td>匹配正则表达式的索引位置拆分字符串</td><td><code>String.prototype.split()</code></td></tr><tr><td><code>Symbol.species</code></td><td>表示一个函数值，该函数作为创建派生对象的构造函数。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。</td><td>作为创建派生对象的构造函数</td></tr><tr><td><code>Symbol.toPrimitive</code></td><td>表示一个方法，该方法将对象转换为相应的原始值</td><td><code>ToPrimitive()</code></td></tr><tr><td><code>Symbol.toStringTag</code></td><td>表示一个字符串，该字符串用于创建对象的默认字符串描述</td><td><code>Object.prototype.toString()</code></td></tr></tbody></table><h3 id="object-类型" tabindex="-1">Object 类型 <a class="header-anchor" href="#object-类型" aria-label="Permalink to &quot;Object 类型&quot;">​</a></h3><p>对象是一组数据和功能的集合，通过 new 操作符创建。<br><code>let o = new Object()</code><br> 每个 object 实例都有如下的属性和方法：</p><ul><li>constructor：构造函数</li><li>hasOwnProperty(propertyName)：判断实例上是否有给定的属性</li><li>isPrototypeOf(object)：判断当前对象是否为另一个对象的原型</li><li>propertyIsEnumerable(propertyName)：判断给定属性是否可枚举（for-in）</li><li>toLocaleString()：返回对象的字符串表示（本地执行环境）</li><li>toString()：返回对象的字符串表示</li><li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同。</li></ul><h2 id="操作符" tabindex="-1">操作符 <a class="header-anchor" href="#操作符" aria-label="Permalink to &quot;操作符&quot;">​</a></h2><h3 id="一元操作符" tabindex="-1">一元操作符 <a class="header-anchor" href="#一元操作符" aria-label="Permalink to &quot;一元操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>++</td><td>先或后递增</td></tr><tr><td>--</td><td>先或后递减</td></tr><tr><td>+</td><td>一元加（转换为数值）</td></tr><tr><td>-</td><td>一元减（转换为数值相应的负值）</td></tr></tbody></table><ol><li>递增和递减操作符有前缀版和后缀版，前缀先执行自加或自减操作，然后返回对应数值；后缀版本先返回数值，然后执行操作。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ,m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre></div><h3 id="位操作符" tabindex="-1">位操作符 <a class="header-anchor" href="#位操作符" aria-label="Permalink to &quot;位操作符&quot;">​</a></h3><p>位操作符用于操作内存中表示数据的比特（位）。<br> 有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。</p><p>负值以补码的二进制编码存储。一个数值的补码通过如下 3 个步骤计算得到：</p><ol><li>确定绝对值的二进制表示（如，对于 -18，先确定 18 的二进制表示）</li><li>找到数值的反码（全部比特进行位非操作）</li><li>给结果加 1。</li></ol><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>~</td><td>按位非</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>有符号右移</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号右移</td></tr></tbody></table><h3 id="布尔操作符" tabindex="-1">布尔操作符 <a class="header-anchor" href="#布尔操作符" aria-label="Permalink to &quot;布尔操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>||</td><td>逻辑或</td></tr></tbody></table><ol><li><p>逻辑非操作符会遵循如下规则：</p><ul><li>如果操作数是对象，则返回 false。</li><li>如果操作数是空字符串，则返回 true。</li><li>如果操作数是非空字符串，则返回 false。</li><li>如果操作数是数值 0，则返回 true。</li><li>如果操作数是非 0 数值（包括 Infinity），则返回 false。</li><li>如果操作数是 null，则返回 true。</li><li>如果操作数是 NaN，则返回 true。</li><li>如果操作数是 undefined，则返回 true。</li></ul></li><li><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。逻辑与并不一定会返回布尔值，而是遵循如下规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数。</li><li>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</li><li>如果两个操作数都是对象，则返回第二个操作数。</li><li>如果有一个操作数是 null，则返回 null。</li><li>如果有一个操作数是 NaN，则返回 NaN。</li><li>如果有一个操作数是 undefined，则返回 undefined。</li></ul></li><li><p>逻辑或操作符也具有短路的特性。</p></li></ol><h3 id="乘性操作符" tabindex="-1">乘性操作符 <a class="header-anchor" href="#乘性操作符" aria-label="Permalink to &quot;乘性操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>取模</td></tr></tbody></table><h3 id="指数操作符" tabindex="-1">指数操作符 <a class="header-anchor" href="#指数操作符" aria-label="Permalink to &quot;指数操作符&quot;">​</a></h3><p>ECMAScript 7 新增了指数操作符（<code>**</code>），相当于 <code>Math.pow()</code></p><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>**</td><td>幂</td></tr></tbody></table><h3 id="加性操作符" tabindex="-1">加性操作符 <a class="header-anchor" href="#加性操作符" aria-label="Permalink to &quot;加性操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>+</td><td>加法、字符串拼接</td></tr><tr><td>-</td><td>减法</td></tr></tbody></table><h3 id="关系操作符" tabindex="-1">关系操作符 <a class="header-anchor" href="#关系操作符" aria-label="Permalink to &quot;关系操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>&lt;, &lt;=, &gt;, &gt;=</td><td>按数值顺序比较</td></tr><tr><td>&lt;, &lt;=, &gt;, &gt;=</td><td>按字母表顺序比较</td></tr></tbody></table><p>比较规则：</p><ul><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li><li>如果有任一操作数是对象，则调用其 valueOf() 方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf() 操作符，则调用 toString() 方法，取得结果后再根据前面的规则执行比较。</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ul><h3 id="相等操作符" tabindex="-1">相等操作符 <a class="header-anchor" href="#相等操作符" aria-label="Permalink to &quot;相等操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>===</td><td>全等</td></tr><tr><td>!==</td><td>不全等</td></tr></tbody></table><ol><li><p>等于和不等于这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ul><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法取得其原始值，再根据前面的规则进行比较。在进行比较时，这两个操作符会遵循如下规则： <ul><li>null 和 undefined 相等。</li><li>null 和 undefined 不能转换为其他类型的值再进行比较。</li><li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</li></ul></li></ul></li><li><p>全等和不全等在比较相等时不转换操作数。</p></li></ol><h3 id="条件操作符" tabindex="-1">条件操作符 <a class="header-anchor" href="#条件操作符" aria-label="Permalink to &quot;条件操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>？:</td><td>三元判断</td></tr></tbody></table><h3 id="空值合并操作符" tabindex="-1">空值合并操作符 <a class="header-anchor" href="#空值合并操作符" aria-label="Permalink to &quot;空值合并操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>??</td><td>空值合并</td></tr></tbody></table><p>如果左边的操作数是 null 或 undefined 时，它就返回右边的操作数。以前一般使用（||）。<br><code>variable = experssion ?? nullish_fallback_value</code></p><h3 id="赋值操作符" tabindex="-1">赋值操作符 <a class="header-anchor" href="#赋值操作符" aria-label="Permalink to &quot;赋值操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>=</td><td>为变量或属性赋值</td></tr><tr><td><code>**=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>+=</code>, <code>-=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code></td><td>操作并赋值</td></tr></tbody></table><h3 id="逗号操作符" tabindex="-1">逗号操作符 <a class="header-anchor" href="#逗号操作符" aria-label="Permalink to &quot;逗号操作符&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>,</td><td>丢弃第一个操作数，返回第二个</td></tr></tbody></table><h2 id="语句" tabindex="-1">语句 <a class="header-anchor" href="#语句" aria-label="Permalink to &quot;语句&quot;">​</a></h2><h3 id="if-语句" tabindex="-1">if 语句 <a class="header-anchor" href="#if-语句" aria-label="Permalink to &quot;if 语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (condition) statement1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> statement2</span></span></code></pre></div><h3 id="do-while-语句" tabindex="-1">do-while 语句 <a class="header-anchor" href="#do-while-语句" aria-label="Permalink to &quot;do-while 语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">statement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (expression);</span></span></code></pre></div><h3 id="while-语句" tabindex="-1">while 语句 <a class="header-anchor" href="#while-语句" aria-label="Permalink to &quot;while 语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expression) statement</span></span></code></pre></div><h3 id="for-语句" tabindex="-1">for 语句 <a class="header-anchor" href="#for-语句" aria-label="Permalink to &quot;for 语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (initialization; expression; post</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expression) statement</span></span></code></pre></div><h3 id="for-in-语句" tabindex="-1">for-in 语句 <a class="header-anchor" href="#for-in-语句" aria-label="Permalink to &quot;for-in 语句&quot;">​</a></h3><p>for-in 语句是一种严格的迭代语句，<strong>用于枚举对象中的非符号键属性</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (property </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expression) statement</span></span></code></pre></div><h3 id="for-of-语句" tabindex="-1">for-of 语句 <a class="header-anchor" href="#for-of-语句" aria-label="Permalink to &quot;for-of 语句&quot;">​</a></h3><p>for-of 语句是一种严格的迭代语句，<strong>用于遍历可迭代对象的元素</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (property </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expression) statement</span></span></code></pre></div><h3 id="标签语句" tabindex="-1">标签语句 <a class="header-anchor" href="#标签语句" aria-label="Permalink to &quot;标签语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: statement</span></span></code></pre></div><h3 id="break-和-continue-语句" tabindex="-1">break 和 continue 语句 <a class="header-anchor" href="#break-和-continue-语句" aria-label="Permalink to &quot;break 和 continue 语句&quot;">​</a></h3><p>break 语句用于立即退出循环，强制执行循环后的下一条语句。<br> continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><h3 id="with-语句" tabindex="-1">with 语句 <a class="header-anchor" href="#with-语句" aria-label="Permalink to &quot;with 语句&quot;">​</a></h3><p>with 语句的用途是将代码作用域设置为特定的对象</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (expression) statement;</span></span></code></pre></div><p>严格模式不允许使用 with 语句，否则会抛出错误。</p><h3 id="switch-语句" tabindex="-1">switch 语句 <a class="header-anchor" href="#switch-语句" aria-label="Permalink to &quot;switch 语句&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (expression) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value1:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  	statement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value2:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  statement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value3:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		statement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value4:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		statement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  statement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> functionName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,...,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  statements</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>不指定返回值的函数实际上会返回特殊值 undefined。</p>`,122)]))}const E=i(l,[["render",n]]);export{c as __pageData,E as default};
