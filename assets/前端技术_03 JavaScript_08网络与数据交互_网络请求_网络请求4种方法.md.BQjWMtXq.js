import{_ as d,C as h,c as p,o as r,ae as n,j as t,G as e,w as a,a as l}from"./chunks/framework.CIivgcbp.js";const k="/obsidian-vitepress-docs/assets/image_cucEOlsiUL.Cf4Lc-Oe.png",q=JSON.parse('{"title":"网络请求 4 种方法","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/08网络与数据交互/网络请求/网络请求4种方法.md","filePath":"前端技术/03 JavaScript/08网络与数据交互/网络请求/网络请求4种方法.md"}'),g={name:"前端技术/03 JavaScript/08网络与数据交互/网络请求/网络请求4种方法.md"},y={tabindex:"0"},o={style:{"text-align":"center"}},E={style:{"text-align":"center"}},x={style:{"text-align":"center"}},c={style:{"text-align":"center"}},f={style:{"text-align":"center"}},u={style:{"text-align":"center"}};function F(A,s,b,m,C,D){const i=h("font");return r(),p("div",null,[s[25]||(s[25]=n('<h1 id="网络请求-4-种方法" tabindex="-1">网络请求 4 种方法 <a class="header-anchor" href="#网络请求-4-种方法" aria-label="Permalink to &quot;网络请求 4 种方法&quot;">​</a></h1><p>ref: <a href="https://juejin.cn/post/6844903469896171533#heading-0" title="https://juejin.cn/post/6844903469896171533#heading-0" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903469896171533#heading-0</a></p><h2 id="ajax-总结表" tabindex="-1">AJAX 总结表 <a class="header-anchor" href="#ajax-总结表" aria-label="Permalink to &quot;AJAX 总结表&quot;">​</a></h2>',3)),t("table",y,[s[24]||(s[24]=t("thead",null,[t("tr",null,[t("th",null,"功能点"),t("th",{style:{"text-align":"center"}},"XHR"),t("th",{style:{"text-align":"center"}},"Fetch")])],-1)),t("tbody",null,[s[18]||(s[18]=t("tr",null,[t("td",null,"基本的请求功能"),t("td",{style:{"text-align":"center"}},"√"),t("td",{style:{"text-align":"center"}},"√")],-1)),s[19]||(s[19]=t("tr",null,[t("td",null,"基本的获取响应能力"),t("td",{style:{"text-align":"center"}},"√"),t("td",{style:{"text-align":"center"}},"√")],-1)),t("tr",null,[s[1]||(s[1]=t("td",null,"监控请求进度",-1)),s[2]||(s[2]=t("td",{style:{"text-align":"center"}},"√",-1)),t("td",o,[e(i,{color:"#ff0000"},{default:a(()=>s[0]||(s[0]=[l("×")])),_:1,__:[0]})])]),s[20]||(s[20]=t("tr",null,[t("td",null,"监控响应进度"),t("td",{style:{"text-align":"center"}},"√"),t("td",{style:{"text-align":"center"}},"√")],-1)),t("tr",null,[s[4]||(s[4]=t("td",null,"Service Worker 中是否可用",-1)),t("td",E,[e(i,{color:"#ff0000"},{default:a(()=>s[3]||(s[3]=[l("×")])),_:1,__:[3]})]),s[5]||(s[5]=t("td",{style:{"text-align":"center"}},"√",-1))]),t("tr",null,[s[7]||(s[7]=t("td",null,"精细控制 cookie 的携带",-1)),t("td",x,[e(i,{color:"#ff0000"},{default:a(()=>s[6]||(s[6]=[l("×")])),_:1,__:[6]})]),s[8]||(s[8]=t("td",{style:{"text-align":"center"}},"√",-1))]),t("tr",null,[s[10]||(s[10]=t("td",null,"控制重定向",-1)),t("td",c,[e(i,{color:"#ff0000"},{default:a(()=>s[9]||(s[9]=[l("×")])),_:1,__:[9]})]),s[11]||(s[11]=t("td",{style:{"text-align":"center"}},"√",-1))]),s[21]||(s[21]=t("tr",null,[t("td",null,"请求取消"),t("td",{style:{"text-align":"center"}},"√"),t("td",{style:{"text-align":"center"}},"√")],-1)),t("tr",null,[s[13]||(s[13]=t("td",null,"自定义 referrer",-1)),t("td",f,[e(i,{color:"#ff0000"},{default:a(()=>s[12]||(s[12]=[l("×")])),_:1,__:[12]})]),s[14]||(s[14]=t("td",{style:{"text-align":"center"}},"√",-1))]),t("tr",null,[s[16]||(s[16]=t("td",null,"流",-1)),t("td",u,[e(i,{color:"#ff0000"},{default:a(()=>s[15]||(s[15]=[l("×")])),_:1,__:[15]})]),s[17]||(s[17]=t("td",{style:{"text-align":"center"}},"√",-1))]),s[22]||(s[22]=t("tr",null,[t("td",null,"API 风格"),t("td",{style:{"text-align":"center"}},"Event"),t("td",{style:{"text-align":"center"}},"Promise")],-1)),s[23]||(s[23]=t("tr",null,[t("td",null,"活跃度"),t("td",{style:{"text-align":"center"}},"停止更新"),t("td",{style:{"text-align":"center"}},"不断更新")],-1))])]),s[26]||(s[26]=n(`<hr><h2 id="一、什么是-ajax" tabindex="-1">一、什么是 AJAX <a class="header-anchor" href="#一、什么是-ajax" aria-label="Permalink to &quot;一、什么是 AJAX&quot;">​</a></h2><p>Ajax 全称 Asynchronous JavaScript and XML，是一种<strong>技术统称</strong>，以实现与服务器进行少量的数据交换，进行页面的局部动态刷新，而无需重载整个页面。</p><ul><li>工作原理： <ol><li>为将要发生的网络请求创建了新的 http 请求线程，并监听返回。</li><li>（后端）返回了一个 JSON 或 XML 格式的数据。</li><li>Js 引擎把设置好的回调函数添加入任务队列</li><li>执行回调函数，对数据的解析与应用</li><li>GUI 渲染线程进行 UI 重绘 (repaint) 或者回流 (reflow)，对页面进行局部更新。</li></ol></li><li>实现方法总体分为两种： <ol><li>以 XmlHttpRequest 为基础的 API，在其上拓展的有 JQuery Ajax、Axios。</li><li>Fetchs</li></ol></li></ul><h2 id="二、xmlhttprequest" tabindex="-1">二、XMLHttpRequest <a class="header-anchor" href="#二、xmlhttprequest" aria-label="Permalink to &quot;二、XMLHttpRequest&quot;">​</a></h2><p>JS 实现 AJAX 的一个对象/模块。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建一个xhr实例对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> xhr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XMLHttpRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>一个 xhr 实例对象拥有 10 个普通属性 +9 个方法，且均来自它的原型对象上。</p><p><img src="`+k+`" alt=""></p><h3 id="_1、主要-api" tabindex="-1">1、主要 API <a class="header-anchor" href="#_1、主要-api" aria-label="Permalink to &quot;1、主要 API&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">API</th><th style="text-align:left;">作用</th><th style="text-align:center;">类型</th></tr></thead><tbody><tr><td style="text-align:left;">onreadystatechange⭐</td><td style="text-align:left;">在 readystate 状态改变时触发，一个周期会被触发 4 次。默认会传入 Event 实例。用以处理服务端返回结果。</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">onloadstart</td><td style="text-align:left;">readyState1 状态之后，readyState2 状态之前触发。默认传入 ProgressEvent 事件进度对象</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">onprogress</td><td style="text-align:left;">readyState3 状态时开始触发。默认传入 ProgressEvent 事件进度对象</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">status⭐</td><td style="text-align:left;">只读。表示 http 请求的状态。</td><td style="text-align:center;">数值</td></tr><tr><td style="text-align:left;">readyState⭐</td><td style="text-align:left;">只读。记录了 AJAX 调用过程中所有可能的状态。分别为：0 (未初始化)、1 (初始化)、2 (发送数据)、3 (数据传送中)、4 (完成)。</td><td style="text-align:center;">数值</td></tr><tr><td style="text-align:left;">statusText</td><td style="text-align:left;">只读。表示服务器的响应状态信息。</td><td style="text-align:center;">字符串</td></tr><tr><td style="text-align:left;">onload</td><td style="text-align:left;">readyState=4 状态之后触发</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">onloadend</td><td style="text-align:left;">readyState4 状态之后 (收到响应时) 或者 readyState2 状态之后 (未收到响应时) 触发</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">timeout⭐</td><td style="text-align:left;">指定 ajax 的超时时长</td><td style="text-align:center;">字符串</td></tr><tr><td style="text-align:left;">ontimeout</td><td style="text-align:left;">请求超时时触发</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">responseURL</td><td style="text-align:left;">返回 ajax 请求最终的 URL，如果请求中存在重定向，那么 responseURL 表示重定向之后的 URL。</td><td style="text-align:center;">字符串</td></tr><tr><td style="text-align:left;">responseXML</td><td style="text-align:left;">只读。表示 xml 形式的响应数据，缺省为 null，若数据不是有效的 xml，则会报错。</td><td style="text-align:center;">XML</td></tr><tr><td style="text-align:left;">response responseText⭐</td><td style="text-align:left;">只读。response 表示服务器的响应内容。responseText 表示服务器响应内容的文本形式。</td><td style="text-align:center;">字符串</td></tr><tr><td style="text-align:left;">responseType</td><td style="text-align:left;">responseType 表示响应的类型, 缺省为空字符串, 可取 &quot;arraybuffer&quot; , &quot;blob&quot; , &quot;document&quot; , &quot;json&quot; , and &quot;text&quot; 共五种类型。</td><td style="text-align:center;">字符串</td></tr><tr><td style="text-align:left;">withCredentials</td><td style="text-align:left;">默认为 false, 表示跨域请求中不发送 cookies 等信息。</td><td style="text-align:center;">布尔值</td></tr><tr><td style="text-align:left;">upload</td><td style="text-align:left;">默认返回一个 XMLHttpRequestUpload 对象，用于上传资源。</td><td style="text-align:center;">对象</td></tr><tr><td style="text-align:left;">abort()⭐</td><td style="text-align:left;">用于取消 ajax 请求。</td><td style="text-align:center;">方法</td></tr><tr><td style="text-align:left;">onerror</td><td style="text-align:left;">请求错误时触发</td><td style="text-align:center;">回调函数</td></tr><tr><td style="text-align:left;">overrideMimeType()</td><td style="text-align:left;">用于强制指定 response 的 MIME 类型，即强制修改 response 的 Content-Type。</td><td style="text-align:center;">方法</td></tr><tr><td style="text-align:left;">setRequestHeader()⭐</td><td style="text-align:left;">用于设置请求头</td><td style="text-align:center;">方法</td></tr><tr><td style="text-align:left;">getResponseHeader()<br>getAllResponseHeaders()⭐</td><td style="text-align:left;">用于获取 ajax 响应头</td><td style="text-align:center;">方法</td></tr><tr><td style="text-align:left;">open()⭐</td><td style="text-align:left;">用于规定请求设置。 open(method, url, async, user, psw) method：请求类型 &#39;GET&#39; 或 &#39;POST&#39;（必须大写） url：请求 url async：可选，true（异步）或 false（同步） user：可选的用户名称 psw：可选的密码</td><td style="text-align:center;">方法</td></tr><tr><td style="text-align:left;">send()⭐</td><td style="text-align:left;">将请求发送到服务器，post 请求时可以将 post 内容作为参数</td><td style="text-align:center;">方法</td></tr></tbody></table><h3 id="_2、基础使用" tabindex="-1">2、基础使用 <a class="header-anchor" href="#_2、基础使用" aria-label="Permalink to &quot;2、基础使用&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> xhr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XMLHttpRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建xhr</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, url, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//设置xhr</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onreadystatechange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (xhr.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//当对于onload</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (xhr.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xhr.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;响应结果&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, xhr.response)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//成功则打印结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ul><li><p>进度条实现，监听 progress</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;progress&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	event.loaded</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	event.total</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li></ul><h2 id="三、jquery-ajax" tabindex="-1">三、JQuery ajax <a class="header-anchor" href="#三、jquery-ajax" aria-label="Permalink to &quot;三、JQuery ajax&quot;">​</a></h2><p>官网：<a href="https://www.jquery123.com/jQuery.ajax/" title="jQuery.ajax() : 执行一个异步的HTTP（Ajax）的请求。 - jQuery API 中文文档 | jQuery 中文网 (jquery123.com)" target="_blank" rel="noreferrer">jQuery.ajax() : 执行一个异步的HTTP（Ajax）的请求。 - jQuery API 中文文档 | jQuery 中文网 (jquery123.com)</a></p><p>$.ajax 是 jquery 对原生 xhr 的封装。通过封装，jquery 抹平了不同版本浏览器异步 http 的差异性，取而代之的是高度统一的 api，并且对 promise 进行了支持。</p><ul><li><h6 id="快捷方法" tabindex="-1">快捷方法 <a class="header-anchor" href="#快捷方法" aria-label="Permalink to &quot;快捷方法&quot;">​</a></h6></li></ul><p><code>$.get(url, [...])</code></p><ul><li>使用一个 HTTP GET 请求从服务器加载数据。</li><li>参数： <ol><li><strong>url</strong> : 一个包含发送请求的 URL 字符串</li><li>data: 发送给服务器的字符串或 Key/value 键值对</li><li>success(data, textStatus, jqXHR) : 当请求成功后执行的回调函数</li><li>dataType : 从服务器返回的预期的数据类型, 默认：智能猜测</li></ol></li></ul><p><code>$.post(url, [...])</code></p><ul><li>使用一个 HTTP POST 请求从服务器加载数据。</li><li>参数： <ol><li><strong>url</strong> : 一个包含发送请求的 URL 字符串</li><li>data: 发送给服务器的字符串或 Key/value 键值对</li><li>success(data, textStatus, jqXHR) : 当请求成功后执行的回调函数</li><li>dataType : 从服务器返回的预期的数据类型, 默认：智能猜测</li></ol></li></ul><p><code>$.load(url, [...])</code></p><ul><li><p>&gt;从服务器载入数据并且将返回的 HTML 代码并插入至匹配的元素中。</p></li><li><p>参数：</p><ol><li><strong>url</strong> : 一个包含发送请求的 URL 字符串</li><li>data: 发送给服务器的字符串或 Key/value 键值对</li><li>complete(responseText, textStatus, XMLHttpRequest) : 当请求成功后执行的回调函数</li></ol></li><li><h6 id="ajax-配置项" tabindex="-1">$.ajax() 配置项 <a class="header-anchor" href="#ajax-配置项" aria-label="Permalink to &quot;$.ajax() 配置项&quot;">​</a></h6></li></ul><p><code>$.ajax()</code> 是一个底层接口，是快捷方法的原生方法，它传入的是一个配置对象。</p><table tabindex="0"><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">类型</th><th style="text-align:left;">描述</th><th style="text-align:left;">默认值/参数</th></tr></thead><tbody><tr><td style="text-align:left;">accepts</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">用于通知服务器该请求需要接收何种类型的返回结果</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">async</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">true 为异步，false 为同步</td><td style="text-align:left;">true</td></tr><tr><td style="text-align:left;">beforeSend</td><td style="text-align:left;">Function</td><td style="text-align:left;">请求发送前的回调</td><td style="text-align:left;">jqXHR 和 settings</td></tr><tr><td style="text-align:left;">cache</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">请求是否开启缓存</td><td style="text-align:left;">true</td></tr><tr><td style="text-align:left;">complete</td><td style="text-align:left;">Function</td><td style="text-align:left;">请求完成后回调函数 (请求 success 和 error 之后均调用)</td><td style="text-align:left;">jqXHR 和 textStatus</td></tr><tr><td style="text-align:left;">contents</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">一个以 &quot;{字符串/正则表达式}&quot; 配对的对象，根据给定的内容类型，解析请求的返回结果</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">contentType</td><td style="text-align:left;">String</td><td style="text-align:left;">发送信息至服务器时内容编码类型</td><td style="text-align:left;">&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</td></tr><tr><td style="text-align:left;">context</td><td style="text-align:left;">Object</td><td style="text-align:left;">设置 ajax 回调函数的上下文</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">converters</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">一个数据类型到数据类型转换器的对象。每个转换器的值是一个函数，返回经转换后的请求结果。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">crossDomain</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">同域请求为 false， 跨域请求为 true</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">data</td><td style="text-align:left;">Array,Object</td><td style="text-align:left;">发送到服务器的数据</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">dataFilter</td><td style="text-align:left;">Function</td><td style="text-align:left;">处理 XMLHttpRequest 原始响应数据的回调</td><td style="text-align:left;">data 和 type</td></tr><tr><td style="text-align:left;">Intelligent</td><td style="text-align:left;">String</td><td style="text-align:left;">预期服务器返回的数据类型</td><td style="text-align:left;">Intelligent Guess (xml, json, script, or html)</td></tr><tr><td style="text-align:left;">error</td><td style="text-align:left;">Function</td><td style="text-align:left;">请求失败时的回调函数</td><td style="text-align:left;">jqXHR 和 textStatus</td></tr><tr><td style="text-align:left;">global</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">表示是否触发全局 ajax 事件</td><td style="text-align:left;">true</td></tr><tr><td style="text-align:left;">headers</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">设置请求头, 格式为 k-v 键值对对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">ifModified</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">只有上次请求响应改变时，才允许请求成功。</td><td style="text-align:left;">false</td></tr><tr><td style="text-align:left;">isLocal</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">允许当前环境被认定为“本地”</td><td style="text-align:left;">取决于当前的位置协议</td></tr><tr><td style="text-align:left;">jsonp</td><td style="text-align:left;">String</td><td style="text-align:left;">显式指定 jsonp 请求中的回调函数的名称</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">jsonpCallback</td><td style="text-align:left;">String,Function</td><td style="text-align:left;">为 jsonp 请求指定一个回调函数名</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">mimeType</td><td style="text-align:left;">String</td><td style="text-align:left;">一个 mime 类型用来覆盖 XHR 的 MIME 类型</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">password</td><td style="text-align:left;">String</td><td style="text-align:left;">用于响应 HTTP 访问认证请求的密码</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">processData</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">jq 的 ajax 方法默认会将传入的 data 隐式转换为查询字符串 (如 &quot;&amp;a=1&amp;b=2&quot;), 以配合 默认内容类型 &quot;application/x-www-form-urlencoded&quot;, 如果不希望转换请设置为 false.</td><td style="text-align:left;">true</td></tr><tr><td style="text-align:left;">scriptCharset</td><td style="text-align:left;">String</td><td style="text-align:left;">仅适用于当 &quot;script&quot; 传输使用时（例如，跨域的 &quot;jsonp&quot; 或 dataType 选项为 &quot;script&quot; 和 &quot;GET&quot; 类型）。请求中使用在 script 标签上设置 charset 属性。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">statusCode</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">一组数值的 HTTP 代码和函数对象，当响应时调用了相应的代码。</td><td style="text-align:left;">{}</td></tr><tr><td style="text-align:left;">success</td><td style="text-align:left;">Function</td><td style="text-align:left;">请求成功后的回调函数。</td><td style="text-align:left;">data, textStatus, jqXHR</td></tr><tr><td style="text-align:left;">timeout</td><td style="text-align:left;">Number</td><td style="text-align:left;">设置请求超时时间（毫秒）</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">traditional</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">如果你想要用传统的方式来序列化数据，那么就设置为 true。</td><td style="text-align:left;">true</td></tr><tr><td style="text-align:left;">type</td><td style="text-align:left;">String</td><td style="text-align:left;">请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)</td><td style="text-align:left;">&quot;GET&quot;</td></tr><tr><td style="text-align:left;">url</td><td style="text-align:left;">String</td><td style="text-align:left;">发送请求的地址。</td><td style="text-align:left;">当前页面地址</td></tr><tr><td style="text-align:left;">username</td><td style="text-align:left;">String</td><td style="text-align:left;">于响应 HTTP 访问认证请求的用户名</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">xhr</td><td style="text-align:left;">Function</td><td style="text-align:left;">回调创建 XMLHttpRequest 对象。</td><td style="text-align:left;">当可用的 ActiveXObject（IE）中，否则为 XMLHttpRequest</td></tr><tr><td style="text-align:left;">xhrFields</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">一对“文件名 - 文件值”组成的映射，用于设定原生的 XHR 对象。</td><td style="text-align:left;"></td></tr></tbody></table><ul><li><h6 id="promise-支持" tabindex="-1">promise 支持 <a class="header-anchor" href="#promise-支持" aria-label="Permalink to &quot;promise 支持&quot;">​</a></h6></li></ul><p>从 jQuery 1.5 开始，<code>$.ajax()</code> 返回的 jqXHR 对象实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为。</p><table tabindex="0"><thead><tr><th>新方法</th><th>被替代的老方法 (jq1.8 起弃用)</th></tr></thead><tbody><tr><td>done(function(data, textStatus, jqXHR) {})</td><td>success</td></tr><tr><td>fail(function(jqXHR, textStatus, errorThrown) {})</td><td>error</td></tr><tr><td>always(function(data or jqXHR, textStatus, jqXHR or errorThrown) {})</td><td>complete</td></tr></tbody></table><h2 id="四、axios" tabindex="-1">四、Axios <a class="header-anchor" href="#四、axios" aria-label="Permalink to &quot;四、Axios&quot;">​</a></h2><p>Axios 是一个基于 <a href="https://javascript.info/promise-basics" title="promise" target="_blank" rel="noreferrer"><em>promise</em></a> 网络请求库，作用于 <a href="https://nodejs.org/" title="node.js" target="_blank" rel="noreferrer">node.js</a> 和浏览器中。 它是 <a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application" title="isomorphic" target="_blank" rel="noreferrer"><em>isomorphic</em></a> 的 (即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><p><strong>中文文档</strong>：</p><p><a href="https://www.axios-http.cn/" title="Axios 中文文档 | Axios 中文网 | Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js (axios-http.cn)" target="_blank" rel="noreferrer">Axios 中文文档 | Axios 中文网 | Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js (axios-http.cn)</a></p><ul><li><h6 id="axios-配置项" tabindex="-1">Axios 配置项 <a class="header-anchor" href="#axios-配置项" aria-label="Permalink to &quot;Axios 配置项&quot;">​</a></h6></li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">属性<img width="100px"></th><th style="text-align:left;">类型</th><th style="text-align:left;">描述</th><th style="text-align:left;">默认值/参数</th></tr></thead><tbody><tr><td style="text-align:left;">url</td><td style="text-align:left;">String</td><td style="text-align:left;">请求的服务器 URL</td><td style="text-align:left;">【必填】</td></tr><tr><td style="text-align:left;">method</td><td style="text-align:left;">String</td><td style="text-align:left;">请求方法</td><td style="text-align:left;">&#39;GET&#39;</td></tr><tr><td style="text-align:left;">baseURL</td><td style="text-align:left;">String</td><td style="text-align:left;">它可以通过设置一个 <code>baseURL</code> 便于为 axios 实例的方法传递相对 URL</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">transformRequest</td><td style="text-align:left;">Array[Function]</td><td style="text-align:left;">允许在向服务器发送前，修改<strong>请求数据</strong>，数组中最后一个函数必须返回一个字符串、一个 Buffer 实例、ArrayBuffer、FormData 或 Stream</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">transformResponse</td><td style="text-align:left;">Array[Function]</td><td style="text-align:left;">在传递给 then/catch 前，允许修改<strong>响应数据</strong></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">headers</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">自定义请求头</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">params</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">与请求一起发送的 URL 参数。必须是一个简单对象或 URLSearchParams 对象</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">paramsSerializer</td><td style="text-align:left;">Function</td><td style="text-align:left;">主要用于序列化 <code>params</code></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">data</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">作为请求体被发送的数据。在没有设置 <code>transformRequest</code> 时，则必须是以下类型之一: string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams - 浏览器专属: FormData, File, Blob - Node 专属: Stream, Buffer</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">timeout</td><td style="text-align:left;">Number</td><td style="text-align:left;">指定请求超时的毫秒数，超过则请求中断</td><td style="text-align:left;">0【永不超时中断】</td></tr><tr><td style="text-align:left;">withCredentials</td><td style="text-align:left;">Boolean</td><td style="text-align:left;">表示跨域请求时是否需要使用凭证</td><td style="text-align:left;">false</td></tr><tr><td style="text-align:left;">adapter</td><td style="text-align:left;">Function</td><td style="text-align:left;">允许自定义处理请求，这使测试更加容易。 返回一个 promise 并提供一个有效的响应</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">auth</td><td style="text-align:left;">PlainObject</td><td style="text-align:left;">HTTP 基础身份验证</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">responseType</td><td style="text-align:left;">String</td><td style="text-align:left;">表示浏览器将要响应的数据类型。选项包括: &#39;arraybuffer&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;</td><td style="text-align:left;">&#39;json&#39;</td></tr><tr><td style="text-align:left;">responseEncoding</td><td style="text-align:left;">String</td><td style="text-align:left;">表示用于解码响应的编码 (Node.js 专属)</td><td style="text-align:left;">&#39;utf8&#39;</td></tr><tr><td style="text-align:left;">xsrfCookieName</td><td style="text-align:left;">String</td><td style="text-align:left;">用作 cookie 的名称</td><td style="text-align:left;">&#39;XSRF-TOKEN&#39;</td></tr><tr><td style="text-align:left;">xsrfHeaderName</td><td style="text-align:left;">String</td><td style="text-align:left;">带有 xsrf token 值的 http 请求头名称</td><td style="text-align:left;">&#39;X-XSRF-TOKEN&#39;</td></tr><tr><td style="text-align:left;">onUploadProgress</td><td style="text-align:left;">Function</td><td style="text-align:left;">上传处理进度事件</td><td style="text-align:left;">progressEvent</td></tr><tr><td style="text-align:left;">onDownloadProgress</td><td style="text-align:left;">Function</td><td style="text-align:left;">下载处理进度事件</td><td style="text-align:left;">progressEvent</td></tr><tr><td style="text-align:left;">maxContentLength</td><td style="text-align:left;">Number</td><td style="text-align:left;">定义了 node.js 中允许的 HTTP 响应内容的最大字节数</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">maxBodyLength</td><td style="text-align:left;">Number</td><td style="text-align:left;">（仅 Node）定义允许的 http 请求内容的最大字节数</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">validateStatus</td><td style="text-align:left;">Function</td><td style="text-align:left;">定义了对于给定的 HTTP 状态码是 resolve 还是 reject promise。如果 <code>validateStatus</code> 返回 <code>true</code> (或者设置为 <code>null</code> 或 <code>undefined</code>)，则 promise 将会 resolved，否则是 rejected。</td><td style="text-align:left;">function (status) {return status &gt;= 200 &amp;&amp; status &lt; 300; }</td></tr><tr><td style="text-align:left;">maxRedirects</td><td style="text-align:left;">Number</td><td style="text-align:left;">定义了在 node.js 中要遵循的最大重定向数</td><td style="text-align:left;">5</td></tr><tr><td style="text-align:left;">socketPath</td><td style="text-align:left;">String</td><td style="text-align:left;">定义了在 node.js 中使用的 UNIX 套接字</td><td style="text-align:left;">null</td></tr><tr><td style="text-align:left;">httpAgent httpsAgent</td><td style="text-align:left;">Object</td><td style="text-align:left;">定义了一个常规的代理当执行一个请求</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">proxy</td><td style="text-align:left;">Object</td><td style="text-align:left;">定义了代理服务器的主机名，端口和协议</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">cancelToken</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">decompress</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr></tbody></table><ul><li><h6 id="全局配置" tabindex="-1">全局配置 <a class="header-anchor" href="#全局配置" aria-label="Permalink to &quot;全局配置&quot;">​</a></h6></li><li><p>全局 axios 默认值</p></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.defaults.baseURL </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://api.example.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.defaults.headers.common[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AUTH_TOKEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.defaults.headers.post[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;application/x-www-form-urlencoded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>自定义实例默认值</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建实例时配置默认值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	baseURL: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://api.example.com&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建实例后修改默认值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.defaults.headers.common[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AUTH_TOKEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>配置的优先级</li></ul><p>lib/defaults.js &lt; defaults &lt; config</p><ul><li><h6 id="响应对象-response-结构" tabindex="-1">响应对象 Response 结构 <a class="header-anchor" href="#响应对象-response-结构" aria-label="Permalink to &quot;响应对象 Response 结构&quot;">​</a></h6></li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`data\` 由服务器提供的响应</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {},</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`status\` 来自服务器响应的 HTTP 状态码</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  status</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`statusText\` 来自服务器响应的 HTTP 状态信息</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  statusText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&#39;OK&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`headers\` 是服务器响应头</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 例如: \`response.headers[&#39;content-type&#39;]\`</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  headers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {},</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`config\` 是 \`axios\` 请求的配置信息</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {},</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // \`request\` 是生成此响应的请求</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在浏览器中则是 XMLHttpRequest 实例</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><h6 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h6></li></ul><ol><li>Axios 支持 node, jquery 并不支持。</li><li>Axios 基于 promise 语法, jq3.0 才开始全面支持。</li><li>Axios 只有 14kb, 更加适合 http 场景, jquery 大而全, 加载较慢。</li><li>vue 作者尤大放弃推荐 vue-resource, 转向推荐 Axios. 以下为尤大原话。</li></ol><h2 id="三、fetch" tabindex="-1">三、Fetch <a class="header-anchor" href="#三、fetch" aria-label="Permalink to &quot;三、Fetch&quot;">​</a></h2><p>Fetch 是 JS 一个获取资源的接口，提供了对 <code>Request</code> 和 <code>Response</code> （以及其他与网络请求有关的）对象的通用定义。</p><p>Fetch 与 JQuery.ajax 和 Axios 相比，它并非是 XMLHttpRequest 的封装。</p><p>XMLHttpRequest 对象的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。那么 Fetch API 就应势而生，提供了一种新规范，用来取代善不完美的 XMLHttpRequest 对象。</p><ul><li>Fetch 的两个特点 <ol><li>接口合理化，AJAX 是将所有不同性质的接口都放在 XHR 对象上，而 Fetch 是将它们分散在几个不同的对象上。</li><li>返回 Promise 对象，避免了嵌套的回调函数。</li></ol></li><li>使用指南 <a href="http://louiszhai.github.io/2016/11/02/fetch/#%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%AAfetch" title="http://louiszhai.github.io/2016/11/02/fetch/#尝试一个fetch" target="_blank" rel="noreferrer">http://louiszhai.github.io/2016/11/02/fetch/#尝试一个fetch</a></li></ul><h3 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://xxxx.xxx&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送一个请求，模式为no-cors</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url,{mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cors&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response;              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//指定的成功回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//打印响应数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Oops, error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//指定错误的回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="get" tabindex="-1">GET <a class="header-anchor" href="#get" aria-label="Permalink to &quot;GET&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个参数url,默认请求方式是get,返回值是一个promise</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回有5种格式 text(),json(),blob(),arrayBuffer(),formData()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//get</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:3002/api/txt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="post" tabindex="-1">Post <a class="header-anchor" href="#post" aria-label="Permalink to &quot;Post&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendPostFetch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 第一个参数url,第二个参数是一个option配置对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:3002/api/post&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;张三&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		headers: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 需要配置请求头定义body的数据类型</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">			&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="进度条实现" tabindex="-1">进度条实现 <a class="header-anchor" href="#进度条实现" aria-label="Permalink to &quot;进度条实现&quot;">​</a></h3><p>原理：</p><ol><li><code>res.body.getReader()</code> 创建一个 body 读取器</li><li>通过 res.headers 里的 <code>&#39;Content-Length&#39;</code> 获取 body 总长度</li><li>循环调用 <code>reader.read()</code>，其返回的结构类似 iterate 生成器，会返回一个 <code>{ done, value }</code> 对象。</li><li>如果 done 为真，说明已经全部读取；value 为当前一次读取的数据</li><li>通过一个计数器累计每一次读取的长度</li><li>累计长度/总长度 = 当前进度</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> total</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.headers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Length&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取总长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">done</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (done) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //当前已获取的数据长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  progress.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">((</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loaded</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFixed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;%&#39;}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="中断请求" tabindex="-1">中断请求 <a class="header-anchor" href="#中断请求" aria-label="Permalink to &quot;中断请求&quot;">​</a></h3><p>原理：</p><ol><li>创建一个 <code>AbortController()</code> 对象</li><li>options 配置 <code>signal: abortController.signal</code></li><li><code>abortController.abort()</code> 在需要的时机执行中断</li></ol><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> abortController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbortController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendPicFetch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:3002/api/static/3.mp4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    signal: abortController.signal</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  abortController.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//需要时执行中断</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>超时：(简易封装）</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> timeoutAbortFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    abortController.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },time)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="fetch-的劣势" tabindex="-1">Fetch 的劣势 <a class="header-anchor" href="#fetch-的劣势" aria-label="Permalink to &quot;Fetch 的劣势&quot;">​</a></h3><ul><li>fetch 请求对某些错误 http 状态不会 reject</li><li>fetch 不支持 abort，不支持超时控制。</li></ul>`,68))])}const j=d(g,[["render",F]]);export{q as __pageData,j as default};
