import{_ as i,c as a,o as e,ae as l}from"./chunks/framework.CIivgcbp.js";const n="/obsidian-vitepress-docs/assets/01-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A7%88-1.BNLmWcSw.png",t="/obsidian-vitepress-docs/assets/01-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A7%88-2.Bo-bIfWw.png",g=JSON.parse('{"title":"01- 框架设计概览","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/07 Vue/笔记：Vue3设计与实现/01-框架设计概览.md","filePath":"前端技术/07 Vue/笔记：Vue3设计与实现/01-框架设计概览.md"}'),p={name:"前端技术/07 Vue/笔记：Vue3设计与实现/01-框架设计概览.md"};function h(r,s,k,o,d,c){return e(),a("div",null,s[0]||(s[0]=[l('<h1 id="_01-框架设计概览" tabindex="-1">01- 框架设计概览 <a class="header-anchor" href="#_01-框架设计概览" aria-label="Permalink to &quot;01- 框架设计概览&quot;">​</a></h1><h2 id="一、权衡的艺术" tabindex="-1">一、权衡的艺术 <a class="header-anchor" href="#一、权衡的艺术" aria-label="Permalink to &quot;一、权衡的艺术&quot;">​</a></h2><h3 id="命令式和声明式" tabindex="-1">命令式和声明式 <a class="header-anchor" href="#命令式和声明式" aria-label="Permalink to &quot;命令式和声明式&quot;">​</a></h3><p>命令式和声明式对比的并非 Vue3 API 的两种风格 (选项式，组合式)，这里的命令式指传统操作 DOM 元素的过程，声明式指用 Vue.js 帮我们封装了过程，只需要声明想要的效果。</p><p>==声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗==</p><p>声明式代码的性能 &lt; 命令式代码的性能。</p><h3 id="为什么要虚拟-dom" tabindex="-1">为什么要虚拟 DOM <a class="header-anchor" href="#为什么要虚拟-dom" aria-label="Permalink to &quot;为什么要虚拟 DOM&quot;">​</a></h3><p>==如果我们能够最小化找出差异的性能消耗，就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。==</p><p>虚拟 DOM 创 建页面的过程分为两步：</p><ol><li>第一步是创建 JavaScript 对象，这个对象可以 理解为真实 DOM 的描述；</li><li>第二步是递归地遍历虚拟 DOM 树并创建真实 DOM。</li></ol><p>我们同样可以用一个公式来表达：创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量。<br><img src="'+n+`" alt="D-学习笔记/前端技术/07 Vue/笔记：Vue3设计与实现/attachments/01-框架设计概览-1.png"><br> 通过与 innerHTML 和原生的对比，虚拟 DOM 是一种折中的方法。</p><h3 id="运行时和编译时" tabindex="-1">运行时和编译时 <a class="header-anchor" href="#运行时和编译时" aria-label="Permalink to &quot;运行时和编译时&quot;">​</a></h3><p>运行时和编译时当设计一个框架的时候，我们有三种选择：</p><ol><li>纯运行时的<br><code>DOM 结构对象 -&gt; render 函数 -&gt; 真实 DOM</code></li><li>纯编译时的<br><code>html 结构字符串 -&gt; compiler 程序 -&gt; 操作 DOM 的 js 代码</code></li><li>运行时 + 编译时的<br><code>html 结构字符串 -&gt; compiler 程序 -&gt; DOM 结构对象 -&gt; render 函数 -&gt; 真实 DOM</code></li></ol><p>Vue.js 3 仍然保持了运行时 + 编译时的架构，在保持灵活性的基础上能够尽可能地去优化。</p><h2 id="二、框架设计的核心要素" tabindex="-1">二、框架设计的核心要素 <a class="header-anchor" href="#二、框架设计的核心要素" aria-label="Permalink to &quot;二、框架设计的核心要素&quot;">​</a></h2><div class="info custom-block github-alert"><p class="custom-block-title">+ 框架设计的核心要素总结：</p><p></p><ol><li>提升用户体验</li></ol><ul><li>良好的错误提示与处理</li><li>TS 类型支持 (使用 TS 编写框架和框架对 TS 类型支持友好是两件完全不同的事。)</li></ul><ol><li>控制代码体积</li></ol><ul><li>Tree-Shaking</li><li>控制输出结构</li><li>特性开关</li></ul></div><h3 id="tree-shaking" tabindex="-1">Tree-Shaking <a class="header-anchor" href="#tree-shaking" aria-label="Permalink to &quot;Tree-Shaking&quot;">​</a></h3><p>简单地说，Tree-Shaking 指的就是消除那些永远不会被执行的代码，也就是排除 dead code，现在无论是 rollup.js 还是 webpack，都支持 Tree-Shaking。</p><p>==ESM 支持在编译时确定模块依赖，而 CJS 在运行时动态加载模块。==因此想要实现 Tree-Shaking，必须使用 ES Module。</p><p>==Tree-Shaking 副作用，就是当调用函数的时候会对外部产生影响==，例如修改了全局变量。</p><p>Vue.js 3 的源码使用了大量的 <code>/*#__PURE__*/</code> （无副作用声明）注释，以剔除 dead code。</p><h3 id="构建输出结构" tabindex="-1">构建输出结构 <a class="header-anchor" href="#构建输出结构" aria-label="Permalink to &quot;构建输出结构&quot;">​</a></h3><p>在 rollup.js 中，我们可以通过配置 <code>format: &#39;iife&#39;</code> 来输出 IIFE 格式的资源，配置为： <code>format: &#39;esm&#39;</code> 输出 ESM 格式的资源。</p><p>当进行服务端渲染时，Vue.js 的代码是在 Node.js 环境中运行的，而非浏览器环境。在 Node.js 环境中，资源的模块格式应该是 CommonJS，简称 cjs。为了能 够输出 cjs 模块的资源，我们可以通过修改 rollup.config.js 的配置 <code>format: &#39;cjs&#39;</code> 来实现。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// rollup.config.js </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	input: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	output: { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		file: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;output.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		format: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cjs&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指定模块形式 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config</span></span></code></pre></div><p><code>__VUE_OPTIONS_API__</code> 是一个特性开关，用于指定使用选项式还是组合式 API。</p><h2 id="三、vue3-的设计思路" tabindex="-1">三、Vue3 的设计思路 <a class="header-anchor" href="#三、vue3-的设计思路" aria-label="Permalink to &quot;三、Vue3 的设计思路&quot;">​</a></h2><h3 id="声明式地描述-ui" tabindex="-1">声明式地描述 UI <a class="header-anchor" href="#声明式地描述-ui" aria-label="Permalink to &quot;声明式地描述 UI&quot;">​</a></h3><p>编写前端页面都涉及哪些内容，具体如下：</p><ul><li>DOM 元素</li><li>属性</li><li>事件</li><li>元素的层级结构</li></ul><p>vue3 的解决方案：</p><ul><li>使用与 HTML 标签一致的方式来描述属性</li><li>==使用 : 或 v-bind 来描述动态绑定的属性==</li><li>==使用 @ 或 v-on 来描述事件==</li><li>使用与 HTML 标签一致的方式来描述层级结构。</li></ul><p>还可以用 JavaScript 对象来描述，描述 UI 更加灵活</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{	</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	tag:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//标签名称	</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	props:{    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//标签属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	    onclick:handler</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	children:[  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	    {tag:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;span&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>对应到 Vue 模板</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">handler</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;</span></span></code></pre></div><p>==而这种使用 JavaScript 对象来描述 UI 的方式，其实就是所谓的虚拟 DOM。==</p><h3 id="初识渲染器" tabindex="-1">初识渲染器 <a class="header-anchor" href="#初识渲染器" aria-label="Permalink to &quot;初识渲染器&quot;">​</a></h3><p>==渲染器的作用就是把虚拟 DOM 渲染为真实 DOM==</p><p><img src="`+t+'" alt="D-学习笔记/前端技术/07 Vue/笔记：Vue3设计与实现/attachments/01-框架设计概览-2.png"></p><p>现在我们回过头来分析渲染器 renderer 的实现思路，总体来说分为三步。</p><ol><li>创建元素：<br> 把 vnode.tag 作为标签名称来创建 DOM 元素。</li><li>为元素添加属性和事件：<br> 遍历 vnode.props 对象，如果 key 以 on 字符开头，说明它是一个事件，把字符 on 截取掉后再调用 toLowerCase 函数将事件名称小写化，最终得到合法的事件名 称，例如 onClick 会变成 click，最后调用 addEventListener 绑定事件处理函数。</li><li>处理 children：<br> 如果 children 是一个数组，就递归地调用 renderer 继续渲染，注意，此时我们要把刚刚创建的元素作为 挂载点（父节点）；如果 children 是字符串，则使用 createTextNode 函数创建一个文本节点，并将其添加到新创建 的元素内。</li></ol><h3 id="组件的本质" tabindex="-1">组件的本质 <a class="header-anchor" href="#组件的本质" aria-label="Permalink to &quot;组件的本质&quot;">​</a></h3><p>组件就是一 组 DOM 元素的封装。<br> 组件的返回值也是虚拟 DOM，它代表组件要渲染的内容。</p><h3 id="模板的工作原理" tabindex="-1">模板的工作原理 <a class="header-anchor" href="#模板的工作原理" aria-label="Permalink to &quot;模板的工作原理&quot;">​</a></h3><p>模板是如何工作的呢？==编译器==</p><p>编译器和渲染器一样，只是一段程序而已，不过它们的工作内容 不同。编译器的作用其实就是将模板编译为渲染函数<br> 对于编译器来说，模板就是一个普通的字符串，它会分析该字符串并生成一个功能与之相同的渲染函数。</p><p>==Vue.js 是各个模块组成的有机整体==</p>',49)]))}const u=i(p,[["render",h]]);export{g as __pageData,u as default};
