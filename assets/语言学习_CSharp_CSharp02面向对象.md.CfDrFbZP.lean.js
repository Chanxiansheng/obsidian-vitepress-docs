import{_ as h,C as k,c as e,o as d,ae as n,j as i,a,G as t,w as p}from"./chunks/framework.CIivgcbp.js";const b=JSON.parse('{"title":"CSharp02 面向对象","description":"","frontmatter":{},"headers":[],"relativePath":"语言学习/CSharp/CSharp02面向对象.md","filePath":"语言学习/CSharp/CSharp02面向对象.md"}'),r={name:"语言学习/CSharp/CSharp02面向对象.md"};function E(g,s,c,y,o,F){const l=k("font");return d(),e("div",null,[s[14]||(s[14]=n("",14)),i("p",null,[s[1]||(s[1]=a("我们构造对象的时候，对象的初始化过程是⾃动完成的，但是在初始化对象的过程中有的 时候需要做⼀些额外的⼯作，例如需要初始化对象存储的数据，构造函数就是⽤于初始化 数据的函数。")),s[2]||(s[2]=i("br",null,null,-1)),s[3]||(s[3]=a(" 声明基本的构造函数的语法就是声明⼀个")),t(l,{color:"#ff0000"},{default:p(()=>s[0]||(s[0]=[a("和所在类同名的⽅法")])),_:1,__:[0]}),s[4]||(s[4]=a("，但是该⽅法没有返回类 型。"))]),s[15]||(s[15]=n("",10)),i("ul",null,[i("li",null,[s[12]||(s[12]=i("p",null,"继承的类型",-1)),i("ol",null,[s[10]||(s[10]=i("li",null,[i("p",null,"实现继承： 表⽰⼀个类型派⽣于⼀个基类型,它拥有该基类型的所有成员字段和函数。 在实现继 承中,派⽣类型采⽤基类型的每个函数的实现代码,除⾮在派⽣类型的定义中指定重写 某个函数的实现代码。 在需要给现有的类型添加功能,或许多相关的类型共享⼀组重 要的公共功能时,这种类型的继承⾮常有⽤。")],-1)),s[11]||(s[11]=i("li",null,[i("p",null,"接⼝继承： 表⽰⼀个类型只继承了函数的签名,没有继承任何实现代码。 在需要指定该类型具有 某些可⽤的特性时,最好使⽤这种类型的继承。")],-1)),i("li",null,[i("p",null,[s[7]||(s[7]=a("多重继承：⼀些语⾔ (C++) ⽀持所谓的 “多重继承”，即⼀个类派⽣⾃多个类。 使⽤多重继承的优点是有争议的: ⼀⽅⾯,毫⽆疑问，可以使⽤多重继承编写⾮常复杂、 但很紧凑的代码。另⼀⽅⾯，使⽤多重实现继承的代码常常很难理解和调试。 如前所述，简化健壮代码的编写⼯作是开发 C#的重要设计⽬标。 因此，")),t(l,{color:"#ff0000"},{default:p(()=>s[5]||(s[5]=[a("C#不⽀持多重实现继承。")])),_:1,__:[5]}),s[8]||(s[8]=a(" ⽽ ")),t(l,{color:"#ff0000"},{default:p(()=>s[6]||(s[6]=[a("C#允许类型派⽣⾃多个接⼝— —多重接⼝继承")])),_:1,__:[6]}),s[9]||(s[9]=a("。 这说明,C#类可以派⽣⾃另⼀个类和任意多个接⼝。更准确地说, System.Object 是⼀个公共的基类，所以每个 C#(除了 Object 类之外) 都有⼀个基类,还可以有任意多个基接⼝。"))])])])]),s[13]||(s[13]=i("li",null,[i("p",null,"继承的实现")],-1))]),s[16]||(s[16]=n("",41))])}const C=h(r,[["render",E]]);export{b as __pageData,C as default};
