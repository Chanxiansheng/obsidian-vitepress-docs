import{_ as a}from"./chunks/07 对象、类与面向对象编程-2.Cz-nz9Gz.js";import{_ as n,c as i,o as t,ae as l}from"./chunks/framework.CIivgcbp.js";const g=JSON.parse('{"title":"原型链的思考","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/03对象与函数/原型链的思考.md","filePath":"前端技术/03 JavaScript/03对象与函数/原型链的思考.md"}'),e={name:"前端技术/03 JavaScript/03对象与函数/原型链的思考.md"};function o(p,s,r,h,c,E){return t(),i("div",null,s[0]||(s[0]=[l('<h1 id="原型链的思考" tabindex="-1">原型链的思考 <a class="header-anchor" href="#原型链的思考" aria-label="Permalink to &quot;原型链的思考&quot;">​</a></h1><h2 id="一、原型链的设计核心" tabindex="-1">一、原型链的设计核心 <a class="header-anchor" href="#一、原型链的设计核心" aria-label="Permalink to &quot;一、原型链的设计核心&quot;">​</a></h2><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><div class="important custom-block github-alert"><p class="custom-block-title">Function 与 Object 的「二元共生」关系</p><p><code>Function</code> 元构造函数提供构造能力，<code>Object</code> 提供原型根基，两者共同构成原型链的 <strong>「DNA 双螺旋结构」</strong></p><ol><li>​<strong>Function 的元能力（Meta-Functionality）​</strong></li></ol><ul><li><strong>所有函数的构造者</strong>：<code>Function</code> 是 JavaScript 中唯一能生成函数对象（包括构造函数）的内置对象。甚至 ​**<code>Object</code> 构造函数本身也是 <code>Function</code> 的实例**</li><li><strong>自举（Bootstrapping）</strong>：<code>Function</code> 的构造函数是自身，形成逻辑闭环</li></ul><ol><li>​<strong>Object 的原型终局性</strong><br><strong>所有对象的根基</strong>：<code>Object.prototype</code> 是原型链的终点（<code>Object.prototype.__proto__ === null</code>），无论是函数还是普通对象，最终均通过原型链继承自它</li><li><code>new</code> 关键字的链式维护</li></ol></div><p><img src="'+a+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/07 对象、类与面向对象编程-2.png"></p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 内置构造函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Function[&quot;Function（内置）&quot;] --&gt;|prototype| FunctionProto[&quot;Function.prototype（内置）&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Object[&quot;Object（内置）&quot;] --&gt;|prototype| ObjectProto[&quot;Object.prototype（内置）&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 自定义构造函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Person[&quot;Person（自定义）&quot;] --&gt;|prototype| PersonProto[&quot;Person.prototype&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Man[&quot;Man（自定义）&quot;] --&gt;|prototype| ManProto[&quot;Man.prototype&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 实例对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    NewPerson[&quot;new Person()&quot;] --&gt;|Prototype| PersonProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    NewMan[&quot;new Man()&quot;] --&gt;|Prototype| ManProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 原型链继承</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PersonProto --&gt;|Prototype| ObjectProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ManProto --&gt;|Prototype| PersonProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 构造函数继承</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Function --&gt;|&quot;__proto__&quot;| FunctionProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Object --&gt;|&quot;__proto__&quot;| FunctionProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Person --&gt;|&quot;__proto__&quot;| FunctionProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Man --&gt;|&quot;__proto__&quot;| FunctionProto</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 终点标识</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ObjectProto --&gt;|Prototype| null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 构造函数反向引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PersonProto -.-&gt; |constructor| Person</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ManProto -.-&gt; |constructor| Man</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    FunctionProto -.-&gt; |constructor| Function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ObjectProto -.-&gt; |constructor| Object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    %% 样式定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    classDef builtin fill:#FFE4E1,stroke:#FF6347;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    classDef custom fill:#E0FFFF,stroke:#4682B4;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    classDef instance fill:#F0F8FF,stroke:#B0C4DE;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    class Function,Object,FunctionProto,ObjectProto builtin;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    class Person,Man,PersonProto,ManProto custom;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    class NewPerson,NewMan instance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linkStyle 0,1,2,3 stroke:#FF6347,stroke-width:2px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linkStyle 4,5 stroke:#4682B4,stroke-width:2px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linkStyle 6,7,8,9 stroke:#20B2AA,stroke-width:1.5px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linkStyle 10 stroke:#808080,stroke-width:1px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    linkStyle 11,12,13,14 stroke:#FFA500,stroke-dasharray:5;</span></span></code></pre></div><h3 id="继承设计差异" tabindex="-1">继承设计差异 <a class="header-anchor" href="#继承设计差异" aria-label="Permalink to &quot;继承设计差异&quot;">​</a></h3><p>原型继承与传统类继承的核心差异：</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph LR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">classDef cls fill:#f9f,stroke:#333;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">classDef proto fill:#bbf,stroke:#333;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph &quot;类继承(Java)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A[类 Class] --&gt; B[实例 Instance]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A --&gt; C[子类 Subclass]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C --&gt; D[子类实例]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  class A,C cls;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph &quot;原型继承(JavaScript)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  E[原型对象 Prototype] --&gt; F[对象 Object]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  E --&gt; G[新原型 New Prototype]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  F --&gt;|委托| E</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  G --&gt;|委托| E</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  class E,G proto;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span></code></pre></div><ul><li>​<strong>类继承</strong>：通过模板（类）批量生成实例，强调分类的严谨性</li><li>​<strong>原型继承</strong>：通过对象直接克隆和修改，强调动态灵活性</li></ul><h2 id="二、原型继承的核心学术支撑" tabindex="-1">二、原型继承的核心学术支撑 <a class="header-anchor" href="#二、原型继承的核心学术支撑" aria-label="Permalink to &quot;二、原型继承的核心学术支撑&quot;">​</a></h2><p>JavaScript 的原型继承机制并非凭空诞生，其设计深受计算机科学领域两大理论的影响：</p><h3 id="_1-​self-语言的启发​-直接影响" tabindex="-1">1. ​<strong>Self 语言的启发</strong>​（直接影响） <a class="header-anchor" href="#_1-​self-语言的启发​-直接影响" aria-label="Permalink to &quot;1. ​**Self 语言的启发**​（直接影响）&quot;">​</a></h3><ul><li>​<strong>核心论文</strong>：<br> 《Prototype-Based Programming》（基于原型的编程）系列论文 <ul><li>David Ungar, Randall B. Smith. <em>Self: The Power of Simplicity</em>. OOPSLA 1987</li><li>论文地址：<a href="https://dl.acm.org/doi/10.1145/38807.38828" target="_blank" rel="noreferrer">https://dl.acm.org/doi/10.1145/38807.38828 </a></li><li>​<strong>关键点</strong>： <ul><li>提出 ​<strong>无类继承（Classless Inheritance）​</strong> 概念</li><li>通过原型对象（Prototype）直接委托实现代码复用</li><li>消除类与实例的严格界限（与 Java/C++ 的类继承形成对比）</li></ul></li></ul></li><li>​<strong>对 JS 的影响</strong>：<br> JavaScript 创始人 Brendan Eich 明确表示，其原型系统设计灵感来源于 Self 语言。例如： <ul><li><code>[[Prototype]]</code> 链的委托机制</li><li>动态修改原型的能力（<code>obj.__proto__</code> 可修改）</li></ul></li></ul><h3 id="_2-​scheme-语言的函数式基因​-间接影响" tabindex="-1">2. ​<strong>Scheme 语言的函数式基因</strong>​（间接影响） <a class="header-anchor" href="#_2-​scheme-语言的函数式基因​-间接影响" aria-label="Permalink to &quot;2. ​**Scheme 语言的函数式基因**​（间接影响）&quot;">​</a></h3><ul><li>​<strong>核心文献</strong>：<br> 《Scheme and the Art of Programming》（Scheme 编程艺术）<br> ​<strong>关键点</strong>： <ul><li>一等函数（First-class Functions）的设计</li><li>闭包（Closure）的变量捕获机制</li><li>对 JS 函数作为对象核心载体的影响（<code>Function.prototype</code>）</li></ul></li></ul><hr><h2 id="三、javascript-原型系统的设计文档" tabindex="-1">三、JavaScript 原型系统的设计文档 <a class="header-anchor" href="#三、javascript-原型系统的设计文档" aria-label="Permalink to &quot;三、JavaScript 原型系统的设计文档&quot;">​</a></h2><h3 id="_1-​ecmascript-规范中的权威定义" tabindex="-1">1. ​<strong>ECMAScript 规范中的权威定义</strong> <a class="header-anchor" href="#_1-​ecmascript-规范中的权威定义" aria-label="Permalink to &quot;1. ​**ECMAScript 规范中的权威定义**&quot;">​</a></h3><ul><li>​<strong>核心文档</strong>：<br> ECMA-262 标准 中的 ​<strong>Object Internal Methods</strong> 和 ​**<code>[[Prototype]]</code>** 相关章节 <ul><li>​<strong>重点章节</strong>： <ul><li>6.1.7.3 Object Internal Methods and Internal Slots</li><li>9.1 Ordinary Object Internal Methods and Internal Slots</li></ul></li><li>​<strong>设计精髓</strong>： <ul><li><code>[[Prototype]]</code> 作为对象内部插槽（Internal Slot）的规范定义</li><li><code>new</code>、<code>Object.create</code> 等操作对原型链的标准化处理流程</li></ul></li></ul></li></ul><h3 id="_2-​brendan-eich-的设计手记" tabindex="-1">2. ​<strong>Brendan Eich 的设计手记</strong> <a class="header-anchor" href="#_2-​brendan-eich-的设计手记" aria-label="Permalink to &quot;2. ​**Brendan Eich 的设计手记**&quot;">​</a></h3><ul><li>​<strong>历史文档</strong>：<br> 1995 年 Netscape 内部设计备忘录（部分公开于 JS 历史访谈） <ul><li>​<strong>关键决策</strong>： <ul><li>选择基于原型而非类（避免与 Java 竞争）</li><li><code>Function</code> 和 <code>Object</code> 的共生设计（解决自举问题）</li></ul></li></ul></li></ul>`,22)]))}const u=n(e,[["render",o]]);export{g as __pageData,u as default};
