import{_ as i,c as t,o as a,ag as r}from"./chunks/framework.-ewJmwvT.js";const o="/obsidian-vitepress-docs/assets/Pasted%20image%2020231222145246.Bmqrrz3I.png",_=JSON.parse('{"title":"07_DOM 的 Diffing 算法","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/08 React/07_DOM的Diffing算法.md","filePath":"前端技术/08 React/07_DOM的Diffing算法.md"}'),l={name:"前端技术/08 React/07_DOM的Diffing算法.md"};function n(f,e,d,s,c,p){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="_07-dom-的-diffing-算法" tabindex="-1">07_DOM 的 Diffing 算法 <a class="header-anchor" href="#_07-dom-的-diffing-算法" aria-label="Permalink to &quot;07_DOM 的 Diffing 算法&quot;">​</a></h1><h2 id="key-的作用" tabindex="-1">key 的作用 <a class="header-anchor" href="#key-的作用" aria-label="Permalink to &quot;key 的作用&quot;">​</a></h2><ul><li><p>key 是虚拟 DOM 对象的标识, 在更新显示时 key 起着极其重要的作用。</p></li><li><p>当状态中的数据发生变化时，react 会根据【新数据】生成【新的虚拟 DOM】, 随后 React 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 比较，比较规则如下：</p><ol><li>旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：<br> a. 若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM<br> b. 若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li><li>旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，根据数据创建新的真实 DOM，随后渲染到到页面</li></ol></li></ul><blockquote><p>[!hint]+ 用 index 作为 key 可能会引发的问题：</p><ol><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题, 但效率低。</li><li>如果结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==&gt; 界面有问题。</li><li>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。</li></ol></blockquote><ul><li>开发中如何选择 key?<br> 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。 如果确定只是简单的展示数据，用 index 也是可以的。</li></ul><p><img src="'+o+'" alt="Pasted image 20231222145246.png"></p><h2 id="diff-原理【待补】" tabindex="-1">diff 原理【待补】 <a class="header-anchor" href="#diff-原理【待补】" aria-label="Permalink to &quot;diff 原理【待补】&quot;">​</a></h2><p><a href="https://juejin.cn/post/7131741751152214030?searchId=20231222161054626A2F2D9081D4719D39" target="_blank" rel="noreferrer">https://juejin.cn/post/7131741751152214030?searchId=20231222161054626A2F2D9081D4719D39</a></p><p><a href="https://juejin.cn/post/7117051812540055588" target="_blank" rel="noreferrer">https://juejin.cn/post/7117051812540055588</a></p><p>在 16 之前，React 是直接递归渲染 vdom 的，setState 会触发重新渲染，对比渲染出的新旧 vdom，对差异部分进行 dom 操作。</p><p>在 16 之后，为了优化性能，会先把 vdom 转换成 fiber，也就是从树转换成链表，然后再渲染。整体渲染流程分成了两个阶段：</p><ul><li>render 阶段：从 vdom 转换成 fiber，并且对需要 dom 操作的节点打上 effectTag 的标记</li><li>commit 阶段：对有 effectTag 标记的 fiber 节点进行 dom 操作，并执行所有的 effect 副作用函数。</li></ul><p>从 vdom 转成 fiber 的过程叫做 <strong>reconcile（调和）</strong>，这个过程是可以打断的，由 scheduler 调度执行。</p>',13)]))}const m=i(l,[["render",n]]);export{_ as __pageData,m as default};
