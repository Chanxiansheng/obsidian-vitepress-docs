import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.CIivgcbp.js";const E=JSON.parse('{"title":"错误处理与调试","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/10工程化与实践/错误处理与调试.md","filePath":"前端技术/03 JavaScript/10工程化与实践/错误处理与调试.md"}'),n={name:"前端技术/03 JavaScript/10工程化与实践/错误处理与调试.md"};function l(h,s,p,r,k,o){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="错误处理与调试" tabindex="-1">错误处理与调试 <a class="header-anchor" href="#错误处理与调试" aria-label="Permalink to &quot;错误处理与调试&quot;">​</a></h1><h2 id="浏览器错误报告" tabindex="-1">浏览器错误报告 <a class="header-anchor" href="#浏览器错误报告" aria-label="Permalink to &quot;浏览器错误报告&quot;">​</a></h2><p>所有主流桌面浏览器，包括 IE/Edge、Firefox、Safari、Chrome 和 Opera，都提供了向用户报告错误的机制。</p><h3 id="桌面控制台" tabindex="-1">桌面控制台 <a class="header-anchor" href="#桌面控制台" aria-label="Permalink to &quot;桌面控制台&quot;">​</a></h3><p>所有现代桌面浏览器都会通过控制台暴露错误。这些错误可以显示在开发者工具内嵌的控制台中。 在前面提到的所有浏览器中，访问开发者工具的路径是相似的。可能最简单的查看错误的方式就是在页面上单击鼠标右键，然后在上下文菜单中选择 Inspect（检查）或 Inspect Element（检查元素），然后再单击 Console（控制台）选项卡。</p><p>要直接进入控制台，不同操作系统和浏览器支持不同的快捷键。</p><table tabindex="0"><thead><tr><th>​<strong>浏览器</strong>​</th><th>​<strong>Windows/Linux</strong>​</th><th>​<strong>Mac</strong>​</th></tr></thead><tbody><tr><td>Chrome</td><td>Ctrl+Shift+J</td><td>Cmd+Opt+J</td></tr><tr><td>Firefox</td><td>Ctrl+Shfit+K</td><td>Cmd+Opt+K</td></tr><tr><td>IE/Edge</td><td>F12，然后 Ctrl+2</td><td>不适用</td></tr><tr><td>Opera</td><td>Ctrl+Shift+I</td><td>Cmd+Opt+I</td></tr><tr><td>Safari</td><td>不适用</td><td>Cmd+Opt+C</td></tr></tbody></table><h3 id="移动控制台" tabindex="-1">移动控制台 <a class="header-anchor" href="#移动控制台" aria-label="Permalink to &quot;移动控制台&quot;">​</a></h3><p>移动浏览器不会直接在设备上提供控制台界面。不过，还是有一些途径可以在移动设备中检查错误。</p><p>Chrome 移动版和 Safari 的 iOS 版内置了实用工具，支持将设备连接到宿主操作系统中相同的浏览器。然后，就可以在对应的桌面浏览器中查看错误了。这涉及设备之间的硬件连接，且要遵循不同的操作步骤，比如 Chrome 的操作步骤参见 Google Developers 网站的文章《Android 设备的远程调试入门》，Safari 的操作步骤参见 Apple Developer 网站的文章“Safari Web Inspector Guide”。</p><p>此外也可以使用第三方工具直接在移动设备上调试。Firefox 常用的调试工具是 Firebug Lite，这需要通过 JavaScript 的书签小工具向当前页面中加入 Firebug 脚本才可以。脚本运行后，就可以直接在移动浏览器上打开调试界面。Firebug Lite 也有面向其他浏览器（如 Chrome）的版本。</p><h2 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-label="Permalink to &quot;错误处理&quot;">​</a></h2><h3 id="try-catch-语句" tabindex="-1">try/catch 语句 <a class="header-anchor" href="#try-catch-语句" aria-label="Permalink to &quot;try/catch 语句&quot;">​</a></h3><p>ECMA-262 第 3 版新增了 <code>try/catch</code> 语句，作为在 JavaScript 中处理异常的一种方式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 可能出错的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 始终需要执行的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果 try 块中有代码发生错误，代码会立即退出执行，并跳到 catch 块中。catch 块此时接收到一个对象，该对象包含发生错误的相关信息。</p><p>错误对象中暴露的实际信息因浏览器而异，但至少包含保存错误消息的 <strong>message</strong> 属性，向用户显示错误消息。ECMA-262 也指定了定义错误类型的 <strong>name</strong> 属性。</p><p><code>try/catch</code> 语句中可选的 finally 子句始终运行。如果 try 块中的代码运行完，则接着执行 finally 块中的代码。如果出错并执行 catch 块中的代码，则 finally 块中的代码仍执行<br> ==只要代码中包含了 finally 子句，try 块或 catch 块中的 return 语句就会被忽略。==</p><p>代码执行过程中会发生各种类型的错误。每种类型都会对应一个错误发生时抛出的错误对象。ECMA-262 定义了以下 8 种错误类型：</p><ol><li>Error：基类，其他错误都继承自它。</li><li>InternalError：JS 引擎内部错误，如递归过深，特定环境（如 Firefox）使用。</li><li>EvalError：eval 函数使用不当，现在较少见。</li><li>RangeError：数值超出有效范围。</li><li>ReferenceError：引用未声明变量或无法访问的变量。</li><li>SyntaxError：语法错误，代码无法解析。</li><li>TypeError：变量或参数类型不正确。</li><li>URIError：URI 处理函数参数无效。</li></ol><p>不同的错误类型可用于为异常提供更多信息，以便实现适当的错误处理逻辑。在 try/catch 语句的 catch 块中，可以使用 instanceof 操作符确定错误的类型，比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypeError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理类型错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReferenceError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理引用错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理所有其他类型的错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="throw-抛出错误" tabindex="-1">throw 抛出错误 <a class="header-anchor" href="#throw-抛出错误" aria-label="Permalink to &quot;throw 抛出错误&quot;">​</a></h3><p>与 try/catch 语句对应的一个机制是 throw 操作符，用于在任何时候抛出自定义错误。throw 操作符必须有一个值，但值的类型不限。<br><code>throw &quot;message&quot;</code></p><p>可以通过内置的错误类型来模拟浏览器错误。每种错误类型的构造函数都只接收一个参数，就是错误消息。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Something bad happened.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SyntaxError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I don&#39;t like your syntax.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InternalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;I can&#39;t do that, Dave.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypeError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;What type of variable do you take me for?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RangeError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Sorry, you just don&#39;t have the range.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EvalError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;That doesn&#39;t evaluate.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URIError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Uri, is that you?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReferenceError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;You didn&#39;t cite your references properly.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>此外，通过继承 Error（第 6 章介绍过继承）也可以创建自定义的错误类型。创建自定义错误类型时，需要提供 name 属性和 message 属性，比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomError</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CustomError&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>使用适当的信息创建自定义错误可以有效提高代码的可维护性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 参数类型判断</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;process(): Argument must be an array.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="error-事件" tabindex="-1">error 事件 <a class="header-anchor" href="#error-事件" aria-label="Permalink to &quot;error 事件&quot;">​</a></h3><p>任何没有被 try/catch 语句处理的错误都会在 window 对象上触发 error 事件。<br> 在 onerror 事件处理程序中，任何浏览器都不会传入 event 对象。相反，会传入 3 个参数：错误消息、发生错误的 URL 和行号。<br> onerror 事件处理程序需要使用 DOM Level 0 技术来指定，因为它不遵循 DOM Level 2 Events 标准格式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>==可以返回 false 来阻止浏览器默认报告错误的行为。==<br> 通过返回 false，这个函数实际上就变成了整个文档的 try/catch 语句，可以捕获所有未处理的运行时错误。</p><h2 id="错误处理策略" tabindex="-1">错误处理策略 <a class="header-anchor" href="#错误处理策略" aria-label="Permalink to &quot;错误处理策略&quot;">​</a></h2><h3 id="静态代码分析器" tabindex="-1">静态代码分析器 <a class="header-anchor" href="#静态代码分析器" aria-label="Permalink to &quot;静态代码分析器&quot;">​</a></h3><p>通过在代码构建流程中添加静态代码分析或代码检查器（linter），可以预先发现非常多的错误。<br> 常用的静态分析工具是 JSHint、JSLint、Google Closure 和 TypeScript。</p><p>==TypeScript 是目前最流行的静态代码分析器。==</p><p>静态代码分析器要求使用类型、函数签名及其他指令来注解 JavaScript，以此描述程序如何在基本可执行代码之外运行。分析器会比较注解和 JavaScript 代码的各个部分，对在实际运行时可能出现的潜在不兼容问题给出提醒。</p><h3 id="识别错误" tabindex="-1">识别错误 <a class="header-anchor" href="#识别错误" aria-label="Permalink to &quot;识别错误&quot;">​</a></h3><p>因为 JavaScript 是松散类型的，不会验证函数参数，所以很多错误只有在代码真正运行起来时才会出现。通常，需要注意 3 类 错误：</p><ul><li><h6 id="类型转换错误" tabindex="-1">类型转换错误 <a class="header-anchor" href="#类型转换错误" aria-label="Permalink to &quot;类型转换错误&quot;">​</a></h6></li></ul><p><strong>类型转换错误</strong>的主要原因是使用了会自动改变某个值的数据类型的操作符或语言构造。<br> 使用等于（ <code>==</code>）或不等于（<code>!=</code>）操作符，以及在 if、for 或 while 等流控制语句中使用非布尔值，经常会导致类型转换错误。</p><ul><li><h6 id="数据类型错误" tabindex="-1">数据类型错误 <a class="header-anchor" href="#数据类型错误" aria-label="Permalink to &quot;数据类型错误&quot;">​</a></h6></li></ul><p>因为 JavaScript 是松散类型的，所以变量和函数参数都不能保证会使用正确的数据类型。开发者需要自己检查数据类型，确保不会发生错误。数据类型错误常发生在将意外值传给函数的时候。</p><h3 id="区分重大与非重大错误" tabindex="-1">区分重大与非重大错误 <a class="header-anchor" href="#区分重大与非重大错误" aria-label="Permalink to &quot;区分重大与非重大错误&quot;">​</a></h3><p>任何错误处理策略中一个非常重要的方面就是确定某个错误是否为重大错误。</p><p>具有以下一个或多个特性的错误属于非重大错误：</p><ul><li>不会影响用户的主要任务；</li><li>只会影响页面中某个部分；</li><li>可以恢复；</li><li>重复操作可能成功。</li></ul><p>另一方面，重大错误具备如下特性：</p><ul><li>应用程序绝对无法继续运行；</li><li>错误严重影响了用户的主要目标；</li><li>会导致其他错误发生</li></ul><h3 id="把错误记录到服务器中" tabindex="-1">把错误记录到服务器中 <a class="header-anchor" href="#把错误记录到服务器中" aria-label="Permalink to &quot;把错误记录到服务器中&quot;">​</a></h3><p>Web 应用程序开发中的一个常见做法是建立中心化的错误日志存储和跟踪系统。数据库和服务器错误正常写到日志中并按照常用 API 加以分类。对复杂的 Web 应用程序而言，最好也把 JavaScript 错误发送回服务器记录下来。这样做可以把错误记录到与服务器相同的系统，只要把它们归类到前端错误即可。使用相同的系统可以进行相同的分析，而不用考虑错误来源。</p><h2 id="调试技术" tabindex="-1">调试技术 <a class="header-anchor" href="#调试技术" aria-label="Permalink to &quot;调试技术&quot;">​</a></h2><h3 id="console-对象" tabindex="-1">console 对象 <a class="header-anchor" href="#console-对象" aria-label="Permalink to &quot;console 对象&quot;">​</a></h3><p>所有主流浏览器都有 JavaScript 控制台，该控制台可用于查询 JavaScript 错误。另外，这些浏览器都支持通过 console 对象直接把 JavaScript 消息写入控制台，这个对象包含如下方法。</p><ul><li><code>error(message)</code>：在控制台中记录错误消息。</li><li><code>warn(message)</code>：在控制台中记录警告消息。</li><li><code>info(message)</code>：在控制台中记录信息性内容。</li><li><code>log(message)</code>：在控制台记录常规消息。</li><li><code>debug(message)</code>：在控制台中记录调试消息。（须开启）</li></ul><p>记录消息时使用的方法不同，消息显示的样式也不同。错误消息包含一个红叉图标，而警告消息包含一个黄色叹号图标。</p><p>console 对象也有一些高级方法：</p><p><code>console.clear()</code>：用于清除开发者控制台。</p><p><code>console.assert(条件, message)</code>：用于测试条件，并只在条件为 false 时向控制台输出错误消息。</p><p><code>console.group()</code>、<code>console.groupEnd()</code>、<code>console.groupCollapsed()</code>：用于分组相关的控制台消息。<br><code>console.group()</code> 开始新分组；<br><code>console.groupEnd()</code> 结束当前组；<br><code>console.groupCollapsed()</code> 开始一个折叠的新分组。</p><p><code>console.count(label)</code> 和 <code>console.countReset(label)</code> 用于对特定代码的执行进行计数。接收一个可选的标签作为参数。</p><p><code>console.time()</code>、<code>console.timeEnd()</code>、<code>console.timeLog()</code> 用于计量代码的执行时间。<br><code>console.time(label)</code> 用提供的标签参数来启动计时器。<br><code>console.timeLog(label)</code> 输出中间消息及计时器启动经过的时间。<br><code>console.timeEnd(label)</code> 结束计时器并返回经过的时间。</p><p><code>console.dir()</code>、<code>console.dirxml()</code>、<code>console.table()</code> 用于以更易读的方式显示对象和数组。<br><code>console.dir()</code> 用分层结构显示对象，方便查看对象的属性和方法。<br><code>console.dirxml()</code> 专门用来以分层结构显示 XML 和 HTML 文档。<br><code>console.table()</code> 用表格来显示数组或对象。</p><p><code>console.trace()</code> 用于把栈跟踪信息输出到控制台。</p><h3 id="理解控制台运行时" tabindex="-1">理解控制台运行时 <a class="header-anchor" href="#理解控制台运行时" aria-label="Permalink to &quot;理解控制台运行时&quot;">​</a></h3><p>浏览器控制台是个<strong>读取 - 求值 - 打印 - 循环（REPL，read-eval-print-loop）</strong>，与页面的 JavaScript 运行时并发。<br> 这个运行时就像浏览器对新出现在 DOM 中的 <code>&lt;script&gt;</code> 标签求值一样。在控制台中执行的命令可以像页面级 JavaScript 一样访问全局和各种 API。控制台中可以执行任意数量的代码，与它可能会阻塞的任何页面级代码一样。修改、对象和回调都会保留在 DOM 和运行时中。</p><p>JavaScript 运行时会限制不同窗口可以访问哪些内容，因而在所有主流浏览器中都可以选择在哪个窗口中执行 JavaScript 控制台输入。你所执行的代码不会有特权提升，仍会受跨源限制和其他浏览器施加的控制规则约束。</p><p>控制台运行时也会集成开发者工具，提供常规 JavaScript 开发中所没有的上下文调试工具。其中一个非常有用的工具是最后点击选择器，所有主流浏览器都会提供。</p><h3 id="debugger-断点调试" tabindex="-1">debugger 断点调试 <a class="header-anchor" href="#debugger-断点调试" aria-label="Permalink to &quot;debugger 断点调试&quot;">​</a></h3><p>在所有主流浏览器中都可以使用的还有 JavaScript 调试器。ECMAScript 5.1 规范定义了 debugger 关键字，用于调用可能存在的调试功能。如果没有相关的功能，这条语句会被简单地跳过。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pauseExecution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Will print before breakpoint&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	debugger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Will not print until breakpoint continues&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码。此外，还可以执行标准的代码调试器操作（单步进入、单步跳过、继续，等等）。</p><p>浏览器也支持在开发者工具的源代码标签页中选择希望设置断点的代码行来手动设置断点（不使用 debugger 关键字）。这样设置的断点与使用 debugger 关键字设置的一样，只是不会在不同浏览器会话之间保持。</p><h3 id="在页面中打印消息" tabindex="-1">在页面中打印消息 <a class="header-anchor" href="#在页面中打印消息" aria-label="Permalink to &quot;在页面中打印消息&quot;">​</a></h3><p>另一种常见的打印调试消息的方式是把消息写到页面中指定的区域。这个区域可以是所有页面中都包含的元素，但仅用于调试目的；也可以是在需要时临时创建的元素。</p>`,77)]))}const c=i(n,[["render",l]]);export{E as __pageData,c as default};
