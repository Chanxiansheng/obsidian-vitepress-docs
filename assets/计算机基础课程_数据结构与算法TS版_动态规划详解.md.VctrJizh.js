import{_ as r,c as o,o as n,ae as a}from"./chunks/framework.CIivgcbp.js";const p=JSON.parse('{"title":"动态规划详解","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/数据结构与算法TS版/动态规划详解.md","filePath":"计算机基础课程/数据结构与算法TS版/动态规划详解.md"}'),s={name:"计算机基础课程/数据结构与算法TS版/动态规划详解.md"};function l(e,t,i,g,_,c){return n(),o("div",null,t[0]||(t[0]=[a('<h1 id="动态规划详解" tabindex="-1">动态规划详解 <a class="header-anchor" href="#动态规划详解" aria-label="Permalink to &quot;动态规划详解&quot;">​</a></h1><h3 id="什么是动态规划" tabindex="-1">什么是动态规划？ <a class="header-anchor" href="#什么是动态规划" aria-label="Permalink to &quot;什么是动态规划？&quot;">​</a></h3><p>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p><h3 id="动态规划核心思想" tabindex="-1">动态规划核心思想 <a class="header-anchor" href="#动态规划核心思想" aria-label="Permalink to &quot;动态规划核心思想&quot;">​</a></h3><p>动态规划是一种<strong>通过把原问题分解为相对简单的子问题来求解复杂问题的方法</strong>。它的核心思想是：</p><ul><li>将复杂问题分解成<strong>相互关联</strong>的子问题</li><li>通过<strong>解决子问题</strong>来解决原问题</li><li>保存<strong>已解决的子问题结果，避免重复计算</strong></li></ul><p>能用动态规划思路解决的问题一般有下面的特点：</p><ol><li><strong>最优子结构</strong>：问题的最优解包含子问题的最优解；</li><li><strong>重叠子问题</strong>：在求解过程中，相同的子问题会重复出现；</li><li><strong>状态转移</strong>：找到子问题之间的关系，通过<strong>状态转移方程</strong>来解决问题。</li></ol><p>解决动态规划问题时，我们需要按照以下步骤系统地思考和解决：</p><ol><li><strong>定义状态</strong>：首先要思考如何用数学语言描述问题。定义状态是整个解题过程中最关键的一步，它决定了我们如何存储和使用计算结果。我们需要仔细思考：要解决的问题需要哪些变量来表示？这些状态通常会以数组的形式存储下来。<strong>一个好的状态定义应该能够完整地描述问题在某个阶段的情况</strong>。</li><li>找出<strong>状态转移方程</strong>：当我们定义好状态后，需要思考状态之间是如何转移的。也就是说，<strong>如何从已知的状态推导出新的状</strong>态，状态转移方程是解决问题的核心，一般想明白状态转移方程问题就解决了。</li><li>确定<strong>初始状态和边界条件</strong>：有了状态转移方程后，我们需要确定问题的初始状态。同时，我们还需要考虑一些特殊情况，比如输入为 0 或负数时应该如何处理。</li><li>按照<strong>状态转移方程求解</strong>：最后一步是实际求解过程。我们通常会按照一定的顺序（比如从小到大）来计算每个状态的值。在这个过程中，我们使用已经计算出的状态值，通过状态转移方程来得到新的状态值。这个过程需要特别注意计算的顺序，<strong>确保在计算某个状态时，它依赖的所有状态都已经计算出来</strong>了。</li></ol>',10)]))}const h=r(s,[["render",l]]);export{p as __pageData,h as default};
