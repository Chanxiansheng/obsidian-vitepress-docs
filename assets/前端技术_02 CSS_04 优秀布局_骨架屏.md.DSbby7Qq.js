import{_ as l,c as a,o as i,ae as r}from"./chunks/framework.CIivgcbp.js";const t="/obsidian-vitepress-docs/assets/Pasted%20image%2020240511182412.CRNy7gAc.png",_=JSON.parse('{"title":"骨架屏","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/02 CSS/04 优秀布局/骨架屏.md","filePath":"前端技术/02 CSS/04 优秀布局/骨架屏.md"}'),o={name:"前端技术/02 CSS/04 优秀布局/骨架屏.md"};function n(s,e,p,u,c,d){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="骨架屏" tabindex="-1">骨架屏 <a class="header-anchor" href="#骨架屏" aria-label="Permalink to &quot;骨架屏&quot;">​</a></h1><p><a href="https://juejin.cn/post/7228977496515575866?searchId=20240511182112CFEB7E5AA03323D6D62F" target="_blank" rel="noreferrer">为什么各大网站都选择骨架屏？谈谈骨架屏对网站的优化的重要性 - 掘金</a><br><a href="https://juejin.cn/post/6844903661726859272?searchId=20240511182112CFEB7E5AA03323D6D62F" target="_blank" rel="noreferrer">Vue项目骨架屏注入实践 - 掘金</a></p><h2 id="什么是骨架屏" tabindex="-1">什么是骨架屏？ <a class="header-anchor" href="#什么是骨架屏" aria-label="Permalink to &quot;什么是骨架屏？&quot;">​</a></h2><ul><li>平常在我们点进一个网站的时候，或许会看见一个一些动态的灰色条状物，他们代替着本应该出现在这里的内容，作为一种加载态的展现方式而呈现，这里我们就拿掘金来举例，进入掘金的首页，按下 F12，进入开发者模式后点击 Network，选择低速 3G，这时候我们再刷新一次，就可以很清楚的看见一个灰色块了<br><img src="'+t+'" alt="Pasted image 20240511182412.png"></li><li>而这里的灰色块，便是骨架屏，现在绝大多数的大厂的网站都会用骨架屏的方案来代替原先的转圈 loading 了，虽然都是加载态的一种方式，但是相较于干巴巴的转圈，这种在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，填充好本应该展现的内容，给人一种创造即时转换的错觉，这也是为什么各个大厂都愿意选择骨架屏来作为加载态的原因。</li></ul><blockquote><p>骨架屏（Skeleton Screen）是一个低保真度的用户界面，信息逐渐加载到其中。它为用户提供了一个视觉提示，即内容正在加载到每个 UI 元素中</p></blockquote><h2 id="骨架屏的好处" tabindex="-1">骨架屏的好处 <a class="header-anchor" href="#骨架屏的好处" aria-label="Permalink to &quot;骨架屏的好处&quot;">​</a></h2><ul><li>无论是 Facebook、YouTube，还是国内的知乎，哔哩哔哩，他们都无一例外的采用了骨架屏的方式，这也侧面说明了目前对于加载态的一个还不错的解决方案就是骨架屏，这里我们来讲一下骨架屏的好处： <ol><li>提高页面加载速度：骨架屏可以在页面真正加载完毕之前，展示出网页的基本结构和布局。这样，用户可以在等待其他资源加载的过程中，看到页面的基本信息，从而降低等待时间，提高用户体验</li><li>提升页面响应速度：如果网站的响应速度很慢，可能会导致用户流失。骨架屏技术可以优化页面响应速度，使用户能够更快地看到网页的基本信息。这样，用户会感到网页更加互动和易用，而不是等待一个加载状态</li><li>提高页面可访问性：骨架屏技术可以提高网站的可访问性。对于使用屏幕阅读器、放大镜等辅助技术的用户，骨架屏可以为他们提供更好的用户体验，因为它们可以看到页面的基本结构和布局</li><li>提高用户满意度：用户访问一个网站时，第一印象很重要。如果网站加载慢，用户可能会感到失望，从而流失。骨架屏技术可以提供一个更快、更流畅的用户体验，从而增加用户满意度</li></ol></li></ul><h2 id="骨架屏的原理" tabindex="-1">骨架屏的原理 <a class="header-anchor" href="#骨架屏的原理" aria-label="Permalink to &quot;骨架屏的原理&quot;">​</a></h2><ul><li><p>在进行实际项目开发的时候，一般会让你实现空态和加载态，后端会给你一个请求接口返回的参数，比如这里我们将 sending 作为请求完接口返回的参数，当 <code>sending==0</code> 的时候，我们这时候就可以返回空态，也就是我们常见的报错页面，这些一般需要我们单独去写一份的；当 <code>sending==1</code> 的时候，我们则进入加载态，也就是我们常见的加载页面，当资源请求完成后再进行页面的替换即可，这也就是骨架屏的基本实现原理</p></li><li><p>目前市面上的骨架屏方案大致有三种：</p><ol><li>手动维护骨架屏的代码 <ul><li>手写 HTML、CSS 的方式为目标页定制骨架屏 做法可以参考&lt;<a href="https://segmentfault.com/a/1190000014832185" target="_blank" rel="noreferrer">Vue页面骨架屏注入实践</a>&gt;，主要思路就是使用 vue-server-renderer 这个本来用于服务端渲染的插件，用来把我们写的.vue 文件处理为 HTML，插入到页面模板的挂载点中，完成骨架屏的注入。这种方式不甚文明，如果页面样式改变了，还得改一遍骨架屏，增加了维护成本。 骨架屏的样式实现参考 CodePen</li></ul></li><li>使用图片作为骨架屏 <ul><li>使用图片作为骨架屏； 简单暴力，让 UI 同学花点功夫吧哈哈；小米商城的移动端页面采用的就是这个方法，它是使用了一个 Base64 的图片来作为骨架屏。</li></ul></li><li>自动生成骨架屏</li></ol></li><li><p>手动维护骨架屏的代码的优势是可定制化高，但相对的缺点就是这无疑会增加开发者的心智负担；而使用图片作为骨架屏，虽然也比较的耗费人力，但和开发的关系不大了😂；重点来说一下第三种，自动生成骨架屏。</p></li></ul><h2 id="自动生成骨架屏" tabindex="-1">自动生成骨架屏 <a class="header-anchor" href="#自动生成骨架屏" aria-label="Permalink to &quot;自动生成骨架屏&quot;">​</a></h2><ul><li><p>自动生成骨架屏大大降低了开发成本，但它的缺陷是很明显的，很难做到一套方案吃遍天下鲜。比如 Facebook 的自动化骨架屏技术，如果放在一个主打视频的网站，如 YouTube 的话，多半会出现一些兼容问题，并且如果业务需求比较的复杂的时候，这时候还是需要我们自己去手动实现一个骨架屏</p></li><li><p>虽然仍然存在一定的问题，但如果是在一个大项目里面，是可以去自己实现一个自动化生成骨架屏的，因为这时候更多的是为自己的项目而服务，不需要去考虑其他的情况，相对来说出现兼容问题的可能性也要低些，这里来介绍一下饿了么开源的 webpack 插件，<strong>page-skeleton-webpack-plugin</strong>，该插件根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。</p></li><li><p>插件原理：利用 Puppeteer 控制无头 Chrome 在服务端打开正在开发中的页面，并在等待页面加载完成后，通过删除或添加元素并使用层叠样式覆盖现有元素，以灰色块的形式隐藏文本、图像和其他内容，同时保留页面布局和样式。然后将修改后的 HTML 和 CSS 样式提取出来，并使用 webpack 插件将其注入到最终生成的 HTML 中</p></li><li><p>下面按照生成骨架屏的步骤来进行解析：</p><ol><li>将页面分块 <ul><li>page-skeleton-webpack-plugin 插件将页面划分成不同的块，如文本块、图片块、按钮快等，通过分块的方式对每个块进行处理，这样也就不会破坏页面的整体样式和布局，当插件自动生成完骨架屏的时候，也不会出现与真实页面布局差异过大的问题</li></ul></li><li>针对不同的块进行骨架屏化 <ul><li>这里可以查看一种自动化生成骨架屏的方案，这篇文章详细介绍了不同的块是如何进行处理的，这里我就不再过多的去赘述了</li></ul></li><li>将骨架屏打包进项目 <ul><li>这里要注意的一点是，我们所看见的骨架屏的展示，都是在开发过程中的，之所以没有选择在构建的时候去生成，是为了方便我们在开发的时候可以事实的进行观测，以方便我们随时进行修改</li></ul></li></ol></li></ul>',11)]))}const b=l(o,[["render",n]]);export{_ as __pageData,b as default};
