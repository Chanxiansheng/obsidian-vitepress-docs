import{_ as o,c as a,o as i,ae as t}from"./chunks/framework.CIivgcbp.js";const h=JSON.parse('{"title":"客户端缓存","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/06_客户端缓存.md","filePath":"计算机基础课程/网络/01 网络原理/06_客户端缓存.md"}'),r={name:"计算机基础课程/网络/01 网络原理/06_客户端缓存.md"};function d(l,e,c,s,n,p){return i(),a("div",null,e[0]||(e[0]=[t('<h1 id="客户端缓存" tabindex="-1">客户端缓存 <a class="header-anchor" href="#客户端缓存" aria-label="Permalink to &quot;客户端缓存&quot;">​</a></h1><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><p>强缓存，指的是<strong>让浏览器强制缓存服务器提供的资源</strong>。当客户端再次发送请求时，浏览器会先从缓冲中读取，而非向服务器发送请求。</p><p>服务器通过设置 http 中 header 的 <code>Expires</code> 和 <code>cache-control</code> 字段告诉浏览器缓存的有效期。</p><ul><li><code>Expires</code>：值为绝对时间，不过 Expires 是 HTTP 1.0 的东西，现在默认浏览器均默认使用 HTTP 1.1</li><li><code>Cache-Control</code>：值为相对时间，如果与 Expires 同时设置的话，其优先级高于 Expires。</li></ul><p><code>cache-control</code> 有下面几个比较常用的设置值：</p><ul><li>-max-age：设置失效时间，客户端在这个有效期内，如果又请求该资源，就直接读取缓存</li><li>-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则从缓存中取数据</li><li>-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求。</li><li>-public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</li><li>-private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</li></ul><p><em>注意：这种方法会有一个固定时间，所带来的问题是如果服务器数据进行了更新，但是还没有到强缓存的过期时间，则数据无法更新。</em></p><p>强缓存分为<strong>from disk cache 硬盘缓存</strong>和<strong>from memory cache 内存缓存</strong>。</p><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><p>协商缓存就是<strong>通过服务器来判断缓存是否可用</strong>，从而判断是否返回新的资源。</p><p><code>Last-Modify</code> 搭配 <code>If-Modify-Since</code></p><ul><li><p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，<strong>Last-modify 是该资源的最后修改时间</strong>。</p></li><li><p>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值服务端 header 中返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p></li></ul><p><code>Etag</code> 搭配 <code>If-None-Match</code></p><ul><li><p>web 服务器响应请求时，会在 header 中加一个 Etag 用来告诉浏览器当前<strong>资源在服务器的唯一标识</strong>（生成规则由服务器决定，hash 值）。</p></li><li><p>则再次向 web 服务器请求时带上头 If-None-Match （Etag 的值）。web 服务器收到请求后将 If-None-Match 与 Etag 进行比对，决定是否命中协商缓存。</p></li></ul><p>ETag 和 Last-Modified 的作用和用法，他们的区别：</p><ol><li>Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；</li><li>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值；</li><li><strong>在优先级上，服务器校验优先考虑 Etag</strong>。<br> 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200。</li></ol>',17)]))}const _=o(r,[["render",d]]);export{h as __pageData,_ as default};
