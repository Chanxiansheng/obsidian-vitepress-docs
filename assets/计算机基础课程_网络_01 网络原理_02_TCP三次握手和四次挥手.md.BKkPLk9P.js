import{_ as a,c as s,o as i,ae as t}from"./chunks/framework.CIivgcbp.js";const l="/obsidian-vitepress-docs/assets/2c03ae383f2b1496254e61e5e36a25ac_ON0Z5aJDq0.CiwoaIes.png",o="/obsidian-vitepress-docs/assets/image_RDlwG1ul7l.CQ-ja1Nd.png",r="/obsidian-vitepress-docs/assets/3c08ee7c0d49646b114229dfedf94557_nxzqDvgoaU.DXhSwRsi.png",c="/obsidian-vitepress-docs/assets/image_vZuVscfDeM.ChEzSz3-.png",C=JSON.parse('{"title":"TCP 三次握手和四次挥手","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/01 网络原理/02_TCP三次握手和四次挥手.md","filePath":"计算机基础课程/网络/01 网络原理/02_TCP三次握手和四次挥手.md"}'),n={name:"计算机基础课程/网络/01 网络原理/02_TCP三次握手和四次挥手.md"};function _(p,e,d,m,h,q){return i(),s("div",null,e[0]||(e[0]=[t('<h1 id="tcp-三次握手和四次挥手" tabindex="-1">TCP 三次握手和四次挥手 <a class="header-anchor" href="#tcp-三次握手和四次挥手" aria-label="Permalink to &quot;TCP 三次握手和四次挥手&quot;">​</a></h1><h2 id="名词描述" tabindex="-1">名词描述 <a class="header-anchor" href="#名词描述" aria-label="Permalink to &quot;名词描述&quot;">​</a></h2><ul><li>seq（sequence number）序列号通过算法随机生成的</li><li>ack（acknowledgement number）确认号 ack = seq + 1</li><li>ACK （acknowledgement）确定序列号有效</li><li>SYN（synchronous）发起新连接</li><li>FIN （FINISH）完成</li></ul><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><p><img src="'+l+'" alt=""></p><p>三次握手很像对讲机通话，一个发送，一个接受，也可以反之。</p><ol><li>首先客户端会发送一个段这个段就是 SYN 报文，想跟服务端进行连接，并且会携带一个序列号，下次发送的数据序列号还会进行 +1。</li><li>服务端收到了 SYN + seq 字段之后，服务端也会生成一个对应服务端 seq 序列号，这时候就会携带 ACK 确认号，表示之前的 SYN 收到了，还会有一个小写的 ack 把客户端的 seq + 1。</li><li>客户端收到服务端的响应之后会发送一个 ACK 确定序列号有效，并且还会发送 seq 注意这里的 seq 会通过算法计算出来是否跟服务端的 ack 值相等，然后会发送一个新的 ack 这里的 ack 是服务端的 seq 值 +1，确保一切正常。</li></ol><p><img src="'+o+'" alt=""></p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><p>四次挥手客户端和服务端均可发起，下以客户端发起为例：</p><p><img src="'+r+'" alt=""></p><ol><li>断开连接服务端和客户端都可以主动发起我们拿客户端举例，客户端进行断开操作先发送 FIN 包生成客户端的 seq 序列号随后进入 wait1 状态 ,这是第一次挥手。</li><li>服务端收到 FIN 包表示自己进入了关闭等待状态，然后向客户端使用 ack 验证，验证成功打上 ACK 标记，随后生成服务端的 seq 值发送给客户端，这是第二次挥手，服务端此时还可以发送未完成的数据。</li><li>等待服务端所有任务操作完成之后服务端开始进入最后确认状态，向客户端发送 FIN 包,并且验证 ack，使用客户端第一次的 seq + 1 去验证，验证成功打上 ACK 标记，并且生成一个新的序列号 seq 发送给客户端，这是第三次挥手。</li><li>客户端收到之后进入超时等待状态 2MSL（1-4 分钟），经过等到后客户端关闭连接，而服务端收到信息验证完成 ack 成功之后打上 ACk 标记随后将关闭连接。</li></ol><ul><li>为什么需要超时等待时间?</li></ul><p>这是为了保证服务端收到 ACK 包，假设如果没有 2MSL 的等待时间，ACK 包丢失了，那服务端将永远不会断开连接，有了 2MSL，如果一旦发生丢包将会进行超时重传，实现可靠连接。</p><p><img src="'+c+'" alt=""></p>',15)]))}const k=a(n,[["render",_]]);export{C as __pageData,k as default};
