import{_ as s,c as a,o as l,ag as t}from"./chunks/framework.-ewJmwvT.js";const o=JSON.parse('{"title":"23 最佳实践","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/10工程化与实践/最佳实践.md","filePath":"前端技术/03 JavaScript/10工程化与实践/最佳实践.md"}'),h={name:"前端技术/03 JavaScript/10工程化与实践/最佳实践.md"};function n(e,i,p,k,r,d){return l(),a("div",null,i[0]||(i[0]=[t(`<h1 id="_23-最佳实践" tabindex="-1">23 最佳实践 <a class="header-anchor" href="#_23-最佳实践" aria-label="Permalink to &quot;23 最佳实践&quot;">​</a></h1><h2 id="可维护性" tabindex="-1">可维护性 <a class="header-anchor" href="#可维护性" aria-label="Permalink to &quot;可维护性&quot;">​</a></h2><p>通常，说代码“可维护”就意味着它具备如下特点。</p><ul><li>容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。</li><li>符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。</li><li>容易适配：即使数据发生变化也不用完全重写。</li><li>容易扩展：代码架构经过认真设计，支持未来扩展核心功能。</li><li>容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。</li></ul><h3 id="编码规范" tabindex="-1">编码规范 <a class="header-anchor" href="#编码规范" aria-label="Permalink to &quot;编码规范&quot;">​</a></h3><h6 id="可读性" tabindex="-1">可读性 <a class="header-anchor" href="#可读性" aria-label="Permalink to &quot;可读性&quot;">​</a></h6><ol><li><p>维护良好的代码缩进；</p></li><li><p>使用代码注释。一般来说，以下这些地方应该写注释。</p><ul><li>函数和方法</li><li>大型代码块</li><li>复杂的算法</li><li>使用黑科技的代码</li></ul></li></ol><h6 id="变量和函数命名" tabindex="-1">变量和函数命名 <a class="header-anchor" href="#变量和函数命名" aria-label="Permalink to &quot;变量和函数命名&quot;">​</a></h6><p>代码中变量和函数的适当命名对于其可读性和可维护性至关重要。以下是关于命名的通用规则：</p><ul><li><strong>变量名应该是名词</strong>，例如 car 或 person。</li><li><strong>函数名应该以动词开始</strong>，例如 getName()。返回布尔值的函数通常以 is 开头，比如 isEnabled()。</li><li><strong>对变量和函数都使用符合逻辑的名称，不用担心长度</strong>。长名字的问题可以通过后处理和压缩解决。</li><li><strong>变量、函数和方法应该以小写字母开头，使用驼峰大小写（camelCase）形式</strong>，如 getName() 和 isPerson。<strong>类名应该首字母大写</strong>，如 Person、RequestFactory。<strong>常量值应该全部大写并以下划线相接</strong>，比如 REQUEST_TIMEOUT。</li><li><strong>名称要尽量用描述性和直观的词汇，但不要过于冗长。</strong> getName() 一看就知道会返回名称，而 PersonFactory 一看就知道会产生某个 Person 对象或实体。</li></ul><h6 id="变量类型透明化" tabindex="-1">变量类型透明化 <a class="header-anchor" href="#变量类型透明化" aria-label="Permalink to &quot;变量类型透明化&quot;">​</a></h6><p>有三种方式可以标明变量的数据类型。</p><ol><li><p>初始化。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> found </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 布尔值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 数值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对象</span></span></code></pre></div></li><li><p>使用匈牙利表示法。<br> 匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。对于基本数据类型，JavaScript 传统的匈牙利表示法用 o 表示对象，s 表示字符串，i 表示整数，f 表示浮点数，b 表示布尔值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bFound; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 布尔值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iCount; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 整数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sName; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oPerson; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对象</span></span></code></pre></div></li><li><p>使用类型注释。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> found </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*:Boolean*/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*:int*/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*:String*/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*:Object*/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ol><h3 id="松散耦合" tabindex="-1">松散耦合 <a class="header-anchor" href="#松散耦合" aria-label="Permalink to &quot;松散耦合&quot;">​</a></h3><p>只要应用程序的某个部分对另一个部分依赖得过于紧密，代码就会变成紧密耦合，因而难以维护。</p><h6 id="解耦-html-javascript" tabindex="-1">解耦 HTML/JavaScript <a class="header-anchor" href="#解耦-html-javascript" aria-label="Permalink to &quot;解耦 HTML/JavaScript&quot;">​</a></h6><p>Web 开发中最常见的耦合是 HTML/JavaScript 耦合。在网页中，HTML 和 JavaScript 分别代表不同层面的解决方案。HTML 是数据，JavaScript 是行为。这是因为它们之间要交互操作，需要通过不同的方式将这两种技术联系起来。</p><p>理想情况下，HTML 和 JavaScript 应该完全分开，通过外部文件引入 JavaScript，然后使用 DOM 添加行为。<br> 同时，<strong>应该避免在 JavaScript 中创建大量 HTML</strong>。HTML 渲染应该尽可能与 JavaScript 分开。</p><h6 id="解耦-css-javascript" tabindex="-1">解耦 CSS/JavaScript <a class="header-anchor" href="#解耦-css-javascript" aria-label="Permalink to &quot;解耦 CSS/JavaScript&quot;">​</a></h6><p>Web 应用程序的另一层是 CSS，主要负责页面显示。JavaScript 和 CSS 紧密相关，它们都建构在 HTML 之上，因此也经常一起使用。与 HTML 和 JavaScript 的情况类似，CSS 也可能与 JavaScript 产生紧密耦合。<strong>最常见的例子就是使用 JavaScript 修改个别样式</strong>。</p><p>现代 Web 应用程序经常使用 JavaScript 改变样式，因此虽然不太可能完全解耦 CSS 和 JavaScript，但可以让这种耦合变成更松散。这主要可以通过动态修改类名而不是样式来实现。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;edit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>通过修改元素的 CSS 类名，可以把大部分样式限制在 CSS 文件里。JavaScript 只负责修改应用样式的类名，而不直接影响元素的样式。只要应用的类名没错，那么显示的问题就只跟 CSS 有关，而跟 JavaScript 无关。</p><h6 id="解耦应用程序逻辑-事件处理程序" tabindex="-1">解耦应用程序逻辑/事件处理程序 <a class="header-anchor" href="#解耦应用程序逻辑-事件处理程序" aria-label="Permalink to &quot;解耦应用程序逻辑/事件处理程序&quot;">​</a></h6><p>每个 Web 应用程序中都会有大量事件处理程序在监听各种事件。可是，其中很少能真正做到应用程序逻辑与事件处理程序分离。</p><p>更好的做法是将应用程序逻辑与事件处理程序分开，各自负责处理各自的事情。事件处理程序应该专注于 event 对象的相关信息，然后把这些信息传给处理应用程序逻辑的某些方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> validateValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  	document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;error-msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).style.display </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;block&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleKeyPress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.keyCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.target;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	  validateValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以下是在解耦应用程序逻辑和业务逻辑时应该注意的几点。</p><ul><li>==不要把 event 对象传给其他方法，而是只传递 event 对象中必要的数据。==</li><li>应用程序中每个可能的操作都应该无须事件处理程序就可以执行。</li><li>事件处理程序应该处理事件，而把后续处理交给应用程序逻辑。</li></ul><h3 id="编码惯例" tabindex="-1">编码惯例 <a class="header-anchor" href="#编码惯例" aria-label="Permalink to &quot;编码惯例&quot;">​</a></h3><h6 id="尊重对象所有权" tabindex="-1">尊重对象所有权 <a class="header-anchor" href="#尊重对象所有权" aria-label="Permalink to &quot;尊重对象所有权&quot;">​</a></h6><p>最好的方法是永远不要修改不属于你的对象。只有你自己创建的才是你的对象。</p><ul><li>不要给实例或原型添加属性。</li><li>不要给实例或原型添加方法。</li><li>不要重定义已有的方法。</li></ul><h6 id="不声明全局变量" tabindex="-1">不声明全局变量 <a class="header-anchor" href="#不声明全局变量" aria-label="Permalink to &quot;不声明全局变量&quot;">​</a></h6><p>与尊重对象所有权密切相关的是尽可能不声明全局变量和函数。同样，这也关系到创建一致和可维护的脚本运行环境。最多可以创建一个全局变量，作为其他对象和函数的命名空间。</p><h6 id="不要比较-null" tabindex="-1">不要比较 null <a class="header-anchor" href="#不要比较-null" aria-label="Permalink to &quot;不要比较 null&quot;">​</a></h6><p>JavaScript 不会自动做任何类型检查，因此就需要开发者担起这个责任。结果，很多 JavaScript 代码不会做类型检查。最常见的类型检查是看值是不是 null。然而，与 null 进行比较的代码太多了，其<br> 中很多因为类型检查不够而频繁引发错误。</p><p>如果看到比较 null 的代码，可以使用下列某种技术替换它。</p><ul><li>如果值应该是引用类型，则使用 <code>instanceof</code> 操作符检查其构造函数。</li><li>如果值应该是原始类型，则使用 <code>typeof</code> 检查其类型。</li><li>如果希望值是有特定方法名的对象，则使用 <code>typeof</code> 操作符确保对象上存在给定名字的方法。</li></ul><h6 id="使用常量" tabindex="-1">使用常量 <a class="header-anchor" href="#使用常量" aria-label="Permalink to &quot;使用常量&quot;">​</a></h6><p>依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误。可以使用以下标准检查哪些数据需要提取。</p><ul><li>重复出现的值：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另一个值没改造成的错误。这里也包括 CSS 的类名。</li><li>用户界面字符串：任何会显示给用户的字符串都应该提取出来，以方便实现国际化。</li><li>URL：Web 应用程序中资源的地址经常会发生变化，因此建议把所有 URL 集中放在一个地方管理。</li><li>任何可能变化的值：任何时候，只要在代码中使用字面值，就问问自己这个值将来是否可能会变。如果答案是“是”，那么就应该把它提取到常量中。</li></ul><h2 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h2><h3 id="作用域意识" tabindex="-1">作用域意识 <a class="header-anchor" href="#作用域意识" aria-label="Permalink to &quot;作用域意识&quot;">​</a></h3><h6 id="避免全局查找" tabindex="-1">避免全局查找 <a class="header-anchor" href="#避免全局查找" aria-label="Permalink to &quot;避免全局查找&quot;">​</a></h6><p>全局变量和函数相比于局部值始终是最费时间的，因为需要经历作用域链查找。<br> ==通过在局部作用域中保存 document 对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找。==</p><h6 id="不使用-with-语句" tabindex="-1">不使用 with 语句 <a class="header-anchor" href="#不使用-with-语句" aria-label="Permalink to &quot;不使用 with 语句&quot;">​</a></h6><p>在性能很重要的代码中，应避免使用 with 语句。与函数类似，with 语句会创建自己的作用域，因此也会加长其中代码的作用域链。</p><h3 id="选择正确的方法" tabindex="-1">选择正确的方法 <a class="header-anchor" href="#选择正确的方法" aria-label="Permalink to &quot;选择正确的方法&quot;">​</a></h3><h6 id="避免不必要的属性查找" tabindex="-1">避免不必要的属性查找 <a class="header-anchor" href="#避免不必要的属性查找" aria-label="Permalink to &quot;避免不必要的属性查找&quot;">​</a></h6><p>在计算机科学中，算法复杂度使用大 O 表示法来表示。最简单同时也最快的算法可以表示为常量值或 O(1)。</p><table tabindex="0"><thead><tr><th>表示法</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>​**O(1)**​</td><td>常量</td><td>无论多少值，执行时间都不变。表示简单值和保存在变量中的值</td></tr><tr><td>​<strong>O(log n)</strong></td><td>对数</td><td>执行时间随着值的增加而增加，但算法完成不需要读取每个值。例子：二分查找</td></tr><tr><td>​**O(n)**​</td><td>线性</td><td>执行时间与值的数量直接相关。例子：迭代数组的所有元素</td></tr><tr><td>​**O(n²)**​</td><td>二次方</td><td>执行时间随着值的增加而增加，而且每个值至少要读取 n 次。例子：插入排序</td></tr></tbody></table><p>常量值或 O(1)，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化。读取常量值是效率极高的操作，因此非常快。</p><p>使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是 O(n)。</p><p>通常，只要能够降低算法复杂度，就应该尽量通过在局部变量中保存值来替代属性查找。</p><h6 id="优化循环" tabindex="-1">优化循环 <a class="header-anchor" href="#优化循环" aria-label="Permalink to &quot;优化循环&quot;">​</a></h6><p>优化循环的基本步骤如下。</p><ol><li><strong>简化终止条件</strong>。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他 O(n) 操作。</li><li><strong>简化循环体</strong>。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。</li><li><strong>使用后测试循环</strong>。最常见的循环就是 for 和 while 循环，这两种循环都属于先测试循环。do-while 就是后测试循环，避免了对终止条件初始评估 ，因此应该会更快。</li></ol><h6 id="展开循环" tabindex="-1">展开循环 <a class="header-anchor" href="#展开循环" aria-label="Permalink to &quot;展开循环&quot;">​</a></h6><p>如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。<br> 如果不能提前预知循环的次数，那么或许可以使用一种叫作<strong>达夫设备（Duff’s Device）</strong> 的技术。达夫设备的基本思路是以 8 的倍数作为迭代次数从而将循环展开为一系列语句。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 来源：Jeff Greenberg 在JavaScript 中实现的达夫设备</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设values.length &gt; 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iterations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ceil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> startAt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> values.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(startAt) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  startAt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iterations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>展开循环对于大型数据集可以节省很多时间，但对于小型数据集来说，则可能不值得。因为实现同样的任务需要多写很多代码，所以如果处理的数据量不大，那么显然没有必要。</p><h6 id="避免重复解释" tabindex="-1">避免重复解释 <a class="header-anchor" href="#避免重复解释" aria-label="Permalink to &quot;避免重复解释&quot;">​</a></h6><p>重复解释的问题存在于 JavaScript 代码尝试解释 JavaScript 代码的情形。</p><h6 id="其他性能优化注意事项" tabindex="-1">其他性能优化注意事项 <a class="header-anchor" href="#其他性能优化注意事项" aria-label="Permalink to &quot;其他性能优化注意事项&quot;">​</a></h6><ul><li>原生方法很快。</li><li>switch 语句很快</li><li>位操作很快。</li></ul><h3 id="语句最少化" tabindex="-1">语句最少化 <a class="header-anchor" href="#语句最少化" aria-label="Permalink to &quot;语句最少化&quot;">​</a></h3><h6 id="避免多个变量声明" tabindex="-1">避免多个变量声明 <a class="header-anchor" href="#避免多个变量声明" aria-label="Permalink to &quot;避免多个变量声明&quot;">​</a></h6><p>避免声明多个变量时很容易出现多条语句</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> values </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一条语句更好</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	values </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h6 id="插入迭代性值" tabindex="-1">插入迭代性值 <a class="header-anchor" href="#插入迭代性值" aria-label="Permalink to &quot;插入迭代性值&quot;">​</a></h6><p>任何时候只要使用迭代性值（即会递增或递减的值），都要尽可能使用组合语句。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> values[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> values[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];s</span></span></code></pre></div><h6 id="使用数组和对象字面量" tabindex="-1">使用数组和对象字面量 <a class="header-anchor" href="#使用数组和对象字面量" aria-label="Permalink to &quot;使用数组和对象字面量&quot;">​</a></h6><p>使用构造函数始终会产生比单纯插入元素或定义属性更多的语句，而字面量只需一条语句即可完成全部操作。</p><h3 id="优化-dom-交互" tabindex="-1">优化 DOM 交互 <a class="header-anchor" href="#优化-dom-交互" aria-label="Permalink to &quot;优化 DOM 交互&quot;">​</a></h3><h6 id="实时更新最小化" tabindex="-1">实时更新最小化 <a class="header-anchor" href="#实时更新最小化" aria-label="Permalink to &quot;实时更新最小化&quot;">​</a></h6><p>访问 DOM 时，只要访问的部分是显示页面的一部分，就是在执行实时更新操作。之所以称其为实<br> 时更新，是因为涉及立即（实时）更新页面的显示，让用户看到。每次这样的更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。</p><p>==只要是必须更新 DOM，就尽量考虑使用文档片段来预先构建 DOM 结构，然后再把构建好的 DOM 结构实时更新到文档中。==</p><h6 id="使用-innerhtml" tabindex="-1">使用 innerHTML <a class="header-anchor" href="#使用-innerhtml" aria-label="Permalink to &quot;使用 innerHTML&quot;">​</a></h6><p>在页面中创建新 DOM 节点的方式有两种：使用 DOM 方法如 createElement() 和 appendChild()，以及使用 innerHTML。对于少量 DOM 更新，这两种技术区别不大，但==对于大量 DOM 更新，使用 innerHTML 要比使用标准 DOM 方法创建同样的结构快很多。==</p><h6 id="使用事件委托" tabindex="-1">使用事件委托 <a class="header-anchor" href="#使用事件委托" aria-label="Permalink to &quot;使用事件委托&quot;">​</a></h6><p>大多数 Web 应用程序会大量使用事件处理程序实现用户交互。一个页面中事件处理程序的数量与页面响应用户交互的速度有直接关系。为了减少对页面响应的影响，应该尽可能使用事件委托。</p><p>事件委托利用了事件的冒泡。任何冒泡的事件都可以不在事件目标上，而在目标的任何祖先元素上处理。基于这个认知，可以把事件处理程序添加到负责处理多个目标的高层元素上。只要可能，就应该在文档级添加事件处理程序，因为在文档级可以处理整个页面的事件。</p><h6 id="注意-htmlcollection" tabindex="-1">注意 HTMLCollection <a class="header-anchor" href="#注意-htmlcollection" aria-label="Permalink to &quot;注意 HTMLCollection&quot;">​</a></h6><p>任何时候，只要访问 HTMLCollection，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。==减少访问 HTMLCollection 的次数可以极大地提升脚本的性能。==</p><p>编写 JavaScript 代码时，关键是要记住，只要返回 HTMLCollection 对象，就应该尽量不访问它。<br> 以下情形会返回 HTMLCollection：</p><ul><li>调用 <code>getElementsByTagName()</code>；</li><li>读取元素的 childNodes 属性；</li><li>读取元素的 attributes 属性；</li><li>访问特殊集合，如 document.form、document.images 等。</li></ul><h2 id="部署" tabindex="-1">部署 <a class="header-anchor" href="#部署" aria-label="Permalink to &quot;部署&quot;">​</a></h2><h3 id="构建流程" tabindex="-1">构建流程 <a class="header-anchor" href="#构建流程" aria-label="Permalink to &quot;构建流程&quot;">​</a></h3><p>你写的代码不应该不做任何处理就直接交给浏览器，原因如下。</p><ul><li>知识产权问题：如果把满是注释的代码放到网上，其他人就很容易了解你在做什么，重用它，并可能发现安全漏洞。</li><li>文件大小：你写的代码可读性很好，容易维护，但性能不好。浏览器不会因为代码中多余的空格、缩进、冗余的函数和变量名而受益。</li><li>代码组织：为保证可维护性而组织的代码不一定适合直接交付给浏览器。<br> 为此，需要为 JavaScript 文件建立构建流程。</li></ul><h6 id="文件结构" tabindex="-1">文件结构 <a class="header-anchor" href="#文件结构" aria-label="Permalink to &quot;文件结构&quot;">​</a></h6><p>构建流程首先定义在源代码控制中存储文件的逻辑结构。<br> ==要遵循面向对象编程语言的典型模式，把对象和自定义类型保存到自己独立的文件中。==这样可以让每个文件只包含最小量的代码，让后期修改更方便，也不易引入错误。</p><p>注意，把代码分散到多个文件是从可维护性而不是部署角度出发的。==对于部署，应该把所有源文件合并为一个或多个汇总文件。==</p><h6 id="任务运行器" tabindex="-1">任务运行器 <a class="header-anchor" href="#任务运行器" aria-label="Permalink to &quot;任务运行器&quot;">​</a></h6><p>如果要把大量文件组合成一个应用程序，很可能需要任务运行器自动完成一些任务。任务运行器可以完成代码检查、打包、转译、启动本地服务器、部署，以及其他可以脚本化的任务。</p><h6 id="摇树优化" tabindex="-1">摇树优化 <a class="header-anchor" href="#摇树优化" aria-label="Permalink to &quot;摇树优化&quot;">​</a></h6><p><strong>摇树优化（tree shaking）</strong> 是非常常见且极为有效的减少冗余代码的策略。</p><p>模块中使用静态模块声明风格意味着构建工具可以确定代码各部分之间的依赖关系。更重要的是，摇树优化还能确定代码中的哪些内容是完全不需要的。</p><h6 id="模块打包器" tabindex="-1">模块打包器 <a class="header-anchor" href="#模块打包器" aria-label="Permalink to &quot;模块打包器&quot;">​</a></h6><p>以模块形式编写代码，并不意味着必须以模块形式交付代码。通常，由大量模块组成的 JavaScript 代码在构建时需要打包到一起，然后只交付一个或少数几个 JavaScript 文件。</p><p>模块打包器的工作是识别应用程序中涉及的 JavaScript 依赖关系，将它们组合成一个大文件，完成对模块的串行组织和拼接，然后生成最终提供给浏览器的输出文件。</p><p>==能够实现模块打包的工具非常多。Webpack、Rollupt 和 Browserify 只是其中的几个，可以将基于模块的代码转换为普遍兼容的网页脚本。==</p><h3 id="验证" tabindex="-1">验证 <a class="header-anchor" href="#验证" aria-label="Permalink to &quot;验证&quot;">​</a></h3><p>有一些工具可以帮我们发现 JavaScript 代码中潜在的问题，最流行的是 Douglas Crockford 的 JSLint 和 ==ESLint==。<br> 这些代码检查工具可以发现 JavaScript 代码中的语法错误和常见的编码错误。下面是它们会报告的一些问题：</p><ul><li>使用 eval()；</li><li>使用未声明的变量；</li><li>遗漏了分号；</li><li>不适当地换行；</li><li>不正确地使用逗号；</li><li>遗漏了包含语句的括号；</li><li>遗漏了 switch 分支中的 break；</li><li>重复声明变量；</li><li>使用了 with；</li><li>错误地使用等号（应该是两个或三个等号）；</li><li>执行不到的代码。</li></ul><h3 id="压缩" tabindex="-1">压缩 <a class="header-anchor" href="#压缩" aria-label="Permalink to &quot;压缩&quot;">​</a></h3><p>谈到 JavaScript 文件压缩，实际上主要是两件事：<strong>代码大小（code size）</strong> 和<strong>传输负载（wire weight）</strong></p><h6 id="代码压缩" tabindex="-1">代码压缩 <a class="header-anchor" href="#代码压缩" aria-label="Permalink to &quot;代码压缩&quot;">​</a></h6><p>JavaScript 不是编译成字节码，而是作为源代码传输的，所以源代码文件通常包含对浏览器的 JavaScript 解释器没有用的额外信息和格式。JavaScript 压缩工具可以把源代码文件中的这些信息删除，并在保证程序逻辑不变的前提下缩小文件大小。</p><p>注释、额外的空格、长变量或函数名都能提升开发者的可读性，但对浏览器而言这些都是多余的字节。压缩工具可以通过如下操作减少代码大小：</p><ul><li>删除空格（包括换行）；</li><li>删除注释；</li><li>缩短变量名、函数名和其他标识符。<br> 所有 JavaScript 文件都应该在部署到线上环境前进行压缩。在构建流程中加入这个环节压缩 JavaScript 文件是很容易的。</li></ul><h6 id="javascript-编译" tabindex="-1">JavaScript 编译 <a class="header-anchor" href="#javascript-编译" aria-label="Permalink to &quot;JavaScript 编译&quot;">​</a></h6><p>类似于最小化，JavaScript 代码编译通常指的是把源代码转换为一种逻辑相同但字节更少的形式。<br> 与最小化的不同之处在于，编译后代码的结构可能不同，但仍然具备与原始代码相同的行为。编译器通过输入全部 JavaScript 代码可以对程序流执行稳健的分析。<br> 编译可能会执行如下操作：</p><ul><li>删除未使用的代码；</li><li>将某些代码转换为更简洁的语法；</li><li>全局函数调用、常量和变量行内化。</li></ul><h6 id="javascript-转译" tabindex="-1">JavaScript 转译 <a class="header-anchor" href="#javascript-转译" aria-label="Permalink to &quot;JavaScript 转译&quot;">​</a></h6><p>通过 JavaScript 转译，可以在开发时使用最新的语法特性而不用担心浏览器的兼容性问题。转译可以将现代的代码转换成更早的 ECMAScript 版本，通常是 ES3 或 ES5，具体取决于你的需求。这样可以确保代码能够跨浏览器兼容。</p><h6 id="http-压缩" tabindex="-1">HTTP 压缩 <a class="header-anchor" href="#http-压缩" aria-label="Permalink to &quot;HTTP 压缩&quot;">​</a></h6><p>服务器则可以根据浏览器通过请求头部（<code>Accept-Encoding</code>）标明自己支持的格式，选择一种用来压缩 JavaScript 文件。在传输压缩后的文件时，服务器响应的头部会有字段（<code>Content-Encoding</code>）标明使用了哪种压缩格式。浏览器看到这个头部字段后，就会根据这个压缩格式进行解压缩。结果是通过网络传输的字节数明显小于原始代码大小。</p><p>例如，使用 Apache 服务器上的两个模块（mod_gzip 和 mod_deflate）可以减少原始 JavaScript 文件的约 70%。这很大程度上是因为 JavaScript 的代码是纯文件，所以压缩率非常高。减少通过网络传输的数据量意味着浏览器能更快收到数据。注意，服务器压缩和浏览器解压缩都需要时间。不过相比于通过传入更少的字节数而节省的时间，整体时间应该是减少的。</p>`,121)]))}const g=s(h,[["render",n]]);export{o as __pageData,g as default};
