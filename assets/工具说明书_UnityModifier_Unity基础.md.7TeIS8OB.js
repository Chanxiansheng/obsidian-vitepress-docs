import{_ as s,c as i,o as a,ag as e}from"./chunks/framework.-ewJmwvT.js";const n="/obsidian-vitepress-docs/assets/Unity%E5%9F%BA%E7%A1%80-2.DUjjeycf.png",l="/obsidian-vitepress-docs/assets/Unity%E5%9F%BA%E7%A1%80-1.CzqLV-mv.png",u=JSON.parse('{"title":"Unity 基础","description":"","frontmatter":{},"headers":[],"relativePath":"工具说明书/UnityModifier/Unity基础.md","filePath":"工具说明书/UnityModifier/Unity基础.md"}'),d={name:"工具说明书/UnityModifier/Unity基础.md"};function r(o,t,p,h,c,g){return a(),i("div",null,t[0]||(t[0]=[e(`<h1 id="unity-基础" tabindex="-1">Unity 基础 <a class="header-anchor" href="#unity-基础" aria-label="Permalink to &quot;Unity 基础&quot;">​</a></h1><div class="note custom-block github-alert"><p class="custom-block-title">文档</p><p><a href="https://docs.unity3d.com/cn/current/Manual/InstantiatingPrefabs.html" target="_blank" rel="noreferrer">在运行时实例化预制件 - Unity 手册</a></p></div><h2 id="与前端类比" tabindex="-1">与前端类比 <a class="header-anchor" href="#与前端类比" aria-label="Permalink to &quot;与前端类比&quot;">​</a></h2><h3 id="🧩-unity-和-web-前端的类比表" tabindex="-1">🧩 Unity 和 Web 前端的类比表 <a class="header-anchor" href="#🧩-unity-和-web-前端的类比表" aria-label="Permalink to &quot;🧩 Unity 和 Web 前端的类比表&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Unity 概念</th><th>前端类比</th><th>说明</th></tr></thead><tbody><tr><td><code>Scene</code></td><td><strong>HTML 页面</strong></td><td>顶层容器，包含所有可见对象（DOM 元素）</td></tr><tr><td><code>GameObject</code></td><td><strong>HTML 元素（div、img、button 等）</strong></td><td>基础构建单位，代表一个实体</td></tr><tr><td><code>Component</code></td><td><strong>元素的属性、CSS、事件监听器、绑定的 JS 脚本</strong></td><td>给元素赋予功能（位置、颜色、行为）</td></tr><tr><td><code>Transform</code></td><td><strong>CSS 的 position/scale/rotate</strong></td><td>控制元素的空间位置</td></tr><tr><td><code>MonoBehaviour</code> 脚本</td><td><strong>绑定在元素上的 JS 脚本对象</strong></td><td>控制元素的逻辑行为，如点击、移动等</td></tr><tr><td><code>Update()</code> 等生命周期函数</td><td><strong>requestAnimationFrame/render loop</strong></td><td>每帧更新逻辑（动画、输入处理）</td></tr><tr><td><code>Awake/Start</code></td><td><strong>JS 脚本初始化逻辑（onload / mounted）</strong></td><td>脚本加载时的一次性初始化</td></tr><tr><td><code>AddComponent&lt;T&gt;()</code></td><td><strong>动态设置属性或绑定事件</strong></td><td>运行时为元素添加功能</td></tr><tr><td><code>Inspector 面板</code></td><td><strong>开发者工具中的元素面板 / Vue Devtools</strong></td><td>查看/修改对象的属性和结构</td></tr><tr><td><code>Prefab</code></td><td><strong>组件模板 / 自定义元素 / Vue 组件</strong></td><td>可复用的 GameObject 结构模板</td></tr><tr><td><code>Instantiate</code></td><td><strong>通过 JS 动态创建 DOM 元素</strong></td><td>克隆 prefab 实例到场景中</td></tr><tr><td><code>Destroy()</code></td><td><strong>removeChild / remove()</strong></td><td>删除 GameObject</td></tr></tbody></table><h3 id="🧠-unity-vs-vue-对照表-核心概念篇" tabindex="-1">🧠 Unity vs Vue 对照表（核心概念篇） <a class="header-anchor" href="#🧠-unity-vs-vue-对照表-核心概念篇" aria-label="Permalink to &quot;🧠 Unity vs Vue 对照表（核心概念篇）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Unity 概念</th><th>Vue 概念</th><th>对应说明</th></tr></thead><tbody><tr><td><strong>Scene</strong></td><td>根 DOM / 页面 / Router 页面</td><td>整个运行环境的根容器</td></tr><tr><td><strong>GameObject</strong></td><td>一个 DOM 元素 / Vue 组件实例</td><td>实体节点</td></tr><tr><td><strong>Component（如 Camera、Renderer）</strong></td><td>Vue 组件的 <code>props</code>、指令、绑定、功能性插件</td><td>功能模块</td></tr><tr><td><strong>MonoBehaviour 脚本</strong></td><td>Vue 的 <code>&lt;script setup&gt;</code> / 组件逻辑部分</td><td>控制逻辑</td></tr><tr><td><code>AddComponent&lt;T&gt;()</code></td><td><code>v-bind</code> 或插件注册 / Mixin</td><td>添加功能行为</td></tr><tr><td><code>Awake()</code></td><td><code>beforeCreate()</code></td><td>初始化时机：对象构造完但未激活</td></tr><tr><td><code>Start()</code></td><td><code>mounted()</code></td><td>GameObject 激活后，组件准备完毕</td></tr><tr><td><code>Update()</code></td><td><code>requestAnimationFrame</code> / reactive 状态更新</td><td>每帧刷新或响应式变更</td></tr><tr><td><code>OnEnable()</code> / <code>OnDisable()</code></td><td><code>watch + v-if</code> 组件挂载/卸载</td><td>状态切换时的生命周期</td></tr><tr><td><code>Destroy()</code></td><td><code>beforeUnmount()</code> / <code>unmounted()</code></td><td>对象即将销毁或已销毁</td></tr></tbody></table><h3 id="🧱-unity-和-vue-的开发流程类比" tabindex="-1">🧱 Unity 和 Vue 的开发流程类比 <a class="header-anchor" href="#🧱-unity-和-vue-的开发流程类比" aria-label="Permalink to &quot;🧱 Unity 和 Vue 的开发流程类比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>开发阶段</th><th>Unity</th><th>Vue</th></tr></thead><tbody><tr><td>结构定义</td><td>GameObject + Component 组合</td><td><code>&lt;template&gt;</code> + <code>&lt;script&gt;</code> + props</td></tr><tr><td>初始化</td><td><code>Awake()</code> / <code>Start()</code></td><td><code>setup()</code> / <code>mounted()</code></td></tr><tr><td>动态创建</td><td><code>Instantiate(prefab)</code></td><td><code>v-for</code> 或 <code>&lt;component :is=&quot;...&quot;&gt;</code></td></tr><tr><td>动态挂载行为</td><td><code>AddComponent&lt;T&gt;()</code></td><td><code>v-bind</code> 动态 props / directive</td></tr><tr><td>状态驱动渲染</td><td><code>Update()</code> 中处理逻辑</td><td><code>ref</code> + <code>reactive</code> 状态绑定</td></tr><tr><td>事件处理</td><td><code>OnMouseDown()</code> / <code>Input.GetKey()</code></td><td><code>@click</code> / <code>@keydown</code></td></tr><tr><td>销毁处理</td><td><code>Destroy(gameObject)</code></td><td>条件渲染 + 生命周期钩子</td></tr></tbody></table><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p><strong>Vue 用组件组合描述 UI + 逻辑，Unity 用组件组合描述场景中对象 + 行为。</strong><br> 本质上，<strong>Vue 是数据驱动的视图系统，Unity 是对象驱动的游戏系统。</strong><br> 但两者都强调：结构 + 行为 解耦，通过组合实现高复用性和解耦设计。</p></div><h2 id="gameobject-类" tabindex="-1">GameObject 类 <a class="header-anchor" href="#gameobject-类" aria-label="Permalink to &quot;GameObject 类&quot;">​</a></h2><p>GameObject 是 Unity 中所有实体的基类。</p><ul><li>编辑器创建 GameObject</li></ul><p>通过 Hierachy 面板下的 Create 菜单可以手动地创建一个 GameObject，它可以是一个相机， 一个灯光，或者一个简单的模型。</p><div class="note custom-block github-alert"><p class="custom-block-title">编辑器创建的 GameObject 何时被实例化</p><p></p><p>Unity 会从场景文件（<code>.unity</code>）中读取<strong>所有 GameObject 和它们的组件配置（序列化数据）</strong>。</p><p><strong>这些数据是编辑器保存的结构化信息</strong>，包括：</p><ul><li>GameObject 的层级关系</li><li>每个 GameObject 拥有哪些组件</li><li>每个组件的字段值（包括引用、配置等）</li></ul><p>场景加载完成 → 运行时阶段开始：</p><ul><li>Unity 会 <strong>自动实例化每一个 GameObject</strong></li><li>并为其 <strong>挂载所有配置好的 Component 实例</strong></li><li>所有继承自 <code>MonoBehaviour</code> 且启用的组件，按生命周期调用。</li></ul><p><code>场景激活 ≈ 场景中的 GameObject 被批量实例化 + 组件挂载 + 生命周期启动</code></p></div><ul><li>手动创建 GameObject</li></ul><p>当我们要在程序里面动态地创建一个空物体的时候，可以 new 一个 GameObject。</p><p>如果想要创建一个可见的物体比如创建一个球体或者一个立方体，可以通过 GameObject 内 提供的接口 CreatePrimitive 来创建。</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gameObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GameObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成一个空物体</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CreatePrimitive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PrimitiveType.Capsule);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成一个胶囊体</span></span></code></pre></div><ul><li>查找游戏对象（多为静态方法）</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Unity&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 🔍 从当前场景（Scene）中查找名为 &quot;Unity&quot; 的 GameObject。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 支持路径语法，如 &quot;Parent/Child&quot; 表示查找嵌套对象。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意：效率较低，不建议频繁调用。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FindWithTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Player&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 🔍 查找场景中第一个拥有 Tag 为 &quot;Player&quot; 的 GameObject。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 若无匹配对象，返回 null。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意：仅返回一个 GameObject。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FindGameObjectsWithTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Player&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 🔍 查找场景中所有 Tag 为 &quot;Player&quot; 的 GameObject，返回 GameObject[] 数组。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 常用于遍历多个敌人、NPC、道具等。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FindObjectOfType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 🔍 查找场景中第一个挂有 Camera 组件的 GameObject，并返回该组件实例。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意：仅返回一个匹配对象，若有多个则不确定返回哪个。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 性能开销较高，不推荐在 Update 中频繁使用。</span></span></code></pre></div><ul><li>添加/获取组件（多为实例方法）</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.isStatic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 GameObject 为静态物体（Static），用于性能优化如静态合批、光照烘焙等。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SetActive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 启用 GameObject（激活状态）。若为 false，则 GameObject 及其所有子对象将被禁用。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AddComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态向 GameObject 添加一个 Camera 组件，并返回该组件实例。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Player&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 GameObject 的标签（Tag），可用于标识对象（如用于触发器或查找）。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetComponentInChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从当前 GameObject 的子对象中查找第一个 Camera 组件（包括自己）。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetComponentInParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从当前 GameObject 的父对象中查找第一个 Camera 组件（包括自己）。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetComponents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取当前 GameObject 上所有的 Camera 组件，返回 Camera[] 数组。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Camera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取当前 GameObject 上的第一个 Camera 组件，如果不存在返回 null。</span></span></code></pre></div><ul><li>销毁游戏对象</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GameObject.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Destroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gameObject);</span></span></code></pre></div><h2 id="component-类" tabindex="-1">Component 类 <a class="header-anchor" href="#component-类" aria-label="Permalink to &quot;Component 类&quot;">​</a></h2><p>组件（Component）是挂载在 GameObject 上，用于赋予其功能的行为模块。<br><strong>GameObject 是容器，Component 是功能。</strong><br><img src="`+n+`" alt=""><br> 🔧 技术上说，组件是继承自 <code>UnityEngine.Component</code> 的类。<br> 所有组件的继承关系图（核心）</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">└── Component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Behaviour</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    │   └── MonoBehaviour</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Transform</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Renderer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Collider</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ├── Rigidbody</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    └── ...</span></span></code></pre></div><h2 id="组件-monobehaviour-类与生命周期" tabindex="-1">组件 - MonoBehaviour 类与生命周期 <a class="header-anchor" href="#组件-monobehaviour-类与生命周期" aria-label="Permalink to &quot;组件 - MonoBehaviour 类与生命周期&quot;">​</a></h2><p>Unity 中，有一个特别重要的知识点，生命周期函数。这些东西全部都是系统定义好的，运行时自动调用，但需要继承 MonoBehaviour 类才能使用。这个类是从 Unity 中创建脚本就自动继承了。正是因为继承了 MonoBehaviour 这个类，Unity 才能依次调用我们的脚本代码，执行游戏逻辑。</p><p>🔹 1. <code>Reset()</code></p><ul><li>🕒 <strong>调用时机</strong>：<strong>仅在编辑器中</strong></li><li>🚩 <strong>触发条件</strong>： <ul><li>第一次将脚本添加到 GameObject 上</li><li>在 Inspector 中点击右键 “Reset”</li></ul></li><li>🔧 <strong>用途</strong>：初始化脚本字段为默认值</li></ul><hr><p>🔹 2. <code>Awake()</code></p><ul><li>🕒 <strong>调用时机</strong>：脚本实例加载时</li><li>🚩 <strong>触发条件</strong>： <ul><li>场景加载</li><li><code>Instantiate</code> 创建对象</li><li>GameObject 从未激活 → 激活</li></ul></li><li>🔧 <strong>用途</strong>：用于一次性初始化，如对象引用、组件缓存等（类似构造函数）</li></ul><hr><p>🔹 3. <code>OnEnable()</code></p><ul><li>🕒 <strong>调用时机</strong>：对象/脚本被激活时</li><li>🚩 <strong>触发条件</strong>： <ul><li>场景加载</li><li>GameObject 激活</li><li>脚本启用（enabled = true）</li></ul></li><li>🔧 <strong>用途</strong>：订阅事件、恢复状态、刷新显示</li></ul><hr><p>🔹 4. <code>Start()</code></p><ul><li>🕒 <strong>调用时机</strong>：<strong>第一帧更新前</strong></li><li>🚩 <strong>触发条件</strong>： <ul><li>GameObject 激活后且脚本启用</li></ul></li><li>🔧 <strong>用途</strong>：延迟初始化（依赖其他组件已完成 <code>Awake()</code>）</li></ul><hr><p>🔹 5. <code>FixedUpdate()</code></p><ul><li>🕒 <strong>调用时机</strong>：<strong>固定时间间隔</strong></li><li>🔧 <strong>用途</strong>：处理物理逻辑（如刚体运动、碰撞检测）</li><li>⚙️ <strong>频率设置</strong>：Project Settings → Time → Fixed Timestep</li></ul><hr><p>🔹 6. <code>Update()</code></p><ul><li>🕒 <strong>调用时机</strong>：<strong>每一帧</strong></li><li>🔧 <strong>用途</strong>：处理核心逻辑、用户输入、状态检测等</li></ul><hr><p>🔹 7. <code>LateUpdate()</code></p><ul><li>🕒 <strong>调用时机</strong>：每帧的 <strong>最后</strong></li><li>🔧 <strong>用途</strong>：通常用于摄像机跟随、依赖其他对象位置已更新后的操作</li><li>💡 <strong>顺序</strong>：<code>Update()</code> → 动画处理 → <code>LateUpdate()</code></li></ul><hr><p>🔹 8. <code>OnDisable()</code></p><ul><li>🕒 <strong>调用时机</strong>：对象/脚本被禁用时</li><li>🚩 <strong>触发条件</strong>： <ul><li>GameObject 或脚本被禁用</li><li>对象被销毁</li></ul></li><li>🔧 <strong>用途</strong>：取消事件订阅、暂停行为、缓存状态</li></ul><hr><p>🔹 9. <code>OnDestroy()</code></p><ul><li><p>🕒 <strong>调用时机</strong>：对象被销毁时</p></li><li><p>🚩 <strong>触发条件</strong>：</p><ul><li>调用 <code>Destroy()</code></li><li>场景卸载</li></ul></li><li><p>🔧 <strong>用途</strong>：释放资源、注销引用、终止协程</p></li></ul><hr><p>🔹 10. <code>OnApplicationQuit()</code></p><ul><li>🕒 <strong>调用时机</strong>：应用退出前（包括退出播放模式）</li><li>🚩 <strong>触发条件</strong>： <ul><li>程序关闭</li><li>Unity 编辑器停止播放</li><li>WebGL 页面关闭</li></ul></li><li>🔧 <strong>用途</strong>：保存数据、清理网络连接、写入日志等</li></ul><h3 id="生命周期高清大图" tabindex="-1">生命周期高清大图 <a class="header-anchor" href="#生命周期高清大图" aria-label="Permalink to &quot;生命周期高清大图&quot;">​</a></h3><p><img src="`+l+'" alt=""></p><h2 id="组件-transform-类" tabindex="-1">组件 - Transform 类 <a class="header-anchor" href="#组件-transform-类" aria-label="Permalink to &quot;组件 - Transform 类&quot;">​</a></h2><p>Unity 中所有游戏对象（GameObject），都存在一个 Transform 组件，无需手动添加，也不能移除。</p><p>Transform 负责描述该对象在 3D 空间中的：</p><ul><li><strong>位置（Position）</strong></li><li><strong>旋转（Rotation）</strong></li><li><strong>缩放（Scale）</strong></li><li><strong>父子层级关系</strong></li></ul><p>Transform 面板一共有 3 个属性 Position、Rotation、Scale，分别控制着场景中每个对象的位置、旋转和缩放。</p><div class="note custom-block github-alert"><p class="custom-block-title">与前端类比</p><p>Unity 的 <code>Transform</code> ≈ 前端 DOM + CSS 所组成的<strong>布局树</strong>（Layout Tree）节点。<br> 它描述了对象在空间中的层级、位置、旋转、缩放，最终决定它是否能以及如何被渲染。</p></div><ul><li><p>position<br><code>transform.position</code> 是一个可读可写的属性。transform.position 是相对于世界坐标系来展示坐标的</p></li><li><p>localPosition<br><code>transform.localPosition</code> 是一个可读可写的属性。transform.localPosition 是利用局部坐标系来展示坐标的，即把父节点作为原点，自身位置就是相对于父节点的在三个轴向上的距离。</p></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">position 的单位</p><p>Unity 中 <code>Transform.position</code> 的单位是 <strong>世界单位（World Unit）</strong>，<strong>不是 px（像素）</strong>。</p><p>是基于三维笛卡尔坐标系（World Space），最终会通过 <strong>摄像机的投影矩阵</strong>（Projection Matrix）被“投射”到 2D 屏幕上，形成最终像素坐标。。</p><p>Unity 渲染到屏幕上时，会通过：</p><ul><li>摄像机的投影（Perspective 或 Orthographic）</li><li>分辨率 &amp; 屏幕缩放</li><li>UI Canvas 模式（对于 UI 元素）</li></ul><p><strong>把这些单位映射成像素位置</strong>，但这个换算是动态的，并不是固定关系。</p><p>所以 <strong>1 个单位 ≠ 固定像素值</strong>，它取决于：</p><ul><li>摄像机的 FOV（视野角度）</li><li>投影模式（ or ） <ul><li>Orthographic 正交投影：就像一个“无限远投影矩形框”，把场景空间中的物体，按平行方式拍扁投到二维画面上。</li><li>Perspective 透视投影：“高无限的正四棱台”（或称为视锥体）的投影</li></ul></li><li>距离摄像机的远近</li><li>屏幕分辨率</li></ul></div><h2 id="create-gameplay" tabindex="-1">Create Gameplay <a class="header-anchor" href="#create-gameplay" aria-label="Permalink to &quot;Create Gameplay&quot;">​</a></h2><h3 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h3><h3 id="游戏对象" tabindex="-1">游戏对象 <a class="header-anchor" href="#游戏对象" aria-label="Permalink to &quot;游戏对象&quot;">​</a></h3><h3 id="预制件" tabindex="-1">预制件 <a class="header-anchor" href="#预制件" aria-label="Permalink to &quot;预制件&quot;">​</a></h3><h2 id="渲染管线" tabindex="-1">渲染管线 <a class="header-anchor" href="#渲染管线" aria-label="Permalink to &quot;渲染管线&quot;">​</a></h2><p>Unity 的渲染系统（Rendering System）是一套 <strong>从场景 → 摄像机 → 渲染图像</strong> 的流程，负责把 3D 世界“变成”屏幕上看到的图像。</p><h4 id="🧱-unity-渲染系统的三大架构-管线" tabindex="-1">🧱 Unity 渲染系统的三大架构（管线） <a class="header-anchor" href="#🧱-unity-渲染系统的三大架构-管线" aria-label="Permalink to &quot;🧱 Unity 渲染系统的三大架构（管线）&quot;">​</a></h4><table tabindex="0"><thead><tr><th>渲染管线类型</th><th>简介</th><th>特点</th></tr></thead><tbody><tr><td><strong>内置渲染管线（Built-in RP）</strong></td><td>Unity 最初默认使用的管线</td><td>易用、但不够灵活，渐被淘汰</td></tr><tr><td><strong>通用渲染管线（URP）</strong></td><td>Universal Render Pipeline</td><td>支持移动平台、高性能、结构清晰，推荐使用</td></tr><tr><td><strong>高清渲染管线（HDRP）</strong></td><td>High Definition RP</td><td>支持高级光照、体积雾、物理渲染等，面向次世代大作</td></tr></tbody></table><blockquote><p>📌 项目创建时可选择哪个管线，<strong>一旦选择需维护对应的资源与 Shader 格式</strong></p></blockquote><h4 id="🧠-渲染流程核心阶段-专业术语" tabindex="-1">🧠 渲染流程核心阶段（专业术语） <a class="header-anchor" href="#🧠-渲染流程核心阶段-专业术语" aria-label="Permalink to &quot;🧠 渲染流程核心阶段（专业术语）&quot;">​</a></h4><table tabindex="0"><thead><tr><th>阶段</th><th>术语</th><th>作用</th></tr></thead><tbody><tr><td>1️⃣ 场景剔除</td><td><strong>Culling</strong></td><td>去除摄像机不可见的对象（加快渲染）</td></tr><tr><td>2️⃣ 光照计算</td><td><strong>Lighting</strong></td><td>光源照亮物体，生成阴影、光照图</td></tr><tr><td>3️⃣ 变换</td><td><strong>Transform → View → Projection</strong></td><td>把世界坐标变换成屏幕坐标</td></tr><tr><td>4️⃣ 渲染命令生成</td><td><strong>Draw Calls</strong></td><td>引擎组织一次性渲染哪些物体</td></tr><tr><td>5️⃣ 图形 API 调用</td><td><strong>Graphics API</strong></td><td>调用底层渲染接口（如 DirectX、OpenGL、Vulkan）</td></tr><tr><td>6️⃣ 像素输出</td><td><strong>Rasterization &amp; Fragment Shader</strong></td><td>生成图像像素（最终颜色）</td></tr><tr><td>7️⃣ 后处理</td><td><strong>Post-processing</strong></td><td>添加特效：景深、泛光、颜色调整等</td></tr><tr><td>8️⃣ 合成</td><td><strong>Frame Buffer</strong></td><td>所有像素合成后输出为一帧图像</td></tr></tbody></table><h4 id="🔧核心模块组成-从开发角度理解" tabindex="-1">🔧核心模块组成（从开发角度理解） <a class="header-anchor" href="#🔧核心模块组成-从开发角度理解" aria-label="Permalink to &quot;🔧核心模块组成（从开发角度理解）&quot;">​</a></h4><table tabindex="0"><thead><tr><th>模块</th><th>专业术语</th><th>对应功能</th></tr></thead><tbody><tr><td>摄像机</td><td><strong>Camera</strong></td><td>渲染入口，决定“看哪儿”</td></tr><tr><td>网格</td><td><strong>MeshRenderer</strong></td><td>渲染 3D 模型的几何形状</td></tr><tr><td>材质</td><td><strong>Material</strong></td><td>控制对象的外观（颜色、贴图）</td></tr><tr><td>着色器</td><td><strong>Shader</strong></td><td>控制材质如何响应光照与渲染</td></tr><tr><td>光源</td><td><strong>Light</strong></td><td>提供不同的光照模式（点光源、方向光等）</td></tr><tr><td>阴影</td><td><strong>Shadow Mapping</strong></td><td>用深度图计算阴影效果</td></tr><tr><td>后期处理</td><td><strong>Post Processing Stack</strong></td><td>添加全局图像效果（如景深、泛光）</td></tr><tr><td>渲染管线设置</td><td><strong>Render Pipeline Asset</strong></td><td>决定用 URP、HDRP 或内置管线</td></tr></tbody></table><h4 id="投影系统" tabindex="-1">投影系统 <a class="header-anchor" href="#投影系统" aria-label="Permalink to &quot;投影系统&quot;">​</a></h4><ul><li>Orthographic 正交投影：就像一个“无限远投影矩形框”，把场景空间中的物体，按平行方式拍扁投到二维画面上。</li><li>Perspective 透视投影：“高无限的正四棱台”（或称为视锥体）的投影</li></ul>',84)]))}const b=s(d,[["render",r]]);export{u as __pageData,b as default};
