import{_ as t,c as p,o as n,ae as l,j as s,a,t as h}from"./chunks/framework.CIivgcbp.js";const r="/obsidian-vitepress-docs/assets/image_fSwjijJGoO.CJo5Vnr-.png",k="/obsidian-vitepress-docs/assets/image_T2NWgOv1NI.CFTgM6cb.png",d="/obsidian-vitepress-docs/assets/image_f-Z6dyVnJh.Cbk2G4lH.png",o="/obsidian-vitepress-docs/assets/image_N0BWWj83l6.BZzGkU9n.png",c="/obsidian-vitepress-docs/assets/image_eYLW0AUzBX.DQABaLG-.png",E="/obsidian-vitepress-docs/assets/image_cLyx6a2nBS.mCeYOzE0.png",A=JSON.parse('{"title":"Vue2 - Xmind 笔记备份","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/07 Vue/Vue2/Vue2-Xmind笔记备份.md","filePath":"前端技术/07 Vue/Vue2/Vue2-Xmind笔记备份.md"}'),u={name:"前端技术/07 Vue/Vue2/Vue2-Xmind笔记备份.md"};function g(e,i,y,b,m,F){return n(),p("div",null,[i[4]||(i[4]=l(`<h1 id="vue2-xmind-笔记备份" tabindex="-1">Vue2 - Xmind 笔记备份 <a class="header-anchor" href="#vue2-xmind-笔记备份" aria-label="Permalink to &quot;Vue2 - Xmind 笔记备份&quot;">​</a></h1><ul><li>[x] 20240611 已重新梳理格式</li></ul><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>Vue2 是一套用于构建<strong>用户界面</strong>的<strong>渐进式</strong>JS<strong>框架</strong>。</p><ul><li>用户界面（数据 --&gt;用户界面）</li><li>渐进式（自底向上逐层的应用）</li><li>框架（能应用各种复杂插件）</li><li>特点 <ul><li>采用组件化模式，提高代码复用率、且更好维护</li><li>声明式编码，无需直接操作 DOM，提高开发效率</li><li>使用虚拟 DOM+ 优秀的 Diff 算法，尽量复用 DOM 节点</li></ul></li></ul><p>awesome Vue：一个周边库网站</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><ol><li><p>安装 Vue Devtools（浏览器）</p></li><li><p>引入</p><ul><li>本地引入<br> 开发版本 vue.js<br> 生产版本 vue.min.js</li><li>CDN 在线引入<br><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.10/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li></ul></li><li><p>全局配置 <code>Vue.config</code><br> productionTip : 设置为 False 时阻止在启动时生成生产提示。</p></li><li><p>live-server 插件 (npm)<br> 以根目录构建本地服务器</p></li></ol><h2 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h2><ul><li><p>定义容器#root<br><code>HTML\\&lt;div id=&quot;root&quot;&gt;\\&lt;/div&gt;</code></p></li><li><p>创建 Vue 实例</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  el: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#root&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //另一种写法vm.$mount(“root”)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data: { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p>data 中用于存储数据，数据供 el 所指定的容器使用，一般以函数方式 return 一个对象，此方法防止 data 对象被多组件使用。<br><code>data:function(){retrun{name:&quot;Vue&quot;}}</code><br> 简写：<code>data(){retrun{name:&quot;Vue&quot;}}</code></p></li><li><p>注意：<br> 容器与实例间只能一对一<br> 真实开发中只有一个 Vue 实例<br> Vue 实例中需要传入一个配置对象</p></li></ul><h2 id="模板语法" tabindex="-1">模板语法 <a class="header-anchor" href="#模板语法" aria-label="Permalink to &quot;模板语法&quot;">​</a></h2>`,11)),s("ul",null,[s("li",null,[s("p",null,[i[0]||(i[0]=a("插值语法")),i[1]||(i[1]=s("br",null,null,-1)),s("code",null,"<p>"+h(e.xxxx)+"</p>",1),i[2]||(i[2]=a(" xxxx 会作为 js 表达式被解析"))])]),i[3]||(i[3]=s("li",null,[s("p",null,[a("指令语法"),s("br"),s("code",null,"v-bind:href = 'xxxx' ")])],-1))]),i[5]||(i[5]=l('<h2 id="数据绑定" tabindex="-1">数据绑定 <a class="header-anchor" href="#数据绑定" aria-label="Permalink to &quot;数据绑定&quot;">​</a></h2><ul><li><p>单向数据绑定<br> v-bind 简写 <code>：</code></p></li><li><p>双向数据绑定<br> v-model 只能应用在表单元素的 value 上，有专用修饰符</p><ul><li><code>.number</code> 输入转为数值型</li><li><code>.trim</code> 去除前后空白字符串</li><li><code>.lazy</code> 在 change 时更新</li></ul></li></ul><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h2><p><img src="'+r+'" alt=""></p><ul><li>M：模型 (Model) ：对应 data 中的数据</li><li>V：视图 (View) ：模板</li><li>VM：视图模型 (ViewModel) ： Vue 实例对象</li></ul><h2 id="object-defineproperty" tabindex="-1">Object.defineProperty() <a class="header-anchor" href="#object-defineproperty" aria-label="Permalink to &quot;Object.defineProperty()&quot;">​</a></h2><ul><li><code>Object.defineProperty()</code> 是 vue2 实现数据响应式的主要函数</li><li>两种用法 <ul><li><code>Object.defineProperty(object, prop, descriptor)</code></li><li><code>Object.defineProperties(object, {prop1 : descriptor1, prop2 : descriptor2, ...)</code></li></ul></li><li>设置数据属性特征 <ol><li><code>value</code></li><li><code>enumerable</code> 可否枚举，默认 false</li><li><code>writable</code> 可否修改，默认 false</li><li><code>configurable</code> 可否删除，默认 false</li></ol></li><li>添加访问器属性<br><code>get()</code><br><code>set()</code></li></ul><h2 id="数据代理" tabindex="-1">数据代理 <a class="header-anchor" href="#数据代理" aria-label="Permalink to &quot;数据代理&quot;">​</a></h2><p><img src="'+k+`" alt=""></p><ul><li>通过 Object.defineProperty() 把 data 对象中所有属性添加到 vm 上</li><li>为每一个添加到 vm 上的属性，都指定一个 getter 和 setter</li><li>在 getter 和 setter 内部操作 data 对应的属性</li></ul><h2 id="事件处理" tabindex="-1">事件处理 <a class="header-anchor" href="#事件处理" aria-label="Permalink to &quot;事件处理&quot;">​</a></h2><ul><li><p>v-on 简写 <code>@</code></p></li><li><p>event 事件对象<br> 内置的变量，包含事件的各种信息。<code>$event</code> 是参数占位符<br> click<br> keydown<br> ...</p></li><li><p>传参<br> @click=MethodName($event,[parameters])</p></li><li><p>方法配置在 Vue 实例的 methods 对象中<br><code>methods:{MethondName(){}}</code></p></li><li><p>事件修饰符</p><ol><li><code>.prevent</code> 阻止事件的默认行为</li><li><code>.stop</code> 停止事件冒泡</li><li><code>.once</code> 只触发一次</li><li><code>.capture</code> 以捕获阶段触发</li><li><code>.self</code> 只有 event.target 是当前操作的元素才触发</li><li><code>.passive</code> 事件的默认行为立即执行，无需等待事件回调执行完毕，用于 wheel 等</li></ol></li><li><p>按键事件修饰符</p><ul><li><p>keyName: enter、delete、esc、space、tab(需 keydown)、up、down、left、right、...</p></li><li><p>系统修饰键 ctrl、alt、shift、meta</p></li><li><p>keycode</p></li><li><p>自定义按键名<br><code>Vue.config.keyCodes.YourCodeName = 13</code></p></li></ul></li></ul><h2 id="计算属性" tabindex="-1">计算属性 <a class="header-anchor" href="#计算属性" aria-label="Permalink to &quot;计算属性&quot;">​</a></h2><ul><li><p>原理<br> 底层借助了 Object.defineproperty 方法的 getter 和 setter</p></li><li><p>方法配置在 Vue 实例的 computed 对象中<br><code>computed:{MethondName{}}</code></p></li><li><p>使用<br> 完整形式：对象</p><p>get</p><p>什么时候调用</p><p>初次读取时</p><p>所依赖的数据发生变化时</p><p>set</p><p>该属性需要被修改时需配置</p><p>简写形式：方法</p><p>默认重构 get</p></li><li><p>优点<br> 与 methods 相比，内部有缓存机制，效率更高，调试方便</p></li></ul><h2 id="监视属性" tabindex="-1">监视属性 <a class="header-anchor" href="#监视属性" aria-label="Permalink to &quot;监视属性&quot;">​</a></h2><ul><li><p>当被监视的属性发生变化时，监视器回调函数 handler 被调用<br> 监视属性必须存在才能进行监视</p></li><li><p>两种配置方法<br> 方法配置在 Vue 实例的 watch 对象中<br> 通过 <code>vm.$watch</code> 监视</p></li><li><p>使用<br><code>handler(newval,oldval){}</code><br><code>immediate: true</code><br> 初始化时 handler 调用一次，默认 false<br><code>deep: true</code><br> 深度监视，默认 false</p></li><li><p>简写形式：直接使用方法<br> 默认重构 handler 方法</p></li><li><p>与计算属性的区别<br> computed 能完成的 watch 都能完成；<br> watch 能完成的 computed 不一定能完成；<br> 能用 computed 尽量使用 computed；<br> 异步任务或较大开销的任务时使用 watch。</p></li><li><p>函数使用小原则<br> vm 管理的函数使用普通函数<br> 不被 vm 管理的函数使用箭头函数，this 则指向 vm</p></li></ul><h2 id="绑定样式" tabindex="-1">绑定样式 <a class="header-anchor" href="#绑定样式" aria-label="Permalink to &quot;绑定样式&quot;">​</a></h2><ul><li><p>绑定 class 样式</p><ol><li>字符串写法<br> 适用于样式名不确定</li><li>数组写法<br> 使用于要绑定的样式个数和名字不确定</li><li>对象写法<br> 适用于样式个数和名字都确定，但动态决定用不用</li></ol></li><li><p>绑定 style 样式</p><ol><li><p>一般用对象写法<br> 样式名改为驼峰命名法，去除 -</p></li><li><p>数组写法</p></li></ol></li></ul><h2 id="条件渲染" tabindex="-1">条件渲染 <a class="header-anchor" href="#条件渲染" aria-label="Permalink to &quot;条件渲染&quot;">​</a></h2><ul><li><p>v-show<br> 动态修改 display 样式，应用于频繁切换的场景</p></li><li><p>v-if / v-else-if / v-else<br> 动态创建或移除元素<br> 可以与 template 标签配合使用</p></li></ul><h2 id="列表渲染" tabindex="-1">列表渲染 <a class="header-anchor" href="#列表渲染" aria-label="Permalink to &quot;列表渲染&quot;">​</a></h2><ul><li><p>遍历数组<br><code>v-for=&quot;item in list&quot;</code><br><code>v-for=&quot;(item,index) in list&quot;</code></p></li><li><p>必须绑定一个 key 属性<br> 不添加 key 时默认行为和绑定 key=&quot;index&quot; 是差不多的。<br> index 作为 key 时存在的问题：<br> 对数据进行：逆序添加、逆序删除等破坏顺序的操作时，产生没必要的真实 DOM 跟新，效率低下。如果结构中还包含输入类 DOM 时，错误 DOM 更新，产生错误的界面</p></li><li><p>Key 的作用<br> 虚拟 DOM 中 key 的作用：<br> key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 根据新数据生成新的虚拟 DOM。随后 Vue 进行新虚拟 DOM 与旧虚拟 DOM 的 diff 算法。<br> 对比规则：</p><ul><li>当没变时，直接使用之前的真实 DOM</li><li>当变化时，创建新的的真实 DOM 渲染到页面</li></ul></li><li><p>列表过滤<br> 计算属性实现<br> 监视属性实现<br> filter 方法和 indexOf 方法/includes 方法</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.name.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p>列表排序<br> sort() 方法</p></li></ul><h2 id="数据监视原理" tabindex="-1">数据监视原理 <a class="header-anchor" href="#数据监视原理" aria-label="Permalink to &quot;数据监视原理&quot;">​</a></h2><ul><li><p>Vue 会监视 data 中所有层次的数据<br> 数据劫持设计模式：观察者模式 Observer</p><p>构建一个 Observer 对象，传入原对象，遍历原对象的所有层级，依次添加 getter 和 setter，但是 get 和 set 的是原对象属性，挂载到了 Observer 对象中。</p><p>当原对象被读取时，即触发了 Observer 对象 getter 的发法</p><p>当原对象被改变时，即触发了 Observer 对象 setter 的发法</p><p>Observer 对象 getter 和 setter 里即可实现数据劫持</p></li><li><p>添加响应式数据<br><code>Vue.set()</code>(全局)<br><code>vm.$set()</code><br> 注意：不能给根数据添加属性</p></li><li><p>如何监听数组中的数组<br> Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li><li>filter()、concat() 和 slice() 等，它们不会变更原始数组，而总是返回一个新数组。当使用这些不改变原数组的方法时，可以用新数组替换旧数组。</li></ul></li></ul><h2 id="过滤器" tabindex="-1">过滤器 <a class="header-anchor" href="#过滤器" aria-label="Permalink to &quot;过滤器&quot;">​</a></h2><ul><li><p>对要显示的数据进行特定格式化后再显示<br> 适用于一些简单逻辑的处理</p></li><li><p>方法配置在 Vue 实例的 filters 对象中<br><code>filters:{filtersName(){}}</code></p></li><li><p>传参<br> 第一位为 value,第二位为传入的参数</p></li><li><p>多个过滤器串联</p></li><li><p>全局过滤器<br><code>Vue.filters(&#39;filtersName&#39;,func(){})</code><br> 必须在 Vue 实例前注入 Vue 类中</p></li></ul><h2 id="内置指令" tabindex="-1">内置指令 <a class="header-anchor" href="#内置指令" aria-label="Permalink to &quot;内置指令&quot;">​</a></h2><ul><li><p><code>v-text</code><br> 向其所在的节点中渲染文本内容<br> 会强制替换标签内容，插值语法不会</p></li><li><p><code>v-html</code><br> 向其所在的节点中渲染包含 html 结构的文本内容<br> 支持 html 结构解析<br> 存在安全性问题，容易导致 XSS 攻击</p></li><li><p><code>v-clock</code><br> 本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删除 v-clock<br> 适用 css 配合 v-cloak 可以解决网速慢导致的错误渲染出 vue 内容的问题</p></li><li><p><code>v-once</code><br> 在所在节点动态渲染后，就视为静态资源<br> 以后数据的改变不影响，用于优化性能</p></li><li><p><code>v-pre</code><br> 跳过其所在节点的编译过程，优化性能</p></li></ul><h2 id="自定义指令" tabindex="-1">自定义指令 <a class="header-anchor" href="#自定义指令" aria-label="Permalink to &quot;自定义指令&quot;">​</a></h2><ul><li><p>配置在 Vue 实例的 directives 对象中<br> 局部指令</p></li><li><p>使用方式</p><ul><li><p>对象式<br> 三个钩子函数：<br><code>bind(){}</code> 指令与元素成功绑定时<br><code>inserted(){}</code> 指令所在元素被插入页面时<br><code>update(){}</code> 指令所在模板被重新解析时</p></li><li><p>简写：函数式<br> 三个钩子函数相同时可以简写</p></li></ul></li><li><p>两个参数<br><code>element</code> 原始 DOM 节点对象<br><code>binding</code> 原始 DOM 节点对象</p></li><li><p>注意点</p><ul><li>命名风格 directives 对象中不需要加 v-。kebab-case 命名。</li><li>三个钩子函数的 this 指向 window。</li><li>全局指令 <code>Vue.directive(&#39;Name&#39;,{})</code>。</li></ul></li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><ul><li><p>定义<br> 又名生命周期函数、生命周期钩子，是 Vue 在 DOM 渲染的关键节点帮助调用的特殊函数，内部 this 指向 vm。</p></li><li><p>生命周期流程图</p></li></ul><p><img src="`+d+'" alt=""></p><ul><li><p>template 配置</p><ul><li>当不存在时，el 节点下的 DOM 会作为 template</li><li>当存在时，编译 template 进入入口函数</li><li>模板字符串里写 DOM 结构，只能有一个根节点</li></ul></li><li><p><code>vm.$destoryed</code><br> 直接触发销毁 vm</p></li><li><p>常用的生命周期方法：<br><code>mounted()</code>: 发送 ajax 请求, 启动定时器等异步任务<br><code>beforeDestory()</code>: 做收尾工作, 如: 清除定时器</p></li></ul><h2 id="组件化编程" tabindex="-1">组件化编程 <a class="header-anchor" href="#组件化编程" aria-label="Permalink to &quot;组件化编程&quot;">​</a></h2><ul><li><p>理解<br> 用来实现局部 (特定) 功能效果的代码集合 (html/css/js/image…..)<br> 作用：复用编码, 简化项目编码, 提高运行效率</p></li><li><p>使用方式<br> 创建组件 <code>const C= Vue.extend（{}）</code><br> 简写：<code>const C = {}</code></p></li><li><p>注册组件<br> 配置在 Vue 实例的 components 对象中<br> 局部注册<br> 全局注册<br><code>Vue.component(&#39;name&#39;,component)</code></p></li><li><p>使用组件<br> 组件名标签 <code>&lt;ComponentName&gt;&lt;/ComponentName&gt;</code></p></li><li><p>注意点</p><ul><li><p>命名风格</p><ul><li>一个单词时：<br> 首字母大写<br> 首字母小写</li><li>多个单词<br> kebab-case 命名<br> 划分单词，全小写<br> CamelCase 命名</li></ul></li><li><p>需要 Vue2 脚手架<br> name 配置项<br> 指定开发者工具的中组件的名字</p></li></ul></li><li><p>VueComponent</p><ul><li><p>本质是一个构造函数（类），当实例时会创建一个该构造函数的实例对象，this 指向实例对象。</p></li><li><p>一个重要关系：<br><code>VueComponent.prototype.__proto__</code>=== <code>Vue.prototype</code><br> 组件实例可以访问到 Vue 原型里的属性和方法</p></li><li><p>VueComponent 原型关系图：</p></li></ul><p><img src="'+o+`" alt=""></p></li></ul><h2 id="单文件组件-vue-文件" tabindex="-1">单文件组件.vue 文件 <a class="header-anchor" href="#单文件组件-vue-文件" aria-label="Permalink to &quot;单文件组件.vue 文件&quot;">​</a></h2><ul><li><p>一个.vue 文件的组成 (3 个部分)</p><ul><li><p>模板页面 template<br><code>&lt;template&gt;页面模板&lt;/template&gt;</code></p></li><li><p>JS 模块 script</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> methods: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> computed: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> components: {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></li><li><p>样式 style<br><code>&lt;style&gt;样式定义&lt;/style&gt;</code></p></li></ul></li><li><p>vuter 快速页面快捷方式 <code>&lt;v</code></p></li><li><p>引入组件<br><code>import name from &#39;src&#39;</code></p></li></ul><h2 id="vue-脚手架" tabindex="-1">Vue 脚手架 <a class="header-anchor" href="#vue-脚手架" aria-label="Permalink to &quot;Vue 脚手架&quot;">​</a></h2><ul><li><p>Vue 脚手架 (Command Line interface) 是 Vue 官方提供的标准化开发工具（开发平台）。</p></li><li><p>步骤</p><ol><li>(仅第一次执行)：全局安装@vue/cli</li><li>切换到你要创建项目的目录，然后使用命令创建项目<br><code>vue create xxxx</code></li><li>启动项目<br><code>npm run serve</code></li></ol></li><li><p>CLI 结构图<br><img src="`+c+`" alt=""></p></li><li><p>脚手架默认 Vue 版本不包含模板解析器<br> vue.runtime.esm.js<br> 无法使用 template，解决方法</p></li><li><p>render 配置项<br> 是一个函数，Vue 会自动调用；<br> 传入的是一个 createElement 函数</p><p>传统写法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctrateElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>简写 <code>render: h=&gt; h(App)</code></p></li><li><p>CLI 默认配置项<br> Webpack 配置文件被 Vue 隐藏 ，需在 Vue.confi.js 中配置。<br> CLI 官网可查看提供的配置项</p></li></ul><h2 id="ref-引用" tabindex="-1">ref 引用 <a class="header-anchor" href="#ref-引用" aria-label="Permalink to &quot;ref 引用&quot;">​</a></h2><ul><li><p>用来给元素或子组件注册引用信息<br> 作用：用于给节点打标识</p></li><li><p>使用<br> 标识方式：<code>&lt;div ref=&quot;name&quot;&gt;&lt;/div&gt;</code><br> 读取方式：<code>this.$refs.xxxxxx</code></p></li><li><p>当应用在传统 DOM 元素上时<br> 获取的是真实 DOM 元素</p></li><li><p>当应用在组件实例上时<br> 获取的是组件实例对象 VueComponent (简写 vc)</p></li></ul><h2 id="组件属性-props" tabindex="-1">组件属性 props <a class="header-anchor" href="#组件属性-props" aria-label="Permalink to &quot;组件属性 props&quot;">​</a></h2><ul><li><p>作用：用于父组件给子组件传递数据</p></li><li><p>传递数据<br><code>&lt;Component classname=&quot;name&quot;&gt;&lt;/Component&gt;</code></p></li><li><p>读取方式</p><ul><li><p>只指定名称：<code>props: [&#39;name&#39;, &#39;age&#39;, &#39;setName&#39;]</code></p></li><li><p>指定名称/类型/必要性/默认值</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: String, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//指定类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//是否必须传</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:xxx   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//默认值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li><li><p>注意点<br> props 是只读的，如果需要修改，需复制一份数据到 data 中。</p></li></ul><h2 id="混入-mixin" tabindex="-1">混入 mixin <a class="header-anchor" href="#混入-mixin" aria-label="Permalink to &quot;混入 mixin&quot;">​</a></h2><ul><li><p>把多个组件公用的配置提取成一个混入对象</p></li><li><p>定义混合<br> 在 js 文件中暴露一个 vc 配置对象，里面可包含 data,methods,生命周期等</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//混入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //公用的组件配置项</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>配置在组件实例的 mixins 对象中<br><code>import ...</code><br><code>mixins:[xxx1,xxx2]</code></p></li><li><p>全局混入<br><code>import ...</code><br><code>Vue.mixin(xxx)</code></p></li></ul><h2 id="插件-plugins" tabindex="-1">插件 plugins <a class="header-anchor" href="#插件-plugins" aria-label="Permalink to &quot;插件 plugins&quot;">​</a></h2><ul><li><p>定义插件<br> 在 js 文件中暴露一个 install 方法，参数包含 Vue 构造器，里面可定义 Vue 的全局配置</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//插件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//全局过滤器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {})  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//全局自定义指令</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mixin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//全局混入</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//全局方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>使用<br><code>import ...</code><br><code>Vue.use(xxx, [option])</code></p></li></ul><h2 id="样式穿透-scoped" tabindex="-1">样式穿透 scoped <a class="header-anchor" href="#样式穿透-scoped" aria-label="Permalink to &quot;样式穿透 scoped&quot;">​</a></h2><p>让样式局部生效，防止冲突 <code>&lt;style scoped&gt;</code></p><p>一般应用于子组件，根组件不使用。</p><h2 id="组件化编码流程-通用" tabindex="-1">组件化编码流程（通用） <a class="header-anchor" href="#组件化编码流程-通用" aria-label="Permalink to &quot;组件化编码流程（通用）&quot;">​</a></h2><ol><li><p>实现静态组件：<br> 抽取组件，使用组件实现静态页面效果</p></li><li><p>展示动态数据：</p><ul><li>数据的类型、名称是什么？</li><li>数据保存在哪个组件？</li></ul></li><li><p>交互——从绑定事件监听开始</p></li></ol><p>注意：<br> v-model 不能绑定 props 传过来的值，因为 props 不能修改</p><h2 id="浏览器本地存储" tabindex="-1">浏览器本地存储 <a class="header-anchor" href="#浏览器本地存储" aria-label="Permalink to &quot;浏览器本地存储&quot;">​</a></h2><ul><li><p>localStorage</p><ul><li>写 <code>setItem()</code></li><li>读 <code>getItem()</code></li><li>删 <code>removeItem()</code></li><li>清空 <code>clear()</code></li></ul></li><li><p>sessionStorage<br> API 同 localStorage</p></li><li><p>注意点：</p><ul><li><p>sessionStorage 浏览器关闭会自动清空</p></li><li><p>localStorage 不会，除非手动清空</p></li><li><p>存储大小一般为 5MB</p></li></ul></li></ul><h2 id="自定义事件" tabindex="-1">自定义事件 <a class="header-anchor" href="#自定义事件" aria-label="Permalink to &quot;自定义事件&quot;">​</a></h2><ul><li><p>方式一<br><code>@EventName = &quot;method&quot;</code></p></li><li><p>方式二<br> 组件在添加 ref<br> 父组件生命周期中使用 <code>this.$ref().$on()</code></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EventName, method))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EventName, method))</span></span></code></pre></div><p>子组件中解绑自定义事件<br><code>$off(eventName)</code><br> 当子组件被销毁后自定义事件被销毁，原生事件不会被销毁</p></li><li><p>触发自定义事件<br><code>$emit(eventName, data)</code></p></li><li><p>注意点</p><ol><li>当使用 $on 或 $once 时，如果回调 method 时一个普通函数，this 指向的是子组件。因此建议传入的是父组件 methods 里的方法或者使用箭头函数进行规避。</li><li>当给子组件添加 click 等原生事件时，会被认为是自定义事件，需要添加.native 修饰符</li></ol></li></ul><h2 id="全局事件总线-eventbus" tabindex="-1">全局事件总线 EventBus <a class="header-anchor" href="#全局事件总线-eventbus" aria-label="Permalink to &quot;全局事件总线 EventBus&quot;">​</a></h2><ul><li><p>指定事件总线对象<br> 可以由 Vue 的实例或 VueComponent 的实例承担</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () { </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$globalEventBus </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>绑定事件 (谁需要广播谁用)<br><code>this.$globalEventBus.on(&#39;Event&#39;, Method）</code></p></li><li><p>订阅事件 (谁要提供数据谁调)<br><code>this.$globalEventBus.emit(&#39;Event&#39;, Data)</code></p></li><li><p>解绑事件<br><code>this.$globalEventBus.off(&#39;Event&#39;&#39;)</code><br> 最好在 beforeDestroy 钩子中解绑<br> 必须带有事件名；否则将解绑所有事件</p></li></ul><h2 id="订阅与发布" tabindex="-1">订阅与发布 <a class="header-anchor" href="#订阅与发布" aria-label="Permalink to &quot;订阅与发布&quot;">​</a></h2><ul><li><p>操作</p><ol><li>订阅消息 -- 对应绑定事件监听</li><li>发布消息 -- 分发事件</li><li>取消消息订阅 -- 解绑事件监听</li></ol></li><li><p>第三方实现库<br> PubSubJS</p></li><li><p>使用</p><ul><li><code>import PubSub from &#39;pubsub-js&#39;</code> 引入</li><li><code>PubSub.subscribe(‘msgName’, functon(msgName, data){ })</code> 发布消息</li><li><code>PubSub.publish(‘msgName’, data)</code> 触发订阅的回调函数调用</li><li><code>PubSub.unsubscribe(token)</code> 取消消息的订阅</li></ul></li></ul><h2 id="组件通信" tabindex="-1">组件通信 <a class="header-anchor" href="#组件通信" aria-label="Permalink to &quot;组件通信&quot;">​</a></h2><ul><li><p>父传子<br> props<br> 插槽</p></li><li><p>子传父<br> props：父给子传一个函数引用<br> 自定义事件：父给子身上绑定一个自定义事件，事件的回调是父组件的一个函数引用。</p></li><li><p>任意组件通信<br> 全局事件总线<br> 广播一个事件，回调是函数引用<br> 订阅与发布实现库<br> vuex</p></li></ul><h2 id="nexttick" tabindex="-1">$nexttick() <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;$nexttick()&quot;">​</a></h2><p>作用：在下一次 DOM 更新结束后执行指定的回调</p><p>使用场景：当改变数据后，要基于更新后的新 DOM 进行某些操作，可以在回调中执行</p><h2 id="动画效果" tabindex="-1">动画效果 <a class="header-anchor" href="#动画效果" aria-label="Permalink to &quot;动画效果&quot;">​</a></h2><ul><li><p>原理<br> 在插入、更新或移除 DOM 元素时，Vue 在合适的时候给元素添加或移除特定样式名<br> 操作 css 的 trasition 或 animation</p></li><li><p><code>&lt;transition&gt;&lt;/transition&gt;</code><br> 包裹需要动画的标签对<br> 特定属性：<br> name 定义动画名<br> appear 进入页面时有动画<br><code>&lt;transition-group&gt;&lt;/transition-group&gt;</code></p></li><li><p>动画实现</p><ol><li>设置动画， 同 CSS3 keyframes</li><li><code>name-enter-active</code> 指定显示的 transition</li><li><code>name-leave-active</code> 指定隐藏的 transition</li></ol></li><li><p>过渡实现</p><ol><li>设置过渡，同 CSS3 transition</li><li><code>name-enter</code> <code>xxx-enter-to</code><br> 分别指定进去前和进入后的样式</li><li><code>name-leave</code> <code>xxx-leave-to</code><br> 分别指定离开前和离开后的样式</li><li>指定过渡效果 transition: 0.5s linear</li></ol></li><li><p>第三方动画库<br> animate.css <a href="https://animate.style/" target="_blank" rel="noreferrer">Animate.css | A cross-browser library of CSS animations.</a></p></li></ul><h2 id="配置代理" tabindex="-1">配置代理 <a class="header-anchor" href="#配置代理" aria-label="Permalink to &quot;配置代理&quot;">​</a></h2><ul><li><p>请求方式</p><ul><li>原生 xhr <code>new XMLHttpRequest()</code> <code>xhr.open()</code> <code>xhr.send()</code></li><li>jQuery <code>$.get $.post</code></li><li>axios</li><li>vue-resource</li><li>fetch</li></ul></li><li><p>跨域解决</p><ul><li>cors 响应头</li><li>jsonp script src</li><li>代理服务器</li><li>利用服务器与服务器间是原生的 http 协议，没有跨域问题</li><li>nginx</li><li>vue-cli 配置方法</li></ul></li><li><p>vue-cli 配置方法</p><ul><li><p>方式一</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">devServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://localhost:4000&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><ul><li>优点<br> 配置简单</li><li>缺点<br> 本地服务器的资源优先级高于访问服务器的资源<br> 不能够开启多个代理，不能够灵活控制是否走代理</li></ul></li><li><p>方式二</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">devServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//匹配以‘/api&#39;开头的请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;url&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//目标路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathRewrite: { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;^/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//重写路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ws: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//用于支持websocket</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //用于控制请求头中的host值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   ......</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>优点<br> 可以配置多个代理，灵活控制</li><li>缺点<br> 配置较为繁琐<br> 请求资源需要加前缀</li></ul></li></ul></li></ul><h2 id="插槽-slot" tabindex="-1">插槽 Slot <a class="header-anchor" href="#插槽-slot" aria-label="Permalink to &quot;插槽 Slot&quot;">​</a></h2><p>定义：父组件向子组件传递带数据的标签，当一个组件有不确定的结构时, 就需要使用 slot 技术。</p><p>注意：插槽内容是在父组件中编译后, 再传递给子组件的</p><ol><li><p>默认插槽</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//父组件中：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Category</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;html结构1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Category</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//子组件中：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 定义插槽 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;插槽默认内容</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></li><li><p>命名插槽</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//父组件中：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Category</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;center&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;html结构1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:footer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		 &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;html结构2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Category</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//子组件中：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		 &lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 定义插槽 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		 &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slot name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;center&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;...&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		 &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slot name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;footer&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;...&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></li><li><p>作用域插槽<br> 数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定<br> 插槽中用 <code>&lt;template&gt;</code> 包裹，并且使用 <code>scope=&quot;xxx&quot;</code> 属性，使能访问子组件中的数据，xxx 是一个对象，包含子组件 slot 的所有属性。<br> scope=&quot;{xxx}&quot;,结构赋值直接使用更为方便</p></li></ol><h2 id="vuex" tabindex="-1">vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;vuex&quot;">​</a></h2><ul><li><p>概念<br> 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p></li><li><p>使用场景</p><ol><li>多个组件依赖于同一状态</li><li>来自不同组件的行为需要变更同一状态</li></ol></li><li><p>Vuex 工作原理图</p><p><img src="`+E+`" alt=""></p></li><li><p>搭建 Vuex 环境</p><ol><li>src 下创建 store 文件夹，创建 index.js 文件</li><li>引入 Vue 和 Vuex</li><li><code>Vue.use(Vuex)</code><br> 必须先使用插件再应用 Store</li><li>创建并暴露 <code>Vuex.store({})</code> 实例</li><li>Vue 实例时添加 store</li></ol></li><li><p>基本使用</p><ul><li><p>actions<br> 值为一个对象，包含多个响应用户动作的回调函数<br> 方法中通过 commit( ) 来触发 mutation 中函数的调用, 间接更新 state<br> 组件调用 <code>this.$store.dispatch(&#39;actionName&#39;，value)</code></p></li><li><p>mutations<br> 值是一个对象，包含多个直接更新 state 的方法<br> actions 调用<br> 组件直接调用 <code>this.$store.commit(&#39;mutationName&#39;，value)</code></p></li><li><p>state<br> vuex 管理的状态对象<br> 组件调用 <code>this.$store.state.xxx</code></p></li><li><p>getters<br> 值为一个对象，包含多个用于返回数据的函数<br> 组件调用 <code>this.$store.getters.xxx</code></p></li></ul></li><li><p>四个 map 方法的使用</p><ul><li><p>目的：简写组件中大量的 $store.xxx.xxx</p></li><li><p>引入<br><code>import { mapState, mapGetters } from &#39;vuex&#39;</code></p></li><li><p>mapState 方法<br> 用于帮助我们映射 state 中的数据为计算属性，利用...解构返回对象中的方法，并添加入组件中的 computed<br><code>...mapState({sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;})</code><br><code>...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])</code></p></li><li><p>mapGetters 方法<br> 用于帮助我们映射 getters 中的数据为计算属性<br><code>...mapGetters({bigSum:&#39;bigSum&#39;})</code><br><code>...mapGetters([&#39;bigSum&#39;])</code></p></li><li><p>mapActions 方法<br> 用于帮助我们生成与 actions 对话的方法，利用...解构返回对象中的方法，并添加入组件中的 methods<br><code>...mapActions({incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;})</code><br><code>...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])</code></p></li><li><p>mapMutations 方法<br> 用于帮助我们生成与 mutations 对话的方法<br><code>...mapMutations({increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;})</code><br><code>...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;])</code></p></li><li><p>注意点<br> mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象</p></li></ul></li><li><p>模块化 + 命名空间</p><ul><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>使用方法</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//通过单独的js文件暴露moudleA、moudleB</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moudleA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    namespaced:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //开启命名空间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">同store配置项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moudleB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    namespaced:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //开启命名空间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">同store配置项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  modules: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    moudleA,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    moudleB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p>直接读取数据/调用方法变化<br><code>this.$store.state.moudleA.xxx</code><br><code>this.$store.getters[&#39;moudleA/xxx&#39;]</code></p><p>读取方式与 state 不同，由于需要用‘/’，因此使用[&#39;&#39;] 读取对象属性</p><p><code>this.$store.dispatch(&#39;moudleA/actionName&#39;,value)</code><br><code>this.$store.commit(&#39;moudleA/mutationName&#39;,value)</code></p></li><li><p>map 方法变化<br> 第一个参数为模块名，第二个参数同源用法<br><code>...mapState(&#39;moudleA&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])</code></p><p><code>...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])</code></p><p><code>...mapActions(&#39;countAbout&#39;,{incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;})</code></p><p><code>...mapMutations(&#39;countAbout&#39;,{increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;})</code></p></li></ul></li></ul><h2 id="路由-router" tabindex="-1">路由 router <a class="header-anchor" href="#路由-router" aria-label="Permalink to &quot;路由 router&quot;">​</a></h2><ul><li><p>理解<br> 一个路由（route）就是一组映射关系（key - value）<br> 多个路由需要路由器（router）进行管理<br> 前端路由：key 是路径，value 是组件<br> 后端路由：key 是路径，value 是一个处理本次请求的响应函数</p></li><li><p>目的<br> 实现单页面应用 SPA<br> 整个应用只有一个完整的页面<br> 点击页面中的导航链接不会刷新页面，只会做页面的局部更新<br> 数据需要通过 ajax 请求获取</p></li><li><p>vue-router<br> vue 的一个插件库，专门用于实现 SPA 应用</p></li><li><p>工作模式</p><ul><li>hash 模式<br> href 带#，#及其后面的内容就是 hash 值<br> #后的变动不会直接引起 http 请求，改变会触发 hashchange 事件，事件中进行路由处理</li><li>history 模式<br> 会先查找前端路由，如果不存在则浏览器直接发起 http 请求<br><code>mode:&#39;history&#39;</code></li></ul></li><li><p>使用</p><ol><li><p>安装 vue-router</p></li><li><p>应用插件<br><code>Vue.use(VueRouter)</code></p></li><li><p>编写 router 配置项</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes:[                           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//注意此为routes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/about&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//key</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      component:About   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      component:Home</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p>实现切换（active-class 可配置高亮样式）</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> active-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;active&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/about&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;About&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-link</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;\`</span></span></code></pre></div></li><li><p>指定展示位置<br><code>&lt;router-view&gt;&lt;/router-view&gt;</code></p></li></ol></li><li><p>几个注意点</p><ol><li>路由组件通常存放在 <code>pages</code> 文件夹，一般组件通常存放在 <code>components</code> 文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的 <code>$route</code> 属性，里面存储着自己的路由信息。</li><li>整个应用只有一个 router，可以通过组件的 <code>$router</code> 属性获取到。</li></ol></li><li><p>嵌套（多级）路由<br> 使用 children 配置项<br><code>path:&#39;news&#39;</code><br> path 不需要写完整，不需要添加‘/’<br><code>\\&lt;router-link to=&quot;/home/news&quot;&gt;News\\&lt;/router-link&gt;</code><br> 跳转地址需要写完整</p></li><li><p>命名路由<br> 作用：可以简化路由的跳转<br> routes 中给路由添加 name 属性<br> :to 中使用 name 属性，不使用 path 属性</p></li><li><p>query 参数<br> 字符串写法（模板字符串）<br> 对象写法</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">666</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你好&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>接收参数<br><code>$route.query.id</code><br><code>$route.query.title</code></p></li><li><p>params 参数<br><code>path:&#39;detail/:id/:title&#39;</code><br> 使用占位符声明接收 params 参数</p><ul><li><p>字符串写法</p><ul><li>param 作为 path 的下级路径名</li></ul></li><li><p>对象写法<br> 路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">666</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你好&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><p>接收参数<br><code>$route.params.id</code><br><code>$route.params.title</code></p></li><li><p>props 配置</p><ul><li><p>作用：让路由组件更方便的收到参数</p></li><li><p>第一种写法：props 值为对象，该对象中所有的 key-value 的组合最终都会通过 props 传给 Detail 组件<br><code>props:{a:900}</code></p></li><li><p>第二种写法：props 值为布尔值，布尔值为 true，则把路由收到的所有 params 参数通过 props 传给 Detail 组件<br><code>props:true</code></p></li><li><p>第三种写法：props 值为函数，该函数返回的对象中每一组 key-value 都会通过 props 传给 Detail 组件</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(route){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      id:route.query.id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      title:route.query.title</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({query:{id,title}})</span></span></code></pre></div></li></ul><p>组件 props 属性接收</p></li><li><p><code>&lt;router-link&gt;</code> 的 replace 属性<br> 作用：控制路由跳转时操作浏览器历史记录的模式</p><p>浏览器的历史记录有两种写入方式：push、replace</p><p><code>replace</code> 属性用于开启</p></li><li><p>编程式路由导航</p><ul><li><p>作用：不借助 <code>&lt;router-link&gt; </code> 实现路由跳转，让路由跳转更加灵活</p></li><li><p>路由 API</p><ol><li><p><code>this.$router.push({...})</code> 相当于点击路由链接 (可以返回到当前路由界面)</p></li><li><p><code>this.$router.replace({...})</code> 用新路由替换当前路由 (不可以返回到当前路由界面)</p></li><li><p><code>this.$router.forward()</code> 前进</p></li><li><p><code>this.$router.back()</code> 后退</p></li><li><p><code>this.$router.go()</code> 可前进（正数）也可后退（负数）</p></li></ol></li></ul></li><li><p>缓存路由组件</p><ul><li>作用：让不展示的路由组件保持挂载，不被销毁</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">alive include</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;News&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">alive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>include 包含，exclude 排除，属性值为组件名</p><ul><li>两个新的生命周期钩子<br><code>activated</code> 路由组件被激活时触发<br><code>deactivated</code> 路由组件失活时触发</li></ul></li><li><p>路由守卫</p><ul><li><p>作用：对路由进行权限控制</p></li><li><p>分类</p><ol><li>全局守卫</li><li>独享守卫</li><li>组件内守卫</li></ol></li><li><p>meta 配置属性<br> 元信息，用于存放程序员想存放的信息，进行路由守卫判断</p></li><li><p>全局守卫</p><ul><li>全局前置守卫<br> 初始化时执行、每次路由切换前执行<br><code>router.beforeEach((to,from,next)=&gt;{}）</code></li><li>全局后置守卫<br> 初始化时执行、每次路由切换后执行<br><code>router.afterEach((to,from)=&gt;{}）</code></li></ul></li><li><p>独享守卫<br><code>beforeEnter(to,from,next){})</code></p></li><li><p>组件内守卫</p><ul><li>进入守卫：通过路由规则，进入该组件时被调用<br><code>beforeRouteEnter(to, from, next){}</code></li><li>离开守卫：通过路由规则，离开该组件时被调用<br><code>beforeRouteLeave(to, from, next){}</code></li></ul></li></ul></li></ul><h2 id="项目部署" tabindex="-1">项目部署 <a class="header-anchor" href="#项目部署" aria-label="Permalink to &quot;项目部署&quot;">​</a></h2><p><code>npm run build</code></p><p>搭建服务器</p><h2 id="vue-ui-组件库" tabindex="-1">Vue UI 组件库 <a class="header-anchor" href="#vue-ui-组件库" aria-label="Permalink to &quot;Vue UI 组件库&quot;">​</a></h2><ul><li>移动端常用 UI 组件库 <ol><li>Vant <a href="https://youzan.github.io/vant" title="https://youzan.github.io/vant" target="_blank" rel="noreferrer">https://youzan.github.io/vant</a></li><li>Cube UI <a href="https://didi.github.io/cube-ui" title="https://didi.github.io/cube-ui" target="_blank" rel="noreferrer">https://didi.github.io/cube-ui</a></li><li>Mint UI <a href="http://mint-ui.github.io" title="http://mint-ui.github.io" target="_blank" rel="noreferrer">http://mint-ui.github.io</a></li></ol></li><li>PC 端常用 UI 组件库 <ol><li>Element UI <a href="https://element.eleme.cn" title="https://element.eleme.cn" target="_blank" rel="noreferrer">https://element.eleme.cn</a></li><li>IView UI <a href="https://www.iviewui.co" title="https://www.iviewui.co" target="_blank" rel="noreferrer">https://www.iviewui.co</a></li></ol></li><li>全部引入/按需引入</li></ul><h2 id="知识补充" tabindex="-1">知识补充 <a class="header-anchor" href="#知识补充" aria-label="Permalink to &quot;知识补充&quot;">​</a></h2><ul><li><p>路由</p><ul><li><p>重定向</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    redirecte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/home&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div></li><li><p>如何指定 params 可传可不传<br> 占位符后 +？<br> 否则当 params 为空时，路由不跳转</p></li><li><p>params 如果传递的是空字符串<br><code>|| undefined</code><br> 否则当 params 为字符串时，路由不跳转</p></li><li><p>编程式路由跳转时如果参数一致，会产生 NavigationDuplicated 错误</p><ul><li>原由<br> vue-router 新版本引入了 promise。如果路由跳转时里面的参数没有改变，会返回一个失败的 promise，如果不去处理这个失败的 promise，就会抛出这个错误。而声明式路由导航不会出现这种错误，因为 Vue 在底层已经处理好了。</li><li>解决办法<br> 每次传入成功或者失败的回调<br><code>router.push(location, onComplete?, onAbort?)</code><br> 改写 router 函数</li></ul></li></ul></li><li><p>axios 二次封装<br> 作用：配置请求拦截器和响应拦截器<br> 请求拦截器</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">requests.interceptors.request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //返回请求头headers</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>响应拦截器</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">requests.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></li><li><p>接口统一管理</p><ul><li>小项目<br> 完全可以组件的生命周期中发请求</li><li>大项目<br> 在一个 js 文件中对外暴露预先定义好的若干请求，进行统一管理</li></ul></li><li><p>nprogress<br> 请求进度条插件<br> 步骤一：引入 js 与 css 样式<br> 步骤二：<code>nprogress.start()</code> 方法开始<br> 步骤三：<code>nprogress.done()</code> 方法结束</p></li><li><p>vuex<br> 状态管理库插件，集中管理项目中组件公用的数据<br> state<br> getters<br> mutations<br> actions<br> 模块化开发<br><code>modules：{}</code></p></li><li><p>导航栏效果实现</p><ul><li><p>动态添加背景色<br> 方法一：hover 样式<br> 方法二：JS mouseenter/mouseleave</p></li><li><p>动态显示和隐藏<br> 方法一：display:block/none<br> 方法二：JS</p></li></ul></li><li><p>防抖与节流 <a href="./../../03 JavaScript/05高级语言特性/防抖与节流.html">防抖与节流</a></p><ul><li>防抖<br> 前面所有的触发都被取消，最后一次执行在规定的时间后才触发；也就是说如果连续快速触发，只会执行一次</li><li>节流<br> 在规定的时间间隔内不会重复触发回调，至于大于这个时间间隔才会触发，把频繁触发变成少量触发</li><li>理解<br> 防抖是回城，会被打断，每次被打断重新计算时间直至完成回城的时间间隔；节流是 cd，施放完技能后进入一个倒计时，倒计时完毕后方可再次释放技能</li><li>实现<br> 闭包 + 延迟器</li><li>lodash 插件<br> 封装了防抖与节流的业务<br><code>_.debounce()</code><br><code>_.throttle()</code></li></ul></li><li><p>工具拓展</p><ul><li>mock.js<br> 一个数据模拟插件<br> 使用方法： <ol><li>项目中创建 src/mock 文件夹</li><li>准备好返回的 JSON</li><li>准备好图片等静态资源</li><li>创建 mockServe.js <code>Mock.mock(本地地址, 返回的 JSON)</code></li><li>入口文件中执行<br> swiper 库</li></ol></li></ul></li></ul>`,86))])}const C=t(u,[["render",g]]);export{A as __pageData,C as default};
