import{_ as i,c as a,o as l,ae as n}from"./chunks/framework.CIivgcbp.js";const c=JSON.parse('{"title":"TypeScript(基础）","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/05 TypeScript/TS(第二轮-小满)/TypeScript(基础).md","filePath":"前端技术/05 TypeScript/TS(第二轮-小满)/TypeScript(基础).md"}'),t={name:"前端技术/05 TypeScript/TS(第二轮-小满)/TypeScript(基础).md"};function e(p,s,h,k,r,d){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="typescript-基础" tabindex="-1">TypeScript(基础） <a class="header-anchor" href="#typescript-基础" aria-label="Permalink to &quot;TypeScript(基础）&quot;">​</a></h1><div class="note custom-block github-alert"><p class="custom-block-title">Title</p><p><a href="https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=090e83bb222c29671e06b8517288701c" target="_blank" rel="noreferrer">小满TypeScript基础教程全集（完结）_哔哩哔哩_bilibili</a></p></div><h2 id="基础类型" tabindex="-1">基础类型 <a class="header-anchor" href="#基础类型" aria-label="Permalink to &quot;基础类型&quot;">​</a></h2><p>类型定义语法 <code>变量：类型</code></p><ol><li><p>字符串类型 <code>string</code></p></li><li><p>数字类型 <code>number</code><br> - 支持十六进制、十进制、八进制和二进制</p></li><li><p>布尔类型 <code>boolean</code></p></li><li><p>空值类型 <code>void</code></p></li><li><p><code>undefined</code> 和 <code>null</code> 类型<br> - 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 string 类型的变量。</p></li><li><p>任意类型 <code>any</code> 类型 和 <code>unknown</code> 顶级类型</p><ul><li>如果使用 any 就失去了 TS 类型检测的作用</li><li>TypeScript 3.0 中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给 unknown</li></ul></li><li><p>ES6 的 <a href="http://es6.ruanyifeng.com/#docs/symbol" title="Symbol" target="_blank" rel="noreferrer">Symbol</a> 和 ES10 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" title="BigInt" target="_blank" rel="noreferrer">BigInt</a></p></li></ol><h2 id="类型层级" tabindex="-1">类型层级 <a class="header-anchor" href="#类型层级" aria-label="Permalink to &quot;类型层级&quot;">​</a></h2><ol><li>any、unknown</li><li>Object</li><li>Number、String、Boolean......</li><li>number、string、boolean......</li><li>1 &#39;xxx&#39; false</li><li>never</li></ol><h2 id="接口和对象类型" tabindex="-1">接口和对象类型 <a class="header-anchor" href="#接口和对象类型" aria-label="Permalink to &quot;接口和对象类型&quot;">​</a></h2><p>在 typescript 中，我们定义对象的方式要用关键字 interface（接口），我的理解是使用 interface 来定义一种约束，让数据的结构满足约束的格式。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InterfaceName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>重名接口自动合并</li><li>可选属性 使用？操作符 <code>age?:string</code></li><li>任意属性签名 <code>[propName: string]: any</code></li><li>只读属性 readonly</li></ul><h2 id="数组类型" tabindex="-1">数组类型 <a class="header-anchor" href="#数组类型" aria-label="Permalink to &quot;数组类型&quot;">​</a></h2><p>定义</p><ul><li><code>类型[]</code></li><li><code>Array&lt;类型&gt;</code> （泛型写法）</li></ul><p>多维数组 <code>类型[][]</code></p><p>arguments 类数组 使用 ts 内置对象 IArguments 定义</p><p>元组 <code> [number,string,stirng]</code> 固定数量的数组</p><h2 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h2><ul><li><p>定义</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">参数</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类型</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">参数</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类型</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类型</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>默认值 <code>参数: 类型=默认值</code></p></li><li><p>可选参数 <code>参数？: 类型</code></p></li><li><p>剩余参数 <code>...arg:any[]</code></p></li><li><p>this 可以在第一个参数中定义类型</p></li><li><p><strong>函数重载</strong><br> 重载是方法名字相同，而参数不同，返回类型可以相同也可以不同</p></li></ul><h2 id="联合类型" tabindex="-1">联合类型 <a class="header-anchor" href="#联合类型" aria-label="Permalink to &quot;联合类型&quot;">​</a></h2><p><code>变量:类型1 | 类型2| ..</code></p><h2 id="交叉类型" tabindex="-1">交叉类型 <a class="header-anchor" href="#交叉类型" aria-label="Permalink to &quot;交叉类型&quot;">​</a></h2><p><code>变量:类型1 &amp; 类型2 &amp; ..</code></p><p>多种类型的集合，联合对象将具有所联合类型的所有成员</p><h2 id="类型断言" tabindex="-1">类型断言 <a class="header-anchor" href="#类型断言" aria-label="Permalink to &quot;类型断言&quot;">​</a></h2><p><code>值 as 类型 </code> <code>value as string</code></p><p><code>&lt;类型&gt;值 </code> <code>&lt;string&gt;value</code> （泛型写法）</p><p>类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p><p><strong>非空断言 <strong><strong><code>变量!.属性 = xxx</code></strong></strong>，断言变量不为 undifned | null</strong></p><h2 id="内置对象" tabindex="-1">内置对象 <a class="header-anchor" href="#内置对象" aria-label="Permalink to &quot;内置对象&quot;">​</a></h2><ul><li>ECMAScript 的内置对象<br> Boolean、Number、string、RegExp、Date、Error 等</li><li>DOM 和 BOM 的内置对象<br> Document、HTMLElement、Event、NodeList 等</li></ul><h2 id="class-类" tabindex="-1">Class 类 <a class="header-anchor" href="#class-类" aria-label="Permalink to &quot;Class 类&quot;">​</a></h2><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  属性名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类型</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">参数</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 类型</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.属性名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 参数;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  方法名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>类的修饰符<br> - public 可以让你定义的变量 内部访问 也可以外部访问 如果不写默认就是 public<br> - private 代表定义的变量私有的只能在内部访问 不能在外部访问<br> - protected 代表定义的变量私有的只能在内部和继承的子类中访问 不能在外部访问</li><li>static 静态属性 和 静态方法</li><li>抽象类<br><code>abstract class xx{}</code></li></ul><h2 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h2><p><code>emum E {}</code></p><p>ts 定义的枚举中的每一个组员默认都是从 0 开始的</p><ul><li>字符串枚举</li><li>异构枚举 枚举可以混合字符串和数字成员</li><li>接口枚举</li><li>const 枚举</li><li>反向映射 <code>E[映射值]</code></li></ul><h2 id="类型别名" tabindex="-1">类型别名 <a class="header-anchor" href="#类型别名" aria-label="Permalink to &quot;类型别名&quot;">​</a></h2><p><code>type 别名 = 类型组合</code></p><h2 id="never-类型" tabindex="-1">never 类型 <a class="header-anchor" href="#never-类型" aria-label="Permalink to &quot;never 类型&quot;">​</a></h2><p>TypeScript 将使用 never 类型来表示不应该存在的状态</p><ul><li>常用于兜底逻辑，当更改部分代码时可以及时提示</li></ul><h2 id="symbol-类型" tabindex="-1">symbol 类型 <a class="header-anchor" href="#symbol-类型" aria-label="Permalink to &quot;symbol 类型&quot;">​</a></h2><p>自 ECMAScript 2015 起，symbol 成为了一种新的原生类型，就像 number 和 string 一样。</p><p><code>let s = Symbol(string 或 number)</code></p><p>可以传递参做为唯一标识 只支持 string 和 number 类型的参数</p><ul><li>Symbol 的值是唯一的</li><li>可用作对象属性的键，防重</li><li>使用 symbol 定义的属性，是不能通过如下方式遍历拿到的<br> - 可以通过 Object.getOwnPropertySymbols(obj)、Reflect.ownKeys(obj) 拿到</li><li><strong><code>Symbol.iterator</code></strong> 实现迭代器、生成器、for of 语法糖</li></ul><h2 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h2><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>相当于动态类型，在函数调用时确定具体类型</p><ul><li><p>支持多个泛型 <code>&lt;T，K&gt;</code>、支持默认类型 <code>&lt;T=number&gt;</code></p></li><li><p>定义泛型接口进行泛型约束</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {  </span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	 length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getLegnth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLegnth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 约束类型必须含有 length 属性</span></span></code></pre></div></li><li><p>使用 keyof 约束对象<br> - keyof 操作符获取 T 类型的所有键，它的返回 类型是联合 类型</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> keyof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	 return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj[key]  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//此时就会报错发现找不到</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//约束 K 泛型是 T 泛型中的属性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	\`\`\`</span></span></code></pre></div></li></ul>`,52)]))}const E=i(t,[["render",e]]);export{c as __pageData,E as default};
