import{_ as a,c as r,o as e,ae as l}from"./chunks/framework.CIivgcbp.js";const b=JSON.parse('{"title":"03 变量、作用域与内存","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/03 变量、作用域与内存.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/03 变量、作用域与内存.md"}'),i={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/03 变量、作用域与内存.md"};function o(d,t,c,n,p,h){return e(),r("div",null,t[0]||(t[0]=[l('<h1 id="_03-变量、作用域与内存" tabindex="-1">03 变量、作用域与内存 <a class="header-anchor" href="#_03-变量、作用域与内存" aria-label="Permalink to &quot;03 变量、作用域与内存&quot;">​</a></h1><h2 id="原始值与引用值" tabindex="-1">原始值与引用值 <a class="header-anchor" href="#原始值与引用值" aria-label="Permalink to &quot;原始值与引用值&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特点</th><th>原始值</th><th>引用值</th></tr></thead><tbody><tr><td>定义</td><td>最简单的数据</td><td>由多个值构成的对象</td></tr><tr><td>存储方式</td><td>按值访问</td><td>按引用访问</td></tr><tr><td>复制值</td><td>独立的复制</td><td>复制的是指针，指向堆内存中的对象</td></tr><tr><td>传递参数</td><td>相当于独立的复制</td><td>值在内存中的位置会被保存在一个局部变量，修改会反映到函数外部</td></tr><tr><td>确定类型</td><td>使用 <code>typeof</code></td><td><code>typeof</code> 返回 &#39;object&#39;，使用 <code>instanceof</code> 来确定具体对象类型</td></tr></tbody></table><h2 id="执行上下文与作用域" tabindex="-1">执行上下文与作用域 <a class="header-anchor" href="#执行上下文与作用域" aria-label="Permalink to &quot;执行上下文与作用域&quot;">​</a></h2><ul><li><p>变量对象<br> 执行上下文决定了变量或函数可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的==变量对象==（无法通过代码访问），而这个上下文中定义的所有变量和函数都存在于这个对象上。</p></li><li><p>全局上下文<br> 全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象。因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法（let 和 const 不能）。</p><p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p></li><li><p>函数上下文<br> 每个函数调用都有自己的上下文。当代码执行流进入函数时，==函数的上下文被推到一个上下文栈上==。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。</p></li><li><p>作用域链<br> ==上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。==这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其==活动对象==（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</p></li></ul><h3 id="作用域链增强" tabindex="-1">作用域链增强 <a class="header-anchor" href="#作用域链增强" aria-label="Permalink to &quot;作用域链增强&quot;">​</a></h3><p>有两种情况下会出现这个临时上下文来增强作用域链：</p><ol><li><p>try/catch 语句的 catch 块<br> 会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p></li><li><p>with 语句<br> 会向作用域链前端添加指定的对象</p></li></ol><h3 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-label="Permalink to &quot;变量声明&quot;">​</a></h3><ol><li><p>使用 var 的函数作用域声明<br> 在使用 var 声明变量时，变量会被自动添加到最接近的上下文。<br> var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。</p></li><li><p>使用 let 的块级作用域声明<br> let 的作用域是块级的。<br> 重复的 let 声明会抛出 SyntaxError。<br> 严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。</p></li><li><p>使用 const 的常量声明<br> const 声明的变量必须同时初始化为某个值。<br> 一经声明，在其生命周期的任何时候都不能再重新赋予新值。<br> 赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code></p></li><li><p>标识符查找<br> 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p></li></ol><h3 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h3><p>JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。<br> 基本思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。</p><p>浏览器主要的标记策略：标记清理和引用计数。</p><ol><li><p>标记清理<br> JavaScript 最常用的垃圾回收策略是<strong>标记清理（mark-and-sweep）</strong>。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。<br> 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p></li><li><p>引用计数<br> 另一种没那么常用的垃圾回收策略是<strong>引用计数（reference counting</strong>）。其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。<br> 引用计数有一个严重的问题：循环引用。==所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。==此时它们的引用数永远不会变成 0。</p></li></ol><ul><li>内存管理<br> 优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作==解除引用==。</li><li>可以在实践中通过以下方式提升垃圾回收的性能。 <ol><li>通过 const 和 let 声明提升性能</li><li>隐藏类和删除操作</li><li>使用对象池</li></ol></li><li>容易造成内存泄漏的情况 <ol><li>意外声明全局变量</li><li>定时器的回调通过闭包引用了外部变量</li><li>使用闭包</li></ol></li></ul>',15)]))}const _=a(i,[["render",o]]);export{b as __pageData,_ as default};
