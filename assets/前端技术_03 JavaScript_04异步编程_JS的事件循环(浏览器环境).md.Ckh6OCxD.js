import{_ as i,c as t,o as a,ae as n}from"./chunks/framework.CIivgcbp.js";const l="/obsidian-vitepress-docs/assets/bg2014100802_H-sWZUqDlR.Nu302pXM.png",g=JSON.parse('{"title":"JS 的事件循环 (浏览器环境)","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/04异步编程/JS的事件循环(浏览器环境).md","filePath":"前端技术/03 JavaScript/04异步编程/JS的事件循环(浏览器环境).md"}'),h={name:"前端技术/03 JavaScript/04异步编程/JS的事件循环(浏览器环境).md"};function e(p,s,k,r,o,d){return a(),t("div",null,s[0]||(s[0]=[n('<h1 id="js-的事件循环-浏览器环境" tabindex="-1">JS 的事件循环 (浏览器环境) <a class="header-anchor" href="#js-的事件循环-浏览器环境" aria-label="Permalink to &quot;JS 的事件循环 (浏览器环境)&quot;">​</a></h1><p><strong>本文主要讲诉在浏览器环境下的事件循环。</strong></p><h2 id="一、为什么-js-是单线程的" tabindex="-1">一、为什么 JS 是单线程的？ <a class="header-anchor" href="#一、为什么-js-是单线程的" aria-label="Permalink to &quot;一、为什么 JS 是单线程的？&quot;">​</a></h2><p><strong>Question</strong>：假设 JavaScript 有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>JavaScript 在最初的设计上是作为浏览器脚本语言，主要用来处理与用户的交互、网络以及操作 DOM。因此，就决定了它只能是单线程的，否则会带来很复杂的同步问题，可联想其他语言的多线程锁（lock）问题。</p><h2 id="二、执行栈与任务队列" tabindex="-1">二、执行栈与任务队列 <a class="header-anchor" href="#二、执行栈与任务队列" aria-label="Permalink to &quot;二、执行栈与任务队列&quot;">​</a></h2><p>由于 JavaScript 单线程，浏览器在进行一些耗时任务时难道一直阻塞吗？因此，为了防止主线程的阻塞，有了同步与异步任务之别。</p><ul><li><p><strong>同步任务</strong></p><ul><li>如果在一个函数返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的。</li><li>同步任务会在调用栈中按照顺序等待主线程依次执行。</li></ul></li><li><p><strong>异步任务</strong></p><ul><li>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li><li>异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（执行栈被清空），被读取到栈内等待主线程的执行。</li></ul></li><li><p><strong>执行栈</strong><br> 执行栈 <code>Execution Context Stack</code><strong>（后进先出）</strong>：当我们调用一个方法的时候，JavaScript 会生成一个与这个方法对应的执行环境，又叫执行上下文 (context)。这个执行环境中保存着该方法的私有作用域、上层作用域 (作用域链)、方法的参数，以及这个作用域中定义的变量和 this 的指向，而当一系列方法被依次调用的时候。由于 JavaScript 是单线程的，这些方法就会按顺序被排列在一个单独的地方，这个地方就是所谓执行栈。</p></li><li><p><strong>任务队列</strong><br> 任务队列 <code>Task Queue</code><strong>（先进先出）</strong>：是一个存储着 <code>异步任务</code> 的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。</p></li></ul><h2 id="三、事件循环" tabindex="-1">三、事件循环 <a class="header-anchor" href="#三、事件循环" aria-label="Permalink to &quot;三、事件循环&quot;">​</a></h2><p><code>Event Loop</code> 即事件循环，是指浏览器或 <code>Node</code> 的一种解决 <code>javaScript</code> 单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p><p><img src="'+l+`" alt=""></p><p>异步执行的运行机制：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个 &quot; 任务队列 &quot;（task queue）。只要异步任务有了运行结果，就在 &quot; 任务队列 &quot; 之中放置一个事件。</li><li>一旦 &quot; 执行栈 &quot; 中的所有同步任务执行完毕，系统就会读取 &quot; 任务队列 &quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><h2 id="四、宏任务与微任务" tabindex="-1">四、宏任务与微任务 <a class="header-anchor" href="#四、宏任务与微任务" aria-label="Permalink to &quot;四、宏任务与微任务&quot;">​</a></h2><p>在 <code>JavaScript</code>ES5 后，异步任务被分为两种，一种宏任务（<code>Task</code>），一种叫微任务（<code>Jobs</code>，ES6 规范叫法）。随之而来的是任务队列被划分为宏任务队列和微任务队列。</p><p><strong>宏任务</strong>是由宿主发起的（浏览器为 window），例如 setTimeout。而<strong>微任务</strong>是由 JavaScript 自身发起，例如 promise.then()。</p><p>在设计上，会把自身发起的任务 (微任务) 先执行完，再把宏任务交宿主去执行。因此，<strong>微任务总是先于宏任务被执行。</strong></p><p>事件循环的运行机制可以总结为：</p><ol><li>从上至下执行所有的同步代码；</li><li>执行过程中遇到的宏任务与微任务分别添加至相应队列</li><li>同步代码执行完后，执行满足条件的微任务回调</li><li>微任务队列执行后，执行满足条件的宏任务回调</li><li>循环事件环</li></ol><p><strong>常见的宏任务</strong></p><table tabindex="0"><thead><tr><th></th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>I/O</td><td>✅</td><td>✅</td></tr><tr><td>setTimeout</td><td>✅</td><td>✅</td></tr><tr><td>setInterval</td><td>✅</td><td>✅</td></tr><tr><td>setImmediate</td><td>❌</td><td>✅</td></tr><tr><td>requestAnimationFrame</td><td>✅</td><td>❌</td></tr></tbody></table><p><strong>常见的微任务</strong></p><table tabindex="0"><thead><tr><th></th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>process.nextTick</td><td>❌</td><td>✅</td></tr><tr><td>MutationObserver</td><td>✅</td><td>❌</td></tr><tr><td>Promise.then catch finally</td><td>✅</td><td>✅</td></tr></tbody></table><h2 id="五、例子" tabindex="-1">五、例子 <a class="header-anchor" href="#五、例子" aria-label="Permalink to &quot;五、例子&quot;">​</a></h2><p>题目：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myPromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> funcOne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    myPromise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Timeout!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Last line!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> funcTwo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myPromise;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Timeout!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Last line!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcOne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcTwo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>思路：</p><ol><li>执行 funcOne()。第一层 then 添加到微任务队列，&quot;Timeout!&quot; 添加到宏任务队列，<strong>打印 &quot;Last line!&quot;</strong></li><li>执行 funcTwo()。await myPromise 后代码添加到微任务队列（相当于把后面的代码放到 then 中）</li><li>执行微任务队列。把第二层 then 添加到微任务队列，await res 后代码添加到微任务队列。</li><li>执行新添加到微任务队列的微任务，<strong>打印 &quot;Promise!&quot;</strong>，<strong>打印 &quot;Promise!&quot;</strong>，&quot;Timeout!&quot; 添加到宏任务队列，<strong>打印 &quot;Last line!&quot;</strong>。</li><li>执行宏任务队列。<strong>打印 &quot;Timeout!&quot;</strong>，<strong>打印 &quot;Timeout!&quot;</strong></li></ol>`,28)]))}const c=i(h,[["render",e]]);export{g as __pageData,c as default};
