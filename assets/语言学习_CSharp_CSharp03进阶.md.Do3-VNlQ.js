import{_ as h,C as p,c as k,o as r,ae as e,G as l,j as t,w as n,a as i}from"./chunks/framework.CIivgcbp.js";const d="/obsidian-vitepress-docs/assets/CSharp_03_%E8%BF%9B%E9%98%B6-1.D0gRZat6.png",m=JSON.parse('{"title":"CSharp03 进阶","description":"","frontmatter":{},"headers":[],"relativePath":"语言学习/CSharp/CSharp03进阶.md","filePath":"语言学习/CSharp/CSharp03进阶.md"}'),E={name:"语言学习/CSharp/CSharp03进阶.md"};function o(y,s,g,c,b,u){const a=p("font");return r(),k("div",null,[s[5]||(s[5]=e(`<h1 id="csharp03-进阶" tabindex="-1">CSharp03 进阶 <a class="header-anchor" href="#csharp03-进阶" aria-label="Permalink to &quot;CSharp03 进阶&quot;">​</a></h1><h2 id="命名空间" tabindex="-1">命名空间 <a class="header-anchor" href="#命名空间" aria-label="Permalink to &quot;命名空间&quot;">​</a></h2><p>命名空间的目的是为了给类进行分类，就像我们电脑中的文件夹，所有文件都放在一个文件 夹里面肯定是不方便管理的。</p><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> namespace_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 代码声明 }</span></span></code></pre></div><ul><li><p>使用：<br> 第一种方式<br><code>namespace_name.item_name;</code><br> 第二种方式<br><code>using namespace_name;</code></p></li><li><p>命名空间可以嵌套</p></li></ul><p>C#常用命名空间 <a href="https://www.cnblogs.com/makesense/p/4500955.html" target="_blank" rel="noreferrer">C#常用命名空间 - 天琊蓝 - 博客园</a></p><h2 id="委托与事件" tabindex="-1">委托与事件 <a class="header-anchor" href="#委托与事件" aria-label="Permalink to &quot;委托与事件&quot;">​</a></h2><ul><li><p>什么是委托？<br> 如果我们要把方法当做参数来传递的话，就要用到委托。简单来说委托是一个类型，这个类型可以赋值一个<strong>方法的引用</strong>。</p></li><li><p>定义委托<br> 使用关键字 <code>delegate</code> 定义。<br> 语法：<code>delegate void IntMethodInvoker(int x);</code><br> 定义了一个委托叫做 IntMethodInvoker，这个委托可以指向什么类型的方法呢？ 这个方法要带有一个 int 类型的参数，并且方法的返回值是 void 的。</p></li><li><p>使用委托<br><code>private delegate string GetAString();</code></p></li><li><p>Action 委托和 Func 委托<br> 除了我们自己定义的委托之外，系统还给我们提供过来一个内置的委托类型，Action 和 Func<br> Action 委托引用了一个 void 返回类型的方法，T 表示方法参数，先看 Action 委托有哪些：<br><code>Action</code><br><code>Action&lt;in T&gt;</code><br><code>Action&lt;in T1,in T2&gt;</code><br><code>Action&lt;in T1,in T2 .... inT16&gt;</code><br> Func 引用了一个带有一个返回值的方法，它可以传递 0 或者多到 16 个参数类型，和一个返回类型 。<br><code>Func&lt;out TResult&gt;</code><br><code>Func&lt;in T,out TResult&gt;</code><br><code>Func&lt;int T1,inT2,,,,,,in T16,out TResult&gt;</code></p></li><li><p>多播委托<br> 前面使用的委托都只包含一个方法的调用，但是委托也可以包含多个方法，这种委托叫做多播委托。使用多播委托就可以按照顺序调用多个方法，多播委托只能得到调用的最后一个方法的结果，一般我们把多播委托的返回类型声明为 void。<br> 多播委托包含一个逐个调用的委托集合，如果通过委托调用的其中一个方法抛出异常，整个 迭代就会停止。</p></li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Action</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Method1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Method2;</span></span></code></pre></div><ul><li>匿名方法<br> 到目前为止，使用委托，都是先定义一个方法，然后把方法给委托的实例。但还有另外一种使用委托的方式，不用去定义一个方法，应该说是使用匿名方法。</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> delegate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> （int a, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><strong>Lambda 表达式</strong><br> 从 C#3.0 开始，可以使用 Lambda 表达式代替匿名方法。只要有委托参数类型的地方就可以使用 Lambda 表达式。<br><code>(...)=&gt;{...}</code></p></blockquote><ul><li>事件<br> 事件 (event) 基于委托，为委托提供了一个<strong>发布/订阅机制</strong>，我们可以说事件是一种具有特殊<br> 签名的委托。<br> 事件（Event）是类或对象向其他类或对象通知发生的事情的一种特殊签名的委托。<br> 事件使用 <code>event</code> 关键词来声明，他的返回类值是一个委托类型。<br><code>public event 委托类型 事件名;</code><br> 通常事件的命名，以名字 +Event 作为他的名称，在编码中尽量使用规范命名，增<br> 加代码可读性。</li></ul><h2 id="反射与特性" tabindex="-1">反射与特性 <a class="header-anchor" href="#反射与特性" aria-label="Permalink to &quot;反射与特性&quot;">​</a></h2><ul><li>什么是元数据？<br> 程序是用来处理数据的，文本和特性都是数据，而我们程序本身（类的定义和 BCL 中的类）这些也是数据。（BCL - Basic Class Lib 基础类库）</li></ul>`,15)),l(a,{color:"#ff0000"},{default:n(()=>s[0]||(s[0]=[i("有关程序及其类型的数据被称为元数据 (metadata)，它们保存在程序的程序集中。")])),_:1,__:[0]}),t("ul",null,[t("li",null,[s[2]||(s[2]=i("什么是反射？")),s[3]||(s[3]=t("br",null,null,-1)),s[4]||(s[4]=i(" 程序在运行时，可以查看其它程序集或其本身的元数据。")),l(a,{color:"#ff0000"},{default:n(()=>s[1]||(s[1]=[i("一个运行的程序查看本身的元数据或者其他程序集的元数据的行为叫做反射。")])),_:1,__:[1]})])]),s[6]||(s[6]=e(`<h3 id="使用-type-类反射数据" tabindex="-1">使用 Type 类反射数据 <a class="header-anchor" href="#使用-type-类反射数据" aria-label="Permalink to &quot;使用 Type 类反射数据&quot;">​</a></h3><p>预定义类型 (int long 和 string 等)，BCL 中的类型 (Console，IEnumerable 等) 和程序员自定义类型（MyClass,MyDel 等）。 每种类型都有自己的成员和特性。<br> BCL 声明了一个叫做 Type 的抽象类，它被设计用来包含类型的特性。使用这个类的对象能让我们获取程序使用的类型的信息。</p><p>由于 Type 是抽象类，因此不能利用它去实例化对象。</p><ul><li><p>关于 Type 的重要事项如下：</p><ol><li>对于程序中用到的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象。</li><li>程序中用到的每一个类型都会关联到独立的 Type 类的对象。</li><li>不管创建的类型有多少个示例，只有一个 Type 对象会关联到所有这些实例。</li></ol></li><li><p>System.Type 类部分成员</p></li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">成员</th><th style="text-align:center;">成员类型</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">Name</td><td style="text-align:center;">属性</td><td style="text-align:center;">返回类型的名字</td></tr><tr><td style="text-align:center;">Namespace</td><td style="text-align:center;">属性</td><td style="text-align:center;">返回包含类型声明的命名空间</td></tr><tr><td style="text-align:center;">Assembly</td><td style="text-align:center;">属性</td><td style="text-align:center;">返回声明类型的程序集。</td></tr><tr><td style="text-align:center;">GetFields</td><td style="text-align:center;">方法</td><td style="text-align:center;">返回类型的字段列表</td></tr><tr><td style="text-align:center;">GetProperties</td><td style="text-align:center;">方法</td><td style="text-align:center;">返回类型的属性列表</td></tr><tr><td style="text-align:center;">GetMethods</td><td style="text-align:center;">方法</td><td style="text-align:center;">返回类型的方法列表</td></tr></tbody></table><blockquote><p>Field 类名 <code>FieldInfo</code><br> Properties 类名 <code>PropertyInfo</code></p></blockquote><ul><li>获取 Type 对象有两种方式 <ol><li>通过类的实例来获取 Type 对象<br><code>Type t = myInstance.GetType();</code><br> 在 object 类有一个 GetType 的方法，返回 Type 对象，因为所有类都是从 object 继承的，所以我们可以在任何类型上使用 <code>GetType()</code> 来获取它的 Type 对象</li><li>直接通过 typeof 运算符和类名获取 Type 对象获取里面的属性<br><code>Type t = typeof(ClassName)</code></li></ol></li></ul><h3 id="使用-assembly-类加载程序集" tabindex="-1">使用 Assembly 类加载程序集 <a class="header-anchor" href="#使用-assembly-类加载程序集" aria-label="Permalink to &quot;使用 Assembly 类加载程序集&quot;">​</a></h3><p>Assembly 类在 System.Reflection 命名空间中定义，它允许访问给定程序集的元数据，它也包含了可以加载和执行程序集。</p><ul><li>加载程序集</li></ul><ol><li><p>根据程序集的名字加载程序集，它会在本地目录和全局程序集缓存目录查找符合名字的程序集。<br><code>Assembly assembly1 = Assembly.Load(&quot;SomeAssembly&quot;);</code></p></li><li><p>这里的参数是程序集的完整路径名，它不会在其他位置搜索。<br><code>Assembly assembly2 = Assembly.LoadFrom(@&quot;c:\\xx\\xx\\xx\\SomeAssembly.dll&quot;)</code></p></li></ol><ul><li>Assembly 对象的使用</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//1. 获取程序集的全名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> assembly1.FullName;\`  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//2. 遍历程序集中定义的类型 </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> theAssembly.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">foreach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> definedType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> types){  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//3. 遍历程序集中定义的所有特性  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">definedAttributes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Attribute.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetCustomAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someAssembly);</span></span></code></pre></div><ul><li>什么是特性？<br> 特性 (attribute) 是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类。<br> 将应用了特性的程序结构叫做<strong>目标</strong>，设计用来获取和使用元数据的程序（对象浏览器）叫做特性的<strong>消费者</strong>。<br> .NET 预定了很多特性，我们也可以声明自定义特性。</li></ul><h3 id="创建和使用特性" tabindex="-1">创建和使用特性 <a class="header-anchor" href="#创建和使用特性" aria-label="Permalink to &quot;创建和使用特性&quot;">​</a></h3><p><img src="`+d+`" alt=""></p><p>我们在源代码中将特性应用于程序结构；<br> 编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中；<br> 消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。</p><p>关于特性的命名规范，特性名使用 Pascal 命名法（首字母大写），并且以 Attribute 后缀结尾，当为目标应用特性时，我们可以不使用后缀。例如对于 SerializableAttribute 和<br> MyAttributeAttribute 这两个特性，我们把他们应用到结构是可以使用 Serializable 和<br> MyAttribute。</p><ul><li>如何应用特性<br> 特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现。<br><strong>我们通过在结构前放置特性片段来应用特性；</strong><br> 特性片段被方括号包围，特性片段包括特性名和特性的参数列表；<br> 应用了特性的结构成为特性装饰（类似与装饰器）。</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//特性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p>Obsolete 特性<br> 一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半 部分，程序员经常需要编写类似功能的新方法替换老方法。处于多种原因，你可能不再使用 哪些调用过时的旧方法的老代码。而只想用新编写的代码调用新方法。旧的方法不能删除， 因为有些旧代码也使用的旧方法，那么如何提示程序员使用新代码呢？可以使用 Obsolete 特 性将程序结构标注为过期的，并且在代码编译时，显示有用的警告信息。</p></li><li><p>Conditional 特性<br> Conditional 特性允许我们包括或取消特定方法的所有调用。为方法声明应用 Conditional 特性并把编译符作为参数来使用。<br> 定义方法的 CIL 代码本身总是会包含在程序集中，只是调用代码会被插入或忽略。</p></li><li><p>调用者信息特性<br> 调用者信息特性可以访问文件路径，代码行数，调用成员的名称等源代码信息。 这个三个特性名称为 <code>CallerFilePath</code>，<code>CallerLineNumber</code> 和 <code>CallerMemberName</code> 这些特性只能用于方法中的可选参数。</p></li><li><p>DebuggerStepThrough 特性<br> 我们在单步调试代码的时候，常常希望调试器不要进入某些方法。我们只想执行该方法，然<br> 后继续调试下一行。DebuggerStepThrough 特性告诉调试器在执行目标代码时不要进入该方法调试。有些方法小并且毫无疑问是正确的，在调试时对其反复单步调试只能徒增烦恼。要小心使用该特性，不要排除了可能出现 bug 的代码。</p></li><li><p>其他预定义特性</p></li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">意义</th></tr></thead><tbody><tr><td style="text-align:left;">CLSCompliant</td><td style="text-align:left;">声明可公开的成员应该被编译器检查是否符合 CLS。兼容的程序集可以被任何.NET 兼容的语言使用</td></tr><tr><td style="text-align:left;">Serializable</td><td style="text-align:left;">声明结构可以被序列化</td></tr><tr><td style="text-align:left;">NonSerialized</td><td style="text-align:left;">声明结构不可以被序列化</td></tr><tr><td style="text-align:left;">DLLImport</td><td style="text-align:left;">声明是非托管代码实现的</td></tr><tr><td style="text-align:left;">WebMethod</td><td style="text-align:left;">声明方法应该被作为 XML Web 服务的一部分暴露</td></tr><tr><td style="text-align:left;">AttributeUsage</td><td style="text-align:left;">声明特性能应用到什么类型的程序结构。将这个特性应用到特性声明上</td></tr></tbody></table><ul><li>多个特性<br> 我们可以为单个结构应用多个特性。有下面两种添加方式：</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//1. 独立的特性片段相互叠在一起</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Simple class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Version 3.57&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//2. 单个特性片段，特性之间使用逗号间隔</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Simple class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Version 3.57&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span></code></pre></div><ul><li>特性目标<br> 我们可以将特性应用到字段和属性等程序结构上。我们还可以显示的标注特性，从而将它应<br> 用到特殊的目标结构。要使用显示目标，在特性片段的开始处放置目标类型，后面跟冒号。</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This value ...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Version2.3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Print....&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Version 3.6&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReturnSettings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.}</span></span></code></pre></div><p>c#定义了 10 个标准的特性目标。<br><code>event</code> <code>field</code> <code>method</code> <code>param</code> <code>property</code> <code>return</code> <code>type</code> <code>typevar</code> <code>assembly</code><br><code>module</code><br> 其中 type 覆盖了类，结构，委托，枚举和接口。<br> typevar 指定使用泛型结构的类型参数。</p><ul><li>全局特性<br> 我们可以通过使用 assembly 和 module 目标名称来使用显式目标说明符把特性设置在程序集或 模块级别。<br> 程序集级别的特性必须放置在任何命名空间之外，并且通常放置在 AssemblyInfo.cs 文件中 AssemblyInfo.cs 文件通常包含有关公司，产品以及版权信息的元数据。</li></ul><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ClassLibrary1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyDescription</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyConfiguration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyCompany</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyProduct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ClassLibrary1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyCopyright</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Copyright © 2015&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyTrademark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">assembly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssemblyCulture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span></code></pre></div><ul><li>自定义特性<br> 应用特性的语法和之前见过的其他语法很不相同。你可能会觉得特性跟结构是完全不同的类型，其实不是，特性只是某个特殊结构的类。所有的特性类都派生自 System.Attribute。</li></ul><p>声明一个特性类和声明其他类一样。有下面的注意事项：</p><ol><li>声明一个派生自 System.Attribute 的类</li><li>给它起一个以后缀 Attribute 结尾的名字</li><li>安全起见，一般我们声明一个 sealed 的特性类</li></ol><div class="language-c# vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyAttributeAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">System</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>特性类的公共成员可以是字段属性或构造函数。<br> 特性类的构造函数的声明跟普通类一样，如果不写系统会提供一个默认的，可以进行重载。<br> 构造函数的实参，必须是在编译期间能确定值的常量表达式，如果调用的是无参的构造函数，那么后面的 () 可以不写。</p><ul><li>限定特性的使用（<strong>自定义特性的特性</strong>）<br> 有一个很重要的预定义特性可以用来应用到自定义特性上，那就是 AttributeUsage 特性，我们可以使用它来限制特性使用在某个目标类型上。<br><code>[AttributeUsage(AttributeTarget.Method)]</code></li></ul><p>自定义特性一般遵守的规范<br> 1. 特性类应该表示目标结构的一些状态<br> 2. 如果特性需要某些字段，可以通过包含具有位置参数的构造函数来收集数据，可选字段可以<br> 3. 采用命名参数按需初始化<br> 4. 除了属性之外，不要实现公共方法和其他函数成员<br> 5. 为了更安全，把特性类声明为 sealed<br> 6. 在特性声明中使用 AttributeUsage 来指定特性目标组</p><h2 id="线程与进程" tabindex="-1">线程与进程 <a class="header-anchor" href="#线程与进程" aria-label="Permalink to &quot;线程与进程&quot;">​</a></h2><ul><li><p>线程<br> 对于所有需要等待的操作，例如移动文件，数据库和网络访问都需要一定的时间，此时就可以启动一个新的线程，同时完成其他任务。一个进程的多个线程可以同时运行在单核 CPU 上或多核 CPU 的不同内核上。<br> 线程是程序中独立的指令流。在 VS 编辑器中输入代码的时候，系统会分析代码，用下划线标注遗漏的分号和其他语法错误，这就是用一个后台线程完成。Word 文档需要一个线程等待用户输入，另一个线程进行后台搜索，第三个线程将写入的数据存储在临时文件中。运行在服务器上的应用程序中等待客户请求的线程成为侦听器线程。</p></li><li><p>进程<br> 进程包含资源，如 Window 句柄，文件系统句柄或其他内核对象。每个进程都分配的虚拟内存。一个进程至少包含一个线程。<br> 一个应用程序启动，会启动一个进程（应用程序运行的载体），然后进程启动多个线程。</p></li></ul>`,38))])}const C=h(E,[["render",o]]);export{m as __pageData,C as default};
