import{_ as i,c as s,o as e,ae as t}from"./chunks/framework.CIivgcbp.js";const k=JSON.parse('{"title":"async/await","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/04异步编程/async-await.md","filePath":"前端技术/03 JavaScript/04异步编程/async-await.md"}'),n={name:"前端技术/03 JavaScript/04异步编程/async-await.md"};function c(o,a,d,l,p,r){return e(),s("div",null,a[0]||(a[0]=[t(`<h1 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h1><h2 id="一、async函数" tabindex="-1">一、async函数 <a class="header-anchor" href="#一、async函数" aria-label="Permalink to &quot;一、async函数&quot;">​</a></h2><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。是对 Generator 函数的改进。</p><p>个人理解：</p><p>它是Generator与Promise的结合体，利用Generator进行异步容器式编程，利用Promise实现异步的流程管理，在此基础上再实现了Generator函数的自动执行。</p><p>特点：</p><ol><li><p>内置执行器</p><p>类似co模块，不过更加便捷，可以像普通函数一样直接使用。</p><p><code>asyncReadFile()</code></p></li><li><p>更好的语义</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p></li><li><p>更广的适用性</p><p>co模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li><li><p>返回值是 Promise</p></li></ol><h2 id="二、await命令" tabindex="-1">二、await命令 <a class="header-anchor" href="#二、await命令" aria-label="Permalink to &quot;二、await命令&quot;">​</a></h2><p><code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。</p><p>如果不是 Promise 对象，就先封装成 resolved值为该结果 的 Promise 对象，再返回该结果。换句话来说就是直接返回对应的值。</p><h2 id="三、基本用法" tabindex="-1">三、基本用法 <a class="header-anchor" href="#三、基本用法" aria-label="Permalink to &quot;三、基本用法&quot;">​</a></h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">async funtion </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asyncFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//把fn1()的返回值当作fn2的参数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="错误处理" tabindex="-1">错误处理： <a class="header-anchor" href="#错误处理" aria-label="Permalink to &quot;错误处理：&quot;">​</a></h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。因此<code>async</code>函数后可以跟catch（）方法进行错误捕捉处理。</p><h4 id="使用注意点" tabindex="-1">使用注意点： <a class="header-anchor" href="#使用注意点" aria-label="Permalink to &quot;使用注意点：&quot;">​</a></h4><ol><li><code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</li><li>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li><li><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</li><li><code>async</code>函数可以保留运行堆栈。</li></ol>`,17)]))}const y=i(n,[["render",c]]);export{k as __pageData,y as default};
