import{_ as e}from"./chunks/11 BOM-1.C2CcK4qC.js";import{_ as o,c as a,o as d,ae as i}from"./chunks/framework.CIivgcbp.js";const k=JSON.parse('{"title":"BOM 对象","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/06浏览器环境/BOM/BOM对象.md","filePath":"前端技术/03 JavaScript/06浏览器环境/BOM/BOM对象.md"}'),r={name:"前端技术/03 JavaScript/06浏览器环境/BOM/BOM对象.md"};function s(l,t,n,c,p,h){return d(),a("div",null,t[0]||(t[0]=[i('<h1 id="bom-对象" tabindex="-1">BOM 对象 <a class="header-anchor" href="#bom-对象" aria-label="Permalink to &quot;BOM 对象&quot;">​</a></h1><p>浏览器对象模型（BOM，Browser Object Model）</p><h2 id="window-对象" tabindex="-1">window 对象 <a class="header-anchor" href="#window-对象" aria-label="Permalink to &quot;window 对象&quot;">​</a></h2><p>BOM 的核心是 window 对象，表示浏览器的实例。<br> window 对象在浏览器中有两重身份，一个是 ECMAScript 中的 <strong>Global 对象</strong>，另一个就是浏览器窗口的 JavaScript 接口。==这意味着网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的全局方法。==</p><p>因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。</p><h3 id="窗口" tabindex="-1">窗口 <a class="header-anchor" href="#窗口" aria-label="Permalink to &quot;窗口&quot;">​</a></h3><ul><li><p>窗口关系<br><strong>top 对象</strong>始终指向最上层（最外层）窗口，即浏览器窗口本身。<br><strong>parent 对象</strong>则始终指向当前窗口的父窗口。<br><strong>self 对象</strong>，它是终极 window 属性，始终会指向 window。</p></li><li><p>窗口位置与像素比<br><strong>screenLeft</strong> 和 <strong>screenTop</strong> 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。<br> 可以使用 <code>moveTo()</code> 和 <code>moveBy()</code> 方法移动窗口。这两个方法都接收两个参数，其中 moveTo() 接收要移动到的新位置的绝对坐标 x 和 y；而 moveBy() 则接收相对当前位置在两个方向上移动的像素数。</p></li></ul><div class="info custom-block github-alert"><p class="custom-block-title">+ 像素比</p><p>CSS 像素是 Web 开发中使用的统一像素单位。这个单位的背后其实是一个角度：0.0213°。如果屏 幕距离人眼是一臂长，则以这个角度计算的 CSS 像素大小约为 1/96 英寸。</p></div><p>物理像素与 CSS 像素之间的转换比率由 <code>window.devicePixelRatio</code> 属性提供。<br> window.devicePixelRatio 实际上与每英寸像素数（DPI，dots per inch）是对应的。DPI 表示单位像素密度，而 window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。</p><ul><li>窗口大小<br><code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code> 和 <code>outerHeight</code>。<br> outerWidth 和 outerHeight 返回浏览器窗口自身的大小。<br> innerWidth 和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。<br><img src="'+e+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/11 BOM-1.png"></li></ul><p>可以使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法调整窗口大小。这两个方法都接收两个参数，<code>resizeTo()</code> 接收新的宽度和高度值，而 resizeBy() 接收宽度和高度各要缩放多少。</p><h3 id="视口" tabindex="-1">视口 <a class="header-anchor" href="#视口" aria-label="Permalink to &quot;视口&quot;">​</a></h3><p>浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。<br> 度量文档相对于视口滚动距离的属性有两对，返回相等的值：<br><code>window.pageXoffset/window.scrollX</code><br><code>window.pageYoffset/window.scrollY</code></p><p>可以使用 <code>scroll()</code>、<code>scrollTo()</code> 和 <code>scrollBy()</code> 方法滚动页面。<br> 这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。<br> 这几个方法也都接收一个 ScrollToOptions ，除了提供偏移值，还可以通过 behavior 属性告诉浏览器是否平滑滚动。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 平滑滚动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	left: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	top: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	behavior: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;smooth&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="新窗口" tabindex="-1">新窗口 <a class="header-anchor" href="#新窗口" aria-label="Permalink to &quot;新窗口&quot;">​</a></h3><p><code>window.open()</code> 方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。</p><blockquote><p>[!example]+ window.open</p><p><code>window.open(url, target, features)</code> 方法用于打开一个新的浏览器窗口或者在指定的窗口/标签页中加载一个 URL。</p><ul><li>url: 要加载的 URL 字符串。可以是绝对或相对路径。如果为空字符串，则会加载一个关于空白页（通常为 &quot;about:blank&quot;）。</li><li>target: 指定目标窗口或标签页的名称。可以是以下预定义名称之一： <ul><li><code>_self</code>: 在当前窗口加载文档（默认值）。</li><li><code>_blank</code>: 在新窗口或标签页中打开文档。</li><li><code>_parent</code>: 在父框架中加载文档；如果没有父框架，则行为类似 <code>_self</code>。</li><li><code>_top</code>: 在整个窗口中加载文档，取消任何框架；如果没有框架，则行为类似 <code>_self</code>。</li><li>自定义窗口名称：在一个具有指定名称的已有窗口中打开文档；如果不存在这样的窗口，则创建一个新的窗口并赋予该名称。</li></ul></li><li>features（可选）: 一个逗号分隔的字符串，定义了新窗口的特性，如位置、大小和是否显示工具栏等。</li></ul><p>返回值: 返回对新窗口的引用，允许脚本与之交互。如果调用失败（比如弹出窗口被阻止），则返回 <code>null</code>。</p></blockquote><ul><li>特性表</li></ul><table tabindex="0"><thead><tr><th>设置</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>fullscreen</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示新窗口是否最大化。仅限 IE 支持</td></tr><tr><td>height</td><td>数值</td><td>新窗口高度。这个值不能小于 100</td></tr><tr><td>left</td><td>数值</td><td>新窗口的 x 轴坐标。这个值不能是负值</td></tr><tr><td>location</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为 &quot;no&quot; 时，地址栏可能隐藏或禁用（取决于浏览器）</td></tr><tr><td>Menubar</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否显示菜单栏。默认为 &quot;no&quot;</td></tr><tr><td>resizable</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否可以拖动改变新窗口大小。默认为 &quot;no&quot;</td></tr><tr><td>scrollbars</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否可以在内容过长时滚动。默认为 &quot;no&quot;</td></tr><tr><td>status</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否显示状态栏。不同浏览器的默认值也不一样</td></tr><tr><td>toolbar</td><td>&quot;yes&quot; 或 &quot;no&quot;</td><td>表示是否显示工具栏。默认为 &quot;no&quot;</td></tr><tr><td>top</td><td>数值</td><td>新窗口的 y 轴坐标。这个值不能是负值</td></tr><tr><td>width</td><td>数值</td><td>新窗口的宽度。这个值不能小于 100</td></tr></tbody></table><p>新创建窗口的 window 对象有一个属性 <strong>opener</strong>，指向打开它的窗口。<br> 可以使用 <code>close()</code> 方法像这样关闭新打开的窗口。（只能用于 <code>window.open()</code> 创建的）</p><p>==所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。==<br> 在浏览器扩展或其他程序屏蔽弹窗时，window.open() 通常会抛出错误。因此要准确检测弹窗是否被屏蔽，除了检测 window.open() 的返回值，还要把它用 try/catch 包装起来。</p><h3 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-label="Permalink to &quot;定时器&quot;">​</a></h3><p><code>setTimeout()</code> 用于指定在一定时间后执行某些代码。</p><blockquote><p>[!example]+ setTimeout</p><p><code>setTimeout(function, delay, arg1, arg2, ...)</code> 方法用于在指定的延迟（以毫秒为单位）后执行一次给定的函数或代码段。</p><ul><li>function: 要执行的函数。也可以传递一个字符串（不推荐，因为这会导致使用 <code>eval</code>），但通常应该使用函数引用或匿名函数。</li><li>delay: 执行前等待的时间，以毫秒为单位。如果设置为 0 或更小，则函数尽可能快地执行（取决于事件循环）。</li><li>arg1, arg2, ...（可选）: 传递给执行函数的实际参数列表。</li></ul><p>返回值: 一个定时器 ID，可用于通过 <code>clearTimeout()</code> 取消定时器。</p><p>注意点：</p><ul><li>delay 时间是放入任务队列的时间，因此实际的延迟时间可能比指定的长，取决于系统任务和其他计时器的负载。</li><li>如果需要取消定时器，必须保存返回的定时器 ID，并在适当时候调用 <code>clearTimeout(id)</code>。</li><li>可用于实现延迟执行逻辑、轮询服务器更新等场景。</li></ul></blockquote><p><code>setInterval()</code> 用于指定每隔一段时间执行某些代码</p><blockquote><p>[!example]+ setInterval</p><p><code>setInterval(function, delay, arg1, arg2, ...)</code> 方法用于每隔指定的延迟（以毫秒为单位）重复执行给定的函数或代码段，直到被手动停止。</p><ul><li>function: 要执行的函数。也可以传递一个字符串（不推荐），但通常应使用函数引用或匿名函数。</li><li>delay: 执行间隔的时间，以毫秒为单位。</li><li>arg1, arg2, ...（可选）: 传递给执行函数的实际参数列表。</li></ul><p>返回值: 一个定时器 ID，可用于通过 <code>clearInterval()</code> 取消定时器。</p><p>注意点：</p><ul><li>delay 时间是放入任务队列的时间，因此实际的延迟时间可能比指定的长，取决于系统任务和其他计时器的负载。</li><li>如果需要停止定时器，必须保存返回的定时器 ID，并在适当时候调用 <code>clearInterval(id)</code>。</li><li>由于累积效应，定时器的实际执行频率可能会低于预期，尤其是在处理复杂操作或大量数据时。</li><li>常用于周期性任务，例如动画、定期检查服务器状态等。</li></ul></blockquote><h3 id="对话框" tabindex="-1">对话框 <a class="header-anchor" href="#对话框" aria-label="Permalink to &quot;对话框&quot;">​</a></h3><p>使用 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法，可以让浏览器调用系统对话框向用户显示消息。<br> 这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。</p><p>JavaScript 还可以显示另外两种对话框：<br><code>find()</code> ：显示查找对话框<br><code>print()</code>：显示打印对话框<br> 这两种对话框都是异步显示的，即控制权会立即返回给脚本。</p><h2 id="location-对象" tabindex="-1">location 对象 <a class="header-anchor" href="#location-对象" aria-label="Permalink to &quot;location 对象&quot;">​</a></h2><p>location 提供了当前窗口中加载文档的信息，以及通常的导航功能。<br> 它既是 window 的属性， 也是 document 的属性。也就是说，window.location 和 document.location 指向同一个对象。</p><p>假设浏览器当前加载的 URL 是 <code>http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=</code><br><code>javascript#contents</code>，location 对象的内容如下表所示：</p><table tabindex="0"><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>location.hash</td><td><code>#contents</code></td><td>URL 散列值（井号后跟零或多个字符），如果没有则为空字符串</td></tr><tr><td>location.host</td><td><code>www.wrox.com:80</code></td><td>服务器名及端口号</td></tr><tr><td>location.hostname</td><td><code>www.wrox.com</code></td><td>服务器名</td></tr><tr><td>location.href</td><td><code>http://www.wrox.com:80/WileyCDA/?q=javascript#contents</code></td><td>当前加载页面的完整 URL。location 的 toString() 方法返回这个值</td></tr><tr><td>location.pathname</td><td><code>/WileyCDA/</code></td><td>URL 中的路径和（或）文件名</td></tr><tr><td>location.port</td><td><code>80</code></td><td>请求的端口。如果 URL 中没有端口，则返回空字符串</td></tr><tr><td>location.protocol</td><td><code>http:</code></td><td>页面使用的协议。通常是 &quot;http:&quot; 或 &quot;https:&quot;</td></tr><tr><td>location.search</td><td><code>?q=javascript</code></td><td>URL 的查询字符串。这个字符串以问号开头</td></tr><tr><td>location.username</td><td><code>foouser</code></td><td>域名前指定的用户名</td></tr><tr><td>location.password</td><td><code>barpassword</code></td><td>域名前指定的密码</td></tr><tr><td>location.origin</td><td><code>http://www.wrox.com</code></td><td>URL 的源地址。只读</td></tr></tbody></table><h3 id="查询字符串" tabindex="-1">查询字符串 <a class="header-anchor" href="#查询字符串" aria-label="Permalink to &quot;查询字符串&quot;">​</a></h3><p>URLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串。给 URLSearchParams 构造函数传入一个查询字符串，就可以创建一个实例。<br> 这个实例上暴露了 get()、set() 和 delete() 等方法，可以对查询字符串执行相应操作。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> qs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;?q=javascript&amp;num=10&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> searchParams </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URLSearchParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(qs);</span></span></code></pre></div><h3 id="操作地址" tabindex="-1">操作地址 <a class="header-anchor" href="#操作地址" aria-label="Permalink to &quot;操作地址&quot;">​</a></h3><p>可以通过修改 location 对象修改浏览器的地址。最常见的是使用 <code>assign()</code> 方法并传入一个 URL 。<br><code>location.assign(&quot;http://www.wrox.com&quot;);</code><br> 如果给 location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign() 方法。<br> 修改 URL 之后，浏览器历史记录中就会增加相应的记录。</p><p>如果不希望增加历史记录，可以使用 <code>replace()</code> 方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace() 之后，用户不能回到前一页。</p><p><code>reload()</code> 能重新加载当前显示的页面。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重新加载，可能是从缓存加载</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重新加载，从服务器加载</span></span></code></pre></div><h2 id="navigator-对象" tabindex="-1">navigator 对象 <a class="header-anchor" href="#navigator-对象" aria-label="Permalink to &quot;navigator 对象&quot;">​</a></h2><p>==navigator 对象的属性通常用于确定浏览器的类型。== （英文原意是“导航者”）<br> navigator 对象实现了 NavigatorID 、NavigatorLanguage 、NavigatorOnLine 、NavigatorContentUtils 、NavigatorStorage 、NavigatorStorageUtils 、NavigatorConcurrentHardware、NavigatorPlugins 和 NavigatorUserMedia 接口定义的属性和方法。</p><table tabindex="0"><thead><tr><th>属性/方法</th><th>说明</th></tr></thead><tbody><tr><td>activeVrDisplays</td><td>返回数组，包含 ispresenting 属性为 true 的 VRDisplay 实例</td></tr><tr><td>appCodeName</td><td>即使在非 Mozilla 浏览器中也会返回 &quot;Mozilla&quot;</td></tr><tr><td>appName</td><td>浏览器全名</td></tr><tr><td>appVersion</td><td>浏览器版本。通常与实际的浏览器版本不一致</td></tr><tr><td>battery</td><td>返回暴露 Battery Status API 的 BatteryManager 对象</td></tr><tr><td>buildId</td><td>浏览器的构建编号</td></tr><tr><td>connection</td><td>返回暴露 Network Information API 的 NetworkInformation 对象</td></tr><tr><td>cookieEnabled</td><td>返回布尔值，表示是否启用了 cookie</td></tr><tr><td>credentials</td><td>返回暴露 Credentials Management API 的 CredentialsContainer 对象</td></tr><tr><td>deviceMemory</td><td>返回单位为 GB 的设备内存容量</td></tr><tr><td>doNotTrack</td><td>返回用户的“不跟踪”（do-not-track）设置</td></tr><tr><td>geolocation</td><td>返回暴露 Geolocation API 的 Geolocation 对象</td></tr><tr><td>getVRDisplays()</td><td>返回数组，包含可用的每个 VRDisplay 实例</td></tr><tr><td>getUserMedia()</td><td>返回与可用媒体设备硬件关联的流</td></tr><tr><td>hardwareConcurrency</td><td>返回设备的处理器核心数量</td></tr><tr><td>javaEnabled</td><td>返回布尔值，表示浏览器是否启用了 Java</td></tr><tr><td>language</td><td>返回浏览器的主语言</td></tr><tr><td>languages</td><td>返回浏览器偏好的语言数组</td></tr><tr><td>locks</td><td>返回暴露 Web Locks API 的 LockManager 对象</td></tr><tr><td>mediaCapabilities</td><td>返回暴露 Media Capabilities API 的 MediaCapabilities 对象</td></tr><tr><td>mediaDevices</td><td>返回可用的媒体设备</td></tr><tr><td>maxTouchPoints</td><td>返回设备触摸屏支持的最大触点数</td></tr><tr><td>mimeTypes</td><td>返回浏览器中注册的 MIME 类型数组</td></tr><tr><td>onLine</td><td>返回布尔值，表示浏览器是否联网</td></tr><tr><td>oscpu</td><td>返回浏览器运行设备的操作系统和（或）CPU</td></tr><tr><td>permissions</td><td>返回暴露 Permissions API 的 Permissions 对象</td></tr><tr><td>platform</td><td>返回浏览器运行的系统平台</td></tr><tr><td>plugins</td><td>返回浏览器安装的插件数组。在 IE 中，这个数组包含页面中所有 <code>&lt;embed&gt;</code> 元素</td></tr><tr><td>product</td><td>返回产品名称（通常是 &quot;Gecko&quot;）</td></tr><tr><td>productSub</td><td>返回产品的额外信息（通常是 Gecko 的版本）</td></tr><tr><td>registerProtocolHandler()</td><td>将一个网站注册为特定协议的处理程序</td></tr><tr><td>requestMediaKeySystemAccess()</td><td>返回一个期约，解决为 MediaKeySystemAccess 对象</td></tr><tr><td>sendBeacon()</td><td>异步传输一些小数据</td></tr><tr><td>serviceWorker</td><td>返回用来与 ServiceWorker 实例交互的 ServiceWorkerContainer</td></tr><tr><td>share()</td><td>返回当前平台的原生共享机制</td></tr><tr><td>storage</td><td>返回暴露 Storage API 的 StorageManager 对象</td></tr><tr><td>userAgent</td><td>返回浏览器的用户代理字符串</td></tr><tr><td>vendor</td><td>返回浏览器的厂商名称</td></tr><tr><td>vendorSub</td><td>返回浏览器厂商的更多信息</td></tr><tr><td>vibrate()</td><td>触发设备振动</td></tr><tr><td>webdriver</td><td>返回浏览器当前是否被自动化程序控制</td></tr></tbody></table><h3 id="检测插件" tabindex="-1">检测插件 <a class="header-anchor" href="#检测插件" aria-label="Permalink to &quot;检测插件&quot;">​</a></h3><p>检测浏览器是否安装了某个插件是开发中常见的需求，可以通过 plugins 数组来确定。这个数组中的每一项都包含如下属性。</p><ul><li>name：插件名称。</li><li>description：插件介绍。</li><li>filename：插件的文件名。</li><li>length：由当前插件处理的 MIME 类型数量。</li></ul><p><code>hasPlugin()</code> 方法用于检测插件。</p><h3 id="注册处理程序" tabindex="-1">注册处理程序 <a class="header-anchor" href="#注册处理程序" aria-label="Permalink to &quot;注册处理程序&quot;">​</a></h3><p>现代浏览器支持 navigator 上的（在 HTML5 中定义的）<code>registerProtocolHandler()</code> 方法，可以把一个网站注册为处理某种特定类型信息应用程序。<br> 必须传入 3 个参数：要处理的协议（如 &quot;mailto&quot; 或 &quot;ftp&quot;）、处理该协议的 URL，以及应用名称。</p><h2 id="screen-对象" tabindex="-1">screen 对象 <a class="header-anchor" href="#screen-对象" aria-label="Permalink to &quot;screen 对象&quot;">​</a></h2><p>screen 对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息。</p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>availHeight</td><td>屏幕像素高度减去系统组件高度（只读）</td></tr><tr><td>availLeft</td><td>没有被系统组件占用的屏幕的最左侧像素（只读）</td></tr><tr><td>availTop</td><td>没有被系统组件占用的屏幕的最顶端像素（只读）</td></tr><tr><td>availWidth</td><td>屏幕像素宽度减去系统组件宽度（只读）</td></tr><tr><td>colorDepth</td><td>表示屏幕颜色的位数；多数系统是 32（只读）</td></tr><tr><td>height</td><td>屏幕像素高度</td></tr><tr><td>left</td><td>当前屏幕左边的像素距离</td></tr><tr><td>pixelDepth</td><td>屏幕的位深（只读）</td></tr><tr><td>top</td><td>当前屏幕顶端的像素距离</td></tr><tr><td>width</td><td>屏幕像素宽度</td></tr><tr><td>orientation</td><td>返回 Screen Orientation API 中屏幕的朝向</td></tr></tbody></table><h2 id="history-对象" tabindex="-1">history 对象 <a class="header-anchor" href="#history-对象" aria-label="Permalink to &quot;history 对象&quot;">​</a></h2><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。<br> 出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。</p><h3 id="导航" tabindex="-1">导航 <a class="header-anchor" href="#导航" aria-label="Permalink to &quot;导航&quot;">​</a></h3><p>go() 方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。</p><blockquote><p>[!example]+ history.go</p><p><code>history.go(delta)</code> 方法允许你加载历史列表中的某个具体页面。通过提供一个相对于当前页面位置的数值参数，可以向前或向后移动指定的步数。</p><ul><li>delta: 一个整数，表示相对于当前页面在历史记录中的位置要移动的步数。正值表示前进，负值表示后退。例如，<code>1</code> 表示前进一页，<code>-2</code> 表示后退两页。如果 delta 超出历史记录范围，则不会发生任何事情。</li></ul><p>返回值: 该方法不返回任何值。</p><p>注意点：</p><ul><li>使用 <code>history.go()</code> 可以实现浏览器历史记录的精确导航，无需用户手动点击“前进”或“后退”按钮。</li><li>如果提供的步数超出了可导航的历史记录范围（比如向前跳转超过了历史记录的数量），则不会有任何效果，也不会抛出错误。</li><li>对于简单的前进和后退操作，也可以使用 <code>history.back()</code> 和 <code>history.forward()</code> 方法，它们分别对应于 <code>history.go(-1)</code> 和 <code>history.go(1)</code>。</li><li>在单页面应用 (SPA) 中，由于路由通常不会创建新的历史记录条目，因此 <code>history.go()</code> 的行为可能与预期不同，需要结合前端路由库的功能来正确实现导航逻辑。</li></ul></blockquote><p>history 对象还有一个 <strong>length</strong> 属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。对于</p><h3 id="历史状态管理" tabindex="-1">历史状态管理 <a class="header-anchor" href="#历史状态管理" aria-label="Permalink to &quot;历史状态管理&quot;">​</a></h3><p><strong>hashchange 事件</strong> 会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。</p><p>而状态管理 API 则可以让开发者改变浏览器 URL 而不会加载新页面。为此，可以使用 <code>history.pushState()</code> 方法。</p><blockquote><p>[!example]+ history.pushState</p><p><code>history.pushState(state, title[, url])</code> 方法用于在浏览器的历史记录栈中添加一条新的记录，而不会导致页面刷新。这使得你可以更新 URL 并允许用户使用“后退”和“前进”按钮导航这些状态。</p><ul><li>state: 一个与新历史记录条目关联的状态对象。这个对象是一个可以序列化的值，通常用来存储关于新历史记录条目的信息。当用户导航到该状态时，可以通过 <code>popstate</code> 事件访问此对象。</li><li>title: 新页面的标题。尽管大多数浏览器目前忽略这个参数，但未来可能会使用它。推荐传递一个空字符串或简短的描述性文本。</li><li>url（可选）: 新历史记录条目的 URL。它可以是绝对路径或相对路径。如果省略，则使用当前 URL。注意，这个 URL 必须与当前页面同源。</li></ul><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>使用 <code>pushState</code> 不会导致页面重载，但它会改变浏览器地址栏中的 URL。</li><li>当用户导航到一个新的状态（例如通过点击后退按钮），将触发 <code>popstate</code> 事件，并且可以在事件处理函数中访问之前通过 <code>pushState</code> 设置的状态对象。</li><li>可以结合前端路由机制使用，以实现无需重新加载页面即可更改 URL 和页面内容的应用程序。</li><li>如果用户导航离开你的站点然后返回，浏览器并不会自动恢复你通过 <code>pushState</code> 创建的状态；你需要自己管理这种场景下的状态恢复逻辑。</li><li>为了确保良好的用户体验，建议仅在确实需要修改历史记录栈时使用 <code>pushState</code>，并且应该提供一种方式让用户理解他们正在浏览的不同状态之间的差异。</li></ul></blockquote><p>可以通过 <strong>history.state</strong> 获取当前的状态对象，也可以使用 <code>replaceState()</code> 并传入与 <code>pushState()</code> 同样的前两个参数来更新状态。</p><h2 id="客户端检测" tabindex="-1">客户端检测 <a class="header-anchor" href="#客户端检测" aria-label="Permalink to &quot;客户端检测&quot;">​</a></h2><h3 id="能力检测" tabindex="-1">能力检测 <a class="header-anchor" href="#能力检测" aria-label="Permalink to &quot;能力检测&quot;">​</a></h3><p>能力检测（又称特性检测）即在 JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。</p><p>能力检测的基本模式如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (object.propertyInQuestion) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用object.propertyInQuestion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>进行能力检测时应该尽量使用 typeof 操作符。<br> 最好集中检测所有能力，而不是等到用的时候再重复检测。</p><h3 id="用户代理检测" tabindex="-1">用户代理检测 <a class="header-anchor" href="#用户代理检测" aria-label="Permalink to &quot;用户代理检测&quot;">​</a></h3><p>用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。<br> 用户代理字符串包含在每个 HTTP 请求的头部，在 JavaScript 中可以通过 <strong>navigator.userAgent</strong> 访问。</p><ol><li><p>伪造用户代理<br> 有些浏览器提供伪私有的 <code>__defineGetter__</code> 方法，利用它可以篡改用户代理字符串。</p></li><li><p>分析浏览器<br> 通过解析浏览器返回的用户代理字符串，可以极其准确地推断出下列相关的环境信息：</p><ul><li>浏览器</li><li>浏览器版本</li><li>浏览器渲染引擎</li><li>设备类型（桌面/移动）</li><li>设备生产商</li><li>设备型号</li><li>操作系统</li><li>操作系统版本</li></ul><p>GitHub 上维护比较频繁的第三方用户代理解析程序：</p><ul><li>Bowser</li><li>UAParser.js</li><li>Platform.js</li><li>CURRENT-DEVICE</li><li>Google Closure</li><li>Mootools</li></ul></li></ol><h3 id="软件与硬件检测" tabindex="-1">软件与硬件检测 <a class="header-anchor" href="#软件与硬件检测" aria-label="Permalink to &quot;软件与硬件检测&quot;">​</a></h3><p>现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。<br> 这些属性可以通过暴露在 window.navigator 上的一组 API 获得。</p><p>==识别浏览器与操作系统==</p><ol><li><strong>navigator.oscpu</strong> ：是一个字符串，通常对应用户代理字符串中操作系统/系统架构相关信息。</li><li><strong>navigator.vendor</strong>：是一个字符串，通常包含浏览器开发商信息。</li><li><strong>navigator.platform</strong> ：是一个字符串，通常表示浏览器所在的操作系统。</li><li><strong>screen.colorDepth</strong> 和<strong>screen.pixelDepth</strong> ：返回一样的值，即显示器每像素颜色的位深。</li><li><strong>screen.orientation</strong> ：返回一个 ScreenOrientation 对象，其中包含 Screen Orientation API 定义的屏幕信息。</li></ol><p>==浏览器元数据==</p><ol><li><p><strong>navigator.geolocation</strong><br> 暴露了 Geolocation API，可以让浏览器脚本感知当前设备的地理位置。</p></li><li><p><strong>Connection State</strong> 和<strong>NetworkInformation API</strong><br> 浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和 navigator.onLine 属性。</p></li><li><p><strong>Battery Status API</strong><br> 浏览器可以访问设备电池及充电状态的信息。<code>navigator.getBattery()</code> 方法会返回一个期约实例，解决为一个 BatteryManager 对象。</p></li></ol><p>==硬件==</p><ol><li>处理器核心数<br><strong>navigator.hardwareConcurrency</strong> 属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值（如果核心数无法确定，这个值就是 1）。</li><li>设备内存大小<br><strong>navigator.deviceMemory</strong> 属性返回设备大致的系统内存大小，包含单位为 GB 的浮点数（舍入为最接近的 2 的幂：512MB 返回 0.5，4GB 返回 4）。</li><li>最大触点数<br><strong>navigator.maxTouchPoints</strong> 属性返回触摸屏支持的最大关联触点数量，包含一个整数值。</li></ol>`,82)]))}const b=o(r,[["render",s]]);export{k as __pageData,b as default};
