import{_ as e,c as a,o as t,ag as l}from"./chunks/framework.-ewJmwvT.js";const h=JSON.parse('{"title":"11-pngquant 工具","description":"","frontmatter":{},"headers":[],"relativePath":"服务端/NodeJS/NodeJS笔记/11-pngquant工具.md","filePath":"服务端/NodeJS/NodeJS笔记/11-pngquant工具.md"}'),n={name:"服务端/NodeJS/NodeJS笔记/11-pngquant工具.md"};function s(o,i,p,d,u,r){return t(),a("div",null,i[0]||(i[0]=[l(`<h1 id="_11-pngquant-工具" tabindex="-1">11-pngquant 工具 <a class="header-anchor" href="#_11-pngquant-工具" aria-label="Permalink to &quot;11-pngquant 工具&quot;">​</a></h1><p><a href="https://pngquant.org/" target="_blank" rel="noreferrer">pngquant — lossy PNG compressor</a></p><p><code>pngquant</code> 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。通过减小文件大小，可以提高网页加载速度，并节省存储空间。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</p><h2 id="基础使用" tabindex="-1">基础使用 <a class="header-anchor" href="#基础使用" aria-label="Permalink to &quot;基础使用&quot;">​</a></h2><ul><li>安装</li><li>环境变量配置</li><li>调用 shell 命令</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { exec } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;child_process&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pngquant 73kb.png --output test.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>Options</li></ul><ol><li><p><code>--ext new.png</code><br> Set custom extension for output filename. By default <code>-or8.png</code> or <code>-fs8.png</code> is used.</p></li><li><p><code>--quality min-max</code><br> Instructs <code>pngquant</code> to use the least amount of colors required to meet or exceed the max quality. If conversion results in quality below the min quality the image won&#39;t be saved (if outputting to stdout, 24-bit original will be output) and <code>pngquant</code> will exit with status code 99.</p><p>min and max are numbers in range 0 (worst) to 100 (perfect), similar to JPEG.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pngquant --quality=65-80 image.png</span></span></code></pre></div></li><li><p><code>--speed N</code>, <code>-sN</code><br> Speed/quality trade-off from 1 (brute-force) to 10 (fastest). The default is 3. Speed 10 has 5% lower quality, but is 8 times faster than the default.</p></li><li><p><code>--version</code><br> Print version information to stdout.</p></li><li><p><code>-</code><br> Read image from stdin and send result to stdout.</p></li><li><p><code>--</code><br> Stops processing of arguments. This allows use of file names that start with <code>-</code>. If you&#39;re using <code>pngquant</code> in a script, it&#39;s advisable to put this before file names:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pngquant $OPTIONS -- &quot;$FILE&quot;</span></span></code></pre></div></li></ol><h2 id="原理是什么" tabindex="-1">原理是什么? <a class="header-anchor" href="#原理是什么" aria-label="Permalink to &quot;原理是什么?&quot;">​</a></h2><p>pngquant 使用修改过的 Median Cut 量化算法以及其他技术来实现压缩 PNG 图像的目的。它的工作原理如下：</p><ol><li>首先，pngquant 构建一个直方图，用于统计图像中的颜色分布情况。</li><li>接下来，它选择盒子来代表一组颜色。与传统的 Median Cut 算法不同，pngquant 选择的盒子是为了最小化盒子中颜色与中位数的差异。</li><li>pngquant 使用感知模型给予图像中噪声较大的区域较少的权重，以建立更准确的直方图。</li><li>为了进一步改善颜色，pngquant 使用类似梯度下降的过程对直方图进行调整。它多次重复 Median Cut 算法，并在较少出现的颜色上增加权重。</li><li>最后，为了生成最佳的调色板，pngquant 使用 Voronoi 迭代（K-means）对颜色进行校正，以确保局部最优。</li><li>在重新映射颜色时，pngquant 只在多个相邻像素量化为相同颜色且不是边缘的区域应用误差扩散。这样可以避免在视觉质量较高且不需要抖动的区域添加噪声。</li></ol><p>通过这些步骤，pngquant 能够在保持图像质量的同时，将 PNG 图像的文件大小减小到最低限度。</p><h2 id="median-cut-量化算法" tabindex="-1">Median Cut 量化算法 <a class="header-anchor" href="#median-cut-量化算法" aria-label="Permalink to &quot;Median Cut 量化算法&quot;">​</a></h2><p>假设我们有一张 8x8 像素的彩色图像，每个像素由红色、绿色和蓝色通道组成，每个通道的值范围是 0 到 255。</p><ol><li><p>初始化：我们将图像中的每个像素视为一个颜色点，并将它们放入一个初始的颜色桶。</p></li><li><p>选择划分桶：在初始的颜色桶中选择一个具有最大范围的颜色通道，假设我们选择红色通道。</p></li><li><p>划分颜色：对于选定的红色通道，将颜色桶中的颜色按照红色通道的值进行排序，并找到中间位置的颜色值作为划分点。假设划分点的红色值为 120。</p><p>划分前的颜色桶：</p><ul><li>颜色 1: (100, 50, 200)</li><li>颜色 2: (150, 30, 100)</li><li>颜色 3: (80, 120, 50)</li><li>颜色 4: (200, 180, 160)</li></ul><p>划分后的颜色桶：</p><ul><li>子桶 1: <ul><li>颜色 1: (100, 50, 200)</li><li>颜色 3: (80, 120, 50)</li></ul></li><li>子桶 2: <ul><li>颜色 2: (150, 30, 100)</li><li>颜色 4: (200, 180, 160)</li></ul></li></ul></li><li><p>重复划分：我们继续选择颜色范围最大的通道，假设我们选择子桶 1 中的绿色通道。</p><p>划分前的颜色桶（子桶 1）：</p><ul><li>颜色 1: (100, 50, 200)</li><li>颜色 3: (80, 120, 50)</li></ul><p>划分后的颜色桶（子桶 1）：</p><ul><li>子桶 1.1: <ul><li>颜色 3: (80, 120, 50)</li></ul></li><li>子桶 1.2: <ul><li>颜色 1: (100, 50, 200)</li></ul></li></ul><p>子桶 2 中只有两个颜色，不需要再进行划分。</p></li><li><p>颜色映射：将原始图像中的每个像素颜色映射到最接近的颜色桶中的颜色。</p><p>假设原始图像中的一个像素为 (110, 70, 180)，我们将它映射到颜色 1: (100, 50, 200)</p><p>大概的公式为 <code>sqrt((110-100)^2 + (70-50)^2 + (180-200)^2) ≈ 31.62</code></p><p>通过 Median Cut 算法，我们将原始图像中的颜色数目从 64 个（8x8 像素）减少到 4 个颜色桶，从而实现了图像的量化</p></li></ol>`,15)]))}const g=e(n,[["render",s]]);export{h as __pageData,g as default};
