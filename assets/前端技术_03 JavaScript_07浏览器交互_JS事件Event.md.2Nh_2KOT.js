import{_ as s,a as i,b as a,c as e}from"./chunks/13 事件Event-5.C2fvjGRX.js";import{_ as n,c as l,o as h,ae as d}from"./chunks/framework.CIivgcbp.js";const F=JSON.parse('{"title":"JS 事件 Event","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/07浏览器交互/JS事件Event.md","filePath":"前端技术/03 JavaScript/07浏览器交互/JS事件Event.md"}'),p={name:"前端技术/03 JavaScript/07浏览器交互/JS事件Event.md"};function k(r,t,o,E,c,g){return h(),l("div",null,t[0]||(t[0]=[d('<h1 id="js-事件-event" tabindex="-1">JS 事件 Event <a class="header-anchor" href="#js-事件-event" aria-label="Permalink to &quot;JS 事件 Event&quot;">​</a></h1><p>JavaScript 与 HTML 的交互是通过<strong>事件</strong>实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的<strong>监听器</strong>（也叫处理程序）订阅事件。</p><h2 id="事件流" tabindex="-1">事件流 <a class="header-anchor" href="#事件流" aria-label="Permalink to &quot;事件流&quot;">​</a></h2><p><strong>事件流</strong>描述了页面接收事件的顺序。IE 和 Netscape 开发团队提出了几乎完全相反的事件流方案。IE 将支持事件冒泡流，而 Netscape Communicator 将支持事件捕获流。</p><h3 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h3><p>IE 事件流被称为<strong>事件冒泡</strong>，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。<br><img src="'+s+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/13 事件Event-1.png"></p><p>现代浏览器中的事件会一直冒泡到 window 对象。</p><h3 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h3><p>Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。<br><img src="'+i+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/13 事件Event-2.png"></p><h3 id="dom-事件流" tabindex="-1">DOM 事件流 <a class="header-anchor" href="#dom-事件流" aria-label="Permalink to &quot;DOM 事件流&quot;">​</a></h3><p>DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。<br><img src="'+a+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/13 事件Event-3.png"><br> 所有现代浏览器都支持 DOM 事件流，只有 IE8 及更早版本不支持。</p><h2 id="事件处理程序" tabindex="-1">事件处理程序 <a class="header-anchor" href="#事件处理程序" aria-label="Permalink to &quot;事件处理程序&quot;">​</a></h2><p>事件意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停（mouseover）。为响应事件而调用的函数被称为<strong>事件处理程序</strong>（或<strong>事件监听器</strong>）。<br> 事件处理程序的名字以 &quot;on&quot; 开头。</p><h3 id="html-事件处理程序" tabindex="-1">HTML 事件处理程序 <a class="header-anchor" href="#html-事件处理程序" aria-label="Permalink to &quot;HTML 事件处理程序&quot;">​</a></h3><p>特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。</p><ul><li><strong>内联事件处理程序（Inline Event Handler）</strong></li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;button&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Click Me&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onclick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>内联事件处理程序会动态创建一个包装函数来封装属性的值。这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象。</p><p>在这个函数中，document 和元素自身的成员都可以被当成局部变量来访问。这是通过使用 with 实现的。这意味着事件处理程序可以更方便地访问自己的属性。==this 指向元素本身。==</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 属性值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>函数引用事件处理程序（Function Reference Event Handler）</strong></li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;button&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Click Me&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onclick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showMessage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>函数引用事件处理程序通用可以访问 event，函数定义在全局作用域，==this 指向 window==。</p><p>使用 HTML 指定事件处理程序的最后一个问题是 ==HTML 与 JavaScript 强耦合==。如果需要修改事件处理程序，则必须在两个地方，即 HTML 和 JavaScript 中，修改代码。</p><h3 id="dom0-事件处理程序" tabindex="-1">DOM0 事件处理程序 <a class="header-anchor" href="#dom0-事件处理程序" aria-label="Permalink to &quot;DOM0 事件处理程序&quot;">​</a></h3><p>要使用 JavaScript 指定事件处理程序，必须先取得要操作对象的引用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> btn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myBtn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>所赋函数被视为元素的方法，因此，事件处理程序会在元素的作用域中运行，即 ==this 等于元素==。<br> 以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。<br> 通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序。</p><h3 id="dom2-事件处理程序" tabindex="-1">DOM2 事件处理程序 <a class="header-anchor" href="#dom2-事件处理程序" aria-label="Permalink to &quot;DOM2 事件处理程序&quot;">​</a></h3><p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：<code>addEventListener()</code> 和 <code>removeEventListener()</code>。</p><blockquote><p>[!example]+ addEventListener</p><p><code>target.addEventListener(type, listener [, options])</code> 方法用于在指定的目标元素上注册事件处理程序。</p><ul><li>type: 字符串，表示要监听的事件类型（例如 &#39;click&#39;, &#39;mouseover&#39;）。</li><li>listener: 一个实现了 <code>EventListener</code> 接口的对象或是一个函数，当所监听的事件发生时会被调用。</li><li>options: 可选参数，可以是布尔值或者是一个对象。如果是对象，则可以包含以下属性： <ul><li>capture: 布尔值，指示事件是否在捕获阶段触发（默认为 false）。</li><li>once: 布尔值，指示事件处理器只执行一次后就自动移除（默认为 false）。</li><li>passive: 布尔值，指示处理函数不会调用 <code>preventDefault()</code>（默认为 false），这有助于提高性能，特别是对于滚动事件。</li></ul></li></ul><p>返回值: 无返回值。</p></blockquote><blockquote><p>[!example]+ removeEventListener</p><p><code>target.removeEventListener(type, listener [, options])</code> 方法用于从目标元素中删除先前添加的事件监听器。</p><ul><li>type: 字符串，表示要移除监听器的事件类型。</li><li>listener: 需要移除的事件处理函数或实现了 <code>EventListener</code> 接口的对象。</li><li>options: 可选参数，通常只需要关注那些影响如何匹配监听器的选项（如 capture）。如果最初添加监听器时使用了选项对象，则此处也应使用相同的选项对象来确保正确匹配。</li></ul><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>==必须提供与最初添加监听器时完全相同的函数引用才能成功移除监听器==。</li></ul></blockquote><h2 id="事件对象" tabindex="-1">事件对象 <a class="header-anchor" href="#事件对象" aria-label="Permalink to &quot;事件对象&quot;">​</a></h2><p>在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中，event 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0 或 DOM2）指定事件处理程序，都会传入这个 event 对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> btn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myBtn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.type); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;click&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.type); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;click&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>事件对象包含与特定事件相关的属性和方法。==不同的事件生成的事件对象也会包含不同的属性和方法==。不过，所有事件对象都会包含下表列出的这些公共属性和方法。</p><table tabindex="0"><thead><tr><th>属性/方法</th><th>类型</th><th>读/写</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>元素</td><td>只读</td><td>==事件目标==</td></tr><tr><td>currentTarget</td><td>元素</td><td>只读</td><td>==当前事件处理程序所在的元素==</td></tr><tr><td>bubbles</td><td>布尔值</td><td>只读</td><td>表示事件是否冒泡</td></tr><tr><td>cancelable</td><td>布尔值</td><td>只读</td><td>表示是否可以取消事件的默认行为</td></tr><tr><td>defaultPrevented</td><td>布尔值</td><td>只读</td><td>true 表示已经调用 preventDefault() 方法（DOM3 Events 中新增）</td></tr><tr><td>detail</td><td>整数</td><td>只读</td><td>事件相关的其他信息</td></tr><tr><td>eventPhase</td><td>整数</td><td>只读</td><td>表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td></tr><tr><td>preventDefault()</td><td>函数</td><td>只读</td><td>用于取消事件的默认行为。只有 cancelable 为 true 才可以调用这个方法</td></tr><tr><td>stopImmediatePropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）</td></tr><tr><td>stopPropagation()</td><td>函数</td><td>只读</td><td>用于取消所有后续事件捕获或事件冒泡。只有 bubbles 为 true 才可以调用这个方法</td></tr><tr><td>trusted</td><td>布尔值</td><td>只读</td><td>true 表示事件是由浏览器生成的。false 表示事件是开发者通过 JavaScript 创建的（DOM3 Events 中新增）</td></tr><tr><td>type</td><td>字符串</td><td>只读</td><td>被触发的事件类型</td></tr><tr><td>view</td><td>AbstractView</td><td>只读</td><td>与事件相关的抽象视图。等于事件所发生的 window 对象</td></tr></tbody></table><p>在事件处理程序内部，==this 对象始终等于 currentTarget 的值==，而 target 只包含事件的实际目标。</p><p>如果这个事件处理程序是添加到按钮的父节点（如 document.body）上，那么 ==currentTarget 指向的是父节点（绑定事件的元素），target 指向的是触发元素==。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.currentTarget </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myBtn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>使用 <strong>event.type</strong> 属性确定了事件类型，从而可以做出不同的响应。</p><p><code>preventDefault()</code> 方法用于阻止特定事件的默认动作。</p><p><code>stopPropagation()</code> 方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。</p><p><strong>eventPhase</strong> 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则 eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3。</p><p>注意，event 对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。</p><h2 id="事件类型" tabindex="-1">事件类型 <a class="header-anchor" href="#事件类型" aria-label="Permalink to &quot;事件类型&quot;">​</a></h2><p>DOM3 Events 定义了如下事件类型：</p><ul><li>用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。</li><li>焦点事件（FocusEvent）：在元素获得和失去焦点时触发。</li><li>鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。</li><li>滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。</li><li>输入事件（InputEvent）：向文档中输入文本时触发。</li><li>键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。</li><li>合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。</li></ul><h3 id="用户界面事件" tabindex="-1">用户界面事件 <a class="header-anchor" href="#用户界面事件" aria-label="Permalink to &quot;用户界面事件&quot;">​</a></h3><p>用户界面事件或 UI 事件不一定跟用户操作有关。这类事件在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>load</td><td>在 window 上当页面加载完成后触发；<br>在 <code>&lt;frameset&gt;</code> 上当所有 <code>&lt;frame&gt;</code> 都加载完成后触发；<br>在 <code>&lt;img&gt;</code> 元素上当图片加载完成后触发；<br>在 <code>&lt;object&gt;</code> 元素上当相应对象加载完成后触发。</td><td>确保所有外部资源（如图像、样式表）都已加载完毕再显示页面</td></tr><tr><td>unload</td><td>在 window 上当页面完全卸载后触发；<br>在 <code>&lt;frameset&gt;</code> 上当所有 <code>&lt;frame&gt;</code> 都卸载完成后触发；<br>在 <code>&lt;object&gt;</code> 元素上当相应对象卸载完成后触发。</td><td>执行清理工作，如删除会话数据、关闭连接或保存用户状态等。</td></tr><tr><td>abort</td><td>在 <code>&lt;object&gt;</code> 元素上当相应对象加载完成前被用户提前终止下载时触发。</td><td>当用户中断了某个对象（如视频、音频文件）的加载时，可以用来提示用户或者记录日志。</td></tr><tr><td>error</td><td>在 window 上当 JavaScript 报错时触发；<br>在 <code>&lt;img&gt;</code> 元素上当无法加载指定图片时触发；<br>在 <code>&lt;object&gt;</code> 元素上当无法加载相应对象时触发；<br>在 <code>&lt;frameset&gt;</code> 上当一个或多个 <code>&lt;frame&gt;</code> 无法完成加载时触发。</td><td>错误处理</td></tr><tr><td>select</td><td>在文本框（<code>&lt;input&gt;</code> 或 <code>&lt;textarea&gt;</code>）上当用户选择了一个或多个字符时触发。</td><td>实现自定义的选择功能，如在用户选择文本时自动复制到剪贴板或启用特定格式化选项。</td></tr><tr><td>resize</td><td>在 window 或窗格上当窗口或窗格被缩放时触发。</td><td>动态调整布局或重新计算元素尺寸，以适应新的窗口大小。常用于响应式设计中。</td></tr><tr><td>scroll</td><td>当用户滚动包含滚动条的元素时在元素上触发。<code>&lt;body&gt;</code> 元素包含已加载页面的滚动条。</td><td>监听用户的滚动行为，实现无限滚动、懒加载图片或其他依赖于滚动位置的功能。</td></tr></tbody></table><h3 id="焦点事件" tabindex="-1">焦点事件 <a class="header-anchor" href="#焦点事件" aria-label="Permalink to &quot;焦点事件&quot;">​</a></h3><p>焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 <code>document.hasFocus()</code> 和 <strong>document.activeElement</strong> 一起为开发者提供用户在页面中导航的信息。</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>blur</td><td>当元素失去焦点时触发。这个事件不冒泡。</td><td>验证表单输入、关闭弹出窗口或提示框、保存用户在某个字段中的临时数据等。</td></tr><tr><td>focus</td><td>当元素获得焦点时触发。这个事件不冒泡。</td><td>表单验证、高亮显示当前选中的元素、自动填充建议等。</td></tr><tr><td>focusin</td><td>当元素获得焦点时触发。这个事件是 focus 的冒泡版。</td><td>在需要冒泡行为的场景中使用，例如在父元素上监听子元素的焦点变化，以实现更灵活的交互设计。</td></tr><tr><td>focusout</td><td>当元素失去焦点时触发。这个事件是 blur 的通用版。</td><td>在需要冒泡行为的场景中使用，例如在父元素上监听子元素的焦点丢失，以便进行统一的处理逻辑。</td></tr></tbody></table><p>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</p><ol><li>focuscout 在失去焦点的元素上触发。</li><li>focusin 在获得焦点的元素上触发。</li><li>blur 在失去焦点的元素上触发。</li><li>focus 在获得焦点的元素上触发。</li></ol><h3 id="鼠标和滚轮事件" tabindex="-1">鼠标和滚轮事件 <a class="header-anchor" href="#鼠标和滚轮事件" aria-label="Permalink to &quot;鼠标和滚轮事件&quot;">​</a></h3><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>click</td><td>在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。</td><td>实现按钮点击、链接跳转、选择项目等交互操作；触发菜单或对话框的显示；执行确认操作。</td></tr><tr><td>dblclick</td><td>在用户双击鼠标主键（通常是左键）时触发。</td><td>启动编辑模式、放大/缩小元素、打开文件或目录等；在图形界面中实现快速操作。</td></tr><tr><td>mousedown</td><td>在用户按下任意鼠标键时触发。</td><td>捕捉用户开始拖拽动作、按下按钮或图标时改变样式以提供视觉反馈；实现自定义的点击效果。</td></tr><tr><td>mouseup</td><td>在用户释放鼠标键时触发。</td><td>确定拖拽操作结束，恢复按钮或图标的原始样式；与 mousedown 结合使用来识别完整的点击行为。</td></tr><tr><td>mouseenter</td><td>在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。</td><td>当鼠标进入一个区域时显示提示信息或工具提示；更改元素的外观以指示可交互性。</td></tr><tr><td>mouseleave</td><td>在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。</td><td>鼠标离开某个区域时隐藏提示信息或工具提示；重置元素外观或状态。</td></tr><tr><td>mousemove</td><td>在鼠标光标在元素上移动时反复触发。</td><td>跟踪鼠标位置以绘制路径、更新坐标信息；实现跟随鼠标的动态效果。</td></tr><tr><td>mouseout</td><td>在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。</td><td>当鼠标移出元素时取消高亮显示或工具提示；管理复杂交互中的状态变化。</td></tr><tr><td>mouseover</td><td>在用户把鼠标光标从元素外部移到元素内部时触发。</td><td>当鼠标悬停于元素上方时显示额外的信息或选项；为用户提供即时反馈或互动机会。</td></tr></tbody></table><p>鼠标双击触发的事件顺序如下：</p><ul><li>mousedown</li><li>mouseup</li><li>click</li><li>mousedown</li><li>mouseup</li><li>click</li><li>dblclick</li></ul><p>鼠标事件还有一个名为<strong>滚轮事件</strong>的子类别。滚轮事件只有一个事件 mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</p><h4 id="坐标" tabindex="-1">坐标 <a class="header-anchor" href="#坐标" aria-label="Permalink to &quot;坐标&quot;">​</a></h4><p>鼠标事件的 event 对象包含多种点击坐标信息，包括客户端坐标、页面坐标和屏幕坐标。</p><ul><li><p>客户端坐标<br> ==clientX 和 clientY==，事件发生时鼠标光标在视口中的坐标</p></li><li><p>页面坐标<br> ==pageX 和 pageY==，事件发生时鼠标光标在页面上的坐标<br> 在页面没有滚动时，pageX 和 pageY 与 clientX 和 clientY 的值相同。</p></li><li><p>屏幕坐标<br> ==screenX 和 screenY==，事件发生时鼠标光标在屏幕上的坐标。</p></li></ul><p><img src="`+e+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/13 事件Event-5.png"></p><h4 id="修饰键" tabindex="-1">修饰键 <a class="header-anchor" href="#修饰键" aria-label="Permalink to &quot;修饰键&quot;">​</a></h4><p>键盘上的修饰键 Shift、Ctrl、Alt 和 Meta 经常用于修改鼠标事件的行为。DOM 规定了 4 个属性来表示这几个修饰键的状态：<strong>shiftKey</strong>、<strong>ctrlKey</strong>、<strong>altKey</strong> 和 <strong>metaKey</strong>。</p><p>这几属性会在各自对应的修饰键被按下时包含布尔值 true，没有被按下时包含 false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。</p><h4 id="相关元素" tabindex="-1">相关元素 <a class="header-anchor" href="#相关元素" aria-label="Permalink to &quot;相关元素&quot;">​</a></h4><p>对 mouseover 和 mouseout 事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对 mouseover 事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对 mouseout 事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。</p><p>DOM 通过 event 对象的 <strong>relatedTarget</strong> 属性提供了相关元素的信息。<br> 这个属性只有在 mouseover 和 mouseout 事件发生时才包含值，其他所有事件的这个属性的值都是 null。</p><h4 id="鼠标按键" tabindex="-1">鼠标按键 <a class="header-anchor" href="#鼠标按键" aria-label="Permalink to &quot;鼠标按键&quot;">​</a></h4><p>对 mousedown 和 mouseup 事件来说，event 对象上会有一个 <strong>button</strong> 属性，表示按下或释放的是哪个按键。DOM 为这个 button 属性定义了 3 个值：0 表示鼠标主键、1 表示鼠标中键（通常也是滚轮键）、2 表示鼠标副键。</p><h4 id="额外事件信息" tabindex="-1">额外事件信息 <a class="header-anchor" href="#额外事件信息" aria-label="Permalink to &quot;额外事件信息&quot;">​</a></h4><p>DOM2 Events 规范在 event 对象上提供了 detail 属性，以给出关于事件的更多信息。对鼠标事件来说，<strong>detail</strong> 包含一个数值，表示在给定位置上发生了多少次单击。如果鼠标在 mousedown 和 mouseup 之间移动了，则 detail 会重置为 0。</p><h4 id="mousewheel-事件" tabindex="-1">mousewheel 事件 <a class="header-anchor" href="#mousewheel-事件" aria-label="Permalink to &quot;mousewheel 事件&quot;">​</a></h4><p>mousewheel 事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。这个事件会在任何元素上触发，并冒泡到 window。<br> 此外还有一个名为 <strong>wheelDelta</strong> 的新属性。当鼠标滚轮向前滚动时，wheelDelta 每次都是 +120；而当鼠标滚轮向后滚动时，wheelDelta 每次都是–120。</p><h3 id="键盘与输入事件" tabindex="-1">键盘与输入事件 <a class="header-anchor" href="#键盘与输入事件" aria-label="Permalink to &quot;键盘与输入事件&quot;">​</a></h3><p>键盘事件是用户操作键盘时触发的。</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>keydown</td><td>用户按下键盘上某个键时触发，而且持续按住会重复触发。</td><td>实现快捷键功能；控制游戏中的角色移动；在用户开始输入时进行预处理或验证。</td></tr><tr><td>keyup</td><td>用户释放键盘上某个键时触发。</td><td>检测组合键的结束；在用户完成按键操作后执行特定逻辑；确保只在按键释放时触发某些交互效果。</td></tr><tr><td>keypress</td><td>用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。<br>Esc 键也会触发这个事件。<br>DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。</td><td>捕捉用户输入的字符以实时显示或处理；实现文本输入过滤或转换；在旧版浏览器中用于检测字符输入。</td></tr></tbody></table><p>当用户按下键盘上的某个字符键时，首先会触发 keydown 事件，然后触发 keypress 事件，最后触发 keyup 事件。</p><p>键盘事件支持与鼠标事件相同的修饰键。<strong>shiftKey、ctrlKey、altKey 和 metaKey</strong> 属性在键盘事件中都是可用的。</p><h4 id="键码" tabindex="-1">键码 <a class="header-anchor" href="#键码" aria-label="Permalink to &quot;键码&quot;">​</a></h4><p>对于 keydown 和 keyup 事件，event 对象的 ==keyCode== 属性中会保存一个键码，对应键盘上特定的一个键。<br> 对于字母和数字键，keyCode 的值与小写字母和数字的 ASCII 编码一致。<br> 其他非字符键的键码如下：</p><table tabindex="0"><thead><tr><th>键</th><th>键码</th><th>键</th><th>键码</th><th>键</th><th>键码</th></tr></thead><tbody><tr><td>Backspace</td><td>8</td><td>数字键盘 +</td><td>107</td><td>F6</td><td>117</td></tr><tr><td>Tab</td><td>9</td><td>减号（包含数字和非数字键盘）</td><td>109</td><td>F7</td><td>118</td></tr><tr><td>Enter</td><td>13</td><td>数字键盘.</td><td>110</td><td>F8</td><td>119</td></tr><tr><td>Shift</td><td>16</td><td>数字键盘/</td><td>111</td><td>F9</td><td>120</td></tr><tr><td>Ctrl</td><td>17</td><td>F1</td><td>112</td><td>F10</td><td>121</td></tr><tr><td>Alt</td><td>18</td><td>F2</td><td>113</td><td>F11</td><td>122</td></tr><tr><td>Pause/Break</td><td>19</td><td>F3</td><td>114</td><td>F12</td><td>123</td></tr><tr><td>Caps Lock</td><td>20</td><td>F4</td><td>115</td><td>Num Lock</td><td>144</td></tr><tr><td>Esc</td><td>27</td><td>F5</td><td>116</td><td>Scroll Lock</td><td>145</td></tr><tr><td>Page Up</td><td>33</td><td>左箭头</td><td>37</td><td>分号 (IE/Safari/Chrome)</td><td>186</td></tr><tr><td>Page Down</td><td>34</td><td>上箭头</td><td>38</td><td>分号 (Opera/FF)</td><td>59</td></tr><tr><td>End</td><td>35</td><td>右箭头</td><td>39</td><td>小于号</td><td>188</td></tr><tr><td>Home</td><td>36</td><td>下箭头</td><td>40</td><td>大于号</td><td>190</td></tr><tr><td>左箭头</td><td>37</td><td>Ins</td><td>45</td><td>反斜杠</td><td>191</td></tr><tr><td>上箭头</td><td>38</td><td>Del</td><td>46</td><td>重音符 (\`)</td><td>192</td></tr><tr><td>右箭头</td><td>39</td><td>左 Windows</td><td>91</td><td>等于号</td><td>61</td></tr><tr><td>下箭头</td><td>40</td><td>右 Windows</td><td>92</td><td>左中括号</td><td>219</td></tr><tr><td>Ins</td><td>45</td><td>Context Menu</td><td>93</td><td>反斜杠 ()</td><td>220</td></tr><tr><td>Del</td><td>46</td><td>数字键盘 0</td><td>96</td><td>右中括号</td><td>221</td></tr><tr><td>左 Windows</td><td>91</td><td>数字键盘 1</td><td>97</td><td>单引号</td><td>222</td></tr><tr><td>右 Windows</td><td>92</td><td>数字键盘 2</td><td>98</td><td></td><td></td></tr><tr><td>Context Menu</td><td>93</td><td>数字键盘 3</td><td>99</td><td></td><td></td></tr><tr><td>数字键盘 0</td><td>96</td><td>数字键盘 4</td><td>100</td><td></td><td></td></tr><tr><td>数字键盘 1</td><td>97</td><td>数字键盘 5</td><td>101</td><td></td><td></td></tr><tr><td>数字键盘 2</td><td>98</td><td>数字键盘 6</td><td>102</td><td></td><td></td></tr><tr><td>数字键盘 3</td><td>99</td><td>数字键盘 7</td><td>103</td><td></td><td></td></tr></tbody></table><h4 id="字符编码" tabindex="-1">字符编码 <a class="header-anchor" href="#字符编码" aria-label="Permalink to &quot;字符编码&quot;">​</a></h4><p>浏览器在 event 对象上支持 <strong>charCode</strong> 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。</p><p>一旦有了字母编码，就可以使用 <code>String.fromCharCode()</code> 方法将其转换为实际的字符了。</p><h4 id="dom3-的变化" tabindex="-1">DOM3 的变化 <a class="header-anchor" href="#dom3-的变化" aria-label="Permalink to &quot;DOM3 的变化&quot;">​</a></h4><ul><li><strong>key 和 char</strong></li></ul><p>key 属性用于替代 keyCode，是按键的字符。<br> char 属性在按下字符键时与 key 类似，在按下非字符键时为 null。</p><ul><li><strong>location</strong></li></ul><p>该属性是一个数值，表示是在哪里按的键。可能的值为：0 是默认键，1 是左边（如左边的 Alt 键），2 是右边（如右边的 Shift 键），3 是数字键盘，4 是移动设备（即虚拟键盘），5 是游戏手柄（如任天堂 Wii 控制器）。</p><ul><li>textInput 事件</li></ul><p>textInput 事件在字符被输入到可编辑区域时触发。<br> 作为对 keypress 的替代，textInput 事件的行为有些不一样。一个区别是 keypress 会在任何可以获得焦点的元素上触发，而 ==textInput 只在可编辑区域上触发==。另一个区别是 ==textInput 只在有新字符被插入时才会触发==，而 keypress 对任何可能影响文本的键都会触发（包括退格键）。</p><p>event 对象上提供了一个 <strong>data</strong> 属性，包含要插入的字符（不是字符编码）。data 的值始终是要被插入的字符，因此如果在按 S 键时没有按 Shift 键，data 的值就是 &quot;s&quot;，但在按 S 键时同时按 Shift 键，data 的值则是 &quot;S&quot;。</p><p>event 对象上还有一个名为 <strong>inputMethod</strong> 的属性，该属性表示向控件中输入文本的手段：</p><ul><li>0，表示浏览器不能确定是什么输入手段；</li><li>1，表示键盘；</li><li>2，表示粘贴；</li><li>3，表示拖放操作；</li><li>4，表示 IME；</li><li>5，表示表单选项；</li><li>6，表示手写（如使用手写笔）；</li><li>7，表示语音；</li></ul><h3 id="合成事件" tabindex="-1">合成事件 <a class="header-anchor" href="#合成事件" aria-label="Permalink to &quot;合成事件&quot;">​</a></h3><p>合成事件是 DOM3 Events 中新增的，用于处理通常使用<strong>输入法编辑器（Input Method Editor）</strong> 输入时的复杂输入序列。IME 可以让用户输入物理键盘上没有的字符。</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>compositionstart</td><td>在 IME 的文本合成系统打开时触发，表示输入即将开始</td><td>这个事件可以用于在用户使用输入法进行复杂字符输入（如中文、日文等）之前准备相应的资源或界面。例如，在一个聊天应用中，可以用来显示正在输入的状态或者调整输入框以适应即将到来的输入内容。</td></tr><tr><td>compositionupdate</td><td>在新字符插入输入字段时触发</td><td>可以用于实时更新显示用户通过输入法输入的内容。比如在一个在线文档编辑器中，随着用户选择不同的候选词或输入更多的字符，前端界面能够即时反映这些变化。</td></tr><tr><td>compositionend</td><td>在 IME 的文本合成系统关闭时触发，表示恢复正常键盘输入</td><td>当用户完成特殊语言字符的输入后，可以执行一些清理工作或处理最终确定的输入文本。例如，在一个表单提交页面中，当检测到此事件时，可以检查并确认所有必填项是否已经填写完毕，并准备提交数据。</td></tr></tbody></table><p>在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是 <strong>data</strong>，其中包含的值视情况而异：</p><ul><li>在 compositionstart 事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）；</li><li>在 compositionupdate 事件中，包含要插入的新字符；</li><li>在 compositionend 事件中，包含本次合成过程中输入的全部内容。</li></ul><h3 id="html5-事件" tabindex="-1">HTML5 事件 <a class="header-anchor" href="#html5-事件" aria-label="Permalink to &quot;HTML5 事件&quot;">​</a></h3><h4 id="contextmenu-事件" tabindex="-1">contextmenu 事件 <a class="header-anchor" href="#contextmenu-事件" aria-label="Permalink to &quot;contextmenu 事件&quot;">​</a></h4><p>contextmenu 事件专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。</p><p>contextmenu 事件应该算一种鼠标事件，因此 event 对象上的很多属性都与光标位置有关。<br> 通常，自定义的上下文菜单都是通过 oncontextmenu 事件处理程序触发显示，并通过 onclick 事件处理程序触发隐藏的。</p><h4 id="beforeunload-事件" tabindex="-1">beforeunload 事件 <a class="header-anchor" href="#beforeunload-事件" aria-label="Permalink to &quot;beforeunload 事件&quot;">​</a></h4><p>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。</p><p>这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。</p><h4 id="domcontentloaded-事件" tabindex="-1">DOMContentLoaded 事件 <a class="header-anchor" href="#domcontentloaded-事件" aria-label="Permalink to &quot;DOMContentLoaded 事件&quot;">​</a></h4><p>window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript 文件、CSS 文件或其他资源加载完成。相对于 load 事件，DOMContentLoaded 可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</p><h4 id="readystatechange-事件" tabindex="-1">readystatechange 事件 <a class="header-anchor" href="#readystatechange-事件" aria-label="Permalink to &quot;readystatechange 事件&quot;">​</a></h4><p>readystatechange 事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持 readystatechange 事件的每个对象都有一个 <strong>readyState</strong> 属性，该属性具有一个以下列出的可能的字符串值。</p><ul><li>uninitialized：对象存在并尚未初始化。</li><li>loading：对象正在加载数据。</li><li>loaded：对象已经加载完数据。</li><li>interactive：对象可以交互，但尚未加载完成。</li><li>complete：对象加载完成。</li></ul><h4 id="pageshow-与-pagehide-事件" tabindex="-1">pageshow 与 pagehide 事件 <a class="header-anchor" href="#pageshow-与-pagehide-事件" aria-label="Permalink to &quot;pageshow 与 pagehide 事件&quot;">​</a></h4><p>浏览器的<strong>往返缓存（bfcache，back-forward cache）</strong> 功能用于在使用“前进”和“后退” 按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储 DOM 和 JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。<br> 浏览器提供一些事件把往返缓存的行为暴露出来。</p><p>第一个事件是 pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow 会在 load 事件之后触发；在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。<br> 与 pageshow 对应的事件是 pagehide，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。</p><h4 id="hashchange-事件" tabindex="-1">hashchange 事件 <a class="header-anchor" href="#hashchange-事件" aria-label="Permalink to &quot;hashchange 事件&quot;">​</a></h4><p>hashchange 事件用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息。</p><p>event 对象有两个新属性：<strong>oldURL 和 newURL</strong>。这两个属性分别保存变化前后的 URL，而且是包含散列值的完整 URL。</p><h3 id="设备事件" tabindex="-1">设备事件 <a class="header-anchor" href="#设备事件" aria-label="Permalink to &quot;设备事件&quot;">​</a></h3><p>设备事件可以用于确定用户使用设备的方式。</p><h4 id="orientationchange-事件" tabindex="-1">orientationchange 事件 <a class="header-anchor" href="#orientationchange-事件" aria-label="Permalink to &quot;orientationchange 事件&quot;">​</a></h4><p>orientationchange 事件用于判断用户的设备是处于垂直模式还是水平模式。<br> window 上暴露了 <strong>window.orientation</strong> 属性，它有以下 3 种值之一：0 表示垂直模式，90 表示左转水平模式（主屏幕键在右侧），–90 表示右转水平模式（主屏幕键在左）。</p><h4 id="deviceorientation-事件" tabindex="-1">deviceorientation 事件 <a class="header-anchor" href="#deviceorientation-事件" aria-label="Permalink to &quot;deviceorientation 事件&quot;">​</a></h4><p>deviceorientation 是 DeviceOrientationEvent 规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在 window 上触发。</p><p>设备本身处于 3D 空间即拥有 x 轴、y 轴和 z 轴的坐标系中。如果把设备静止放在水平的表面上，那么三轴的值均为 0，其中，x 轴方向为从设备左侧到右侧，y 轴方向为从设备底部到上部，z 轴方向为从设备背面到正面。</p><p>当 deviceorientation 触发时，event 对象中会包含各个轴相对于设备静置时坐标值的变化，主要是以下 5 个属性。</p><ul><li><strong>alpha</strong>：0~360 范围内的浮点值，表示围绕 z 轴旋转时 y 轴的度数（左右转）。</li><li><strong>beta</strong>：–180~180 范围内的浮点值，表示围绕 x 轴旋转时 z 轴的度数（前后转）。</li><li><strong>gamma</strong>：–90~90 范围内的浮点值，表示围绕 y 轴旋转时 z 轴的度数（扭转）。</li><li><strong>absolute</strong>：布尔值，表示设备是否返回绝对值。</li><li><strong>compassCalibrated</strong>：布尔值，表示设备的指南针是否正确校准。</li></ul><p>基于这些信息，可以随着设备朝向的变化重新组织或修改屏幕上显示的元素。</p><h4 id="devicemotion-事件" tabindex="-1">devicemotion 事件 <a class="header-anchor" href="#devicemotion-事件" aria-label="Permalink to &quot;devicemotion 事件&quot;">​</a></h4><p>DeviceOrientationEvent 规范也定义了 devicemotion 事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。</p><p>当 devicemotion 事件触发时，event 对象中包含如下额外的属性。</p><ul><li><strong>acceleration</strong>：对象，包含 x、y 和 z 属性，反映不考虑重力情况下各个维度的加速信息。</li><li><strong>accelerationIncludingGravity</strong>：对象，包含 x、y 和 z 属性，反映各个维度的加速信息，包含 z 轴自然重力加速度。</li><li><strong>interval</strong>：毫秒，距离下次触发 devicemotion 事件的时间。此值在事件之间应为常量。</li><li><strong>rotationRate</strong>：对象，包含 alpha、beta 和 gamma 属性，表示设备朝向。</li></ul><h3 id="触摸及手势事件" tabindex="-1">触摸及手势事件 <a class="header-anchor" href="#触摸及手势事件" aria-label="Permalink to &quot;触摸及手势事件&quot;">​</a></h3><p>WebKit 也为 Android 定制了很多专有事件，成为了事实标准，并被纳入 W3C 的 Touch Events 规范。事件只适用于触屏设备。</p><h4 id="触摸事件" tabindex="-1">触摸事件 <a class="header-anchor" href="#触摸事件" aria-label="Permalink to &quot;触摸事件&quot;">​</a></h4><p>当手指放在屏幕上、在屏幕上滑动或从屏幕移开时，触摸事件即会触发。</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>touchstart</td><td>手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</td><td>可用于检测用户的初始触摸动作，适用于启动拖拽、滑动或点击等交互操作。</td></tr><tr><td>touchmove</td><td>手指在屏幕上滑动时连续触发。</td><td>常用于实现手势控制的滚动、缩放或绘制等功能。</td></tr><tr><td>touchend</td><td>手指从屏幕上移开时触发。</td><td>标识用户结束了触摸操作，可以用来完成一次点击、拖拽或滑动手势。</td></tr><tr><td>touchcancel</td><td>系统停止跟踪触摸时触发。</td><td>通常用于清理资源或取消当前正在进行的操作，特别是在意外情况下（如来电）中断用户的触摸操作。</td></tr></tbody></table><p>每个触摸事件的 event 对象都提供了鼠标事件的公共属性：<strong>bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey 和 metaKey。</strong></p><p>除了这些公共的 DOM 属性，触摸事件还提供了以下 3 个属性用于跟踪触点。</p><ul><li>touches：Touch 对象的数组，表示当前屏幕上的每个触点。</li><li>targetTouches：Touch 对象的数组，表示特定于事件目标的触点。</li><li>changedTouches：Touch 对象的数组，表示自上次用户动作之后变化的触点。</li></ul><p>每个 Touch 对象都包含下列属性。</p><ul><li>clientX：触点在视口中的 x 坐标。</li><li>clientY：触点在视口中的 y 坐标。</li><li>identifier：触点 ID。</li><li>pageX：触点在页面上的 x 坐标。</li><li>pageY：触点在页面上的 y 坐标。</li><li>screenX：触点在屏幕上的 x 坐标。</li><li>screenY：触点在屏幕上的 y 坐标。</li><li>target：触摸事件的事件目标。</li></ul><p>当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：</p><ol><li>touchstart</li><li>mouseover</li><li>mousemove（1 次）</li><li>mousedown</li><li>mouseup</li><li>click</li><li>touchend</li></ol><h4 id="手势事件" tabindex="-1">手势事件 <a class="header-anchor" href="#手势事件" aria-label="Permalink to &quot;手势事件&quot;">​</a></h4><p>手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下 3 种：</p><table tabindex="0"><thead><tr><th>事件</th><th>触发条件</th><th>应用场景</th></tr></thead><tbody><tr><td>gesturestart</td><td>一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。</td><td>可用于启动多点触控操作，如缩放、旋转等。</td></tr><tr><td>gesturechange</td><td>任何一个手指在屏幕上的位置发生变化时触发。</td><td>常用于实现动态调整界面元素的功能，比如在地图应用中通过双指滑动来旋转地图视角，或者在绘画应用中改变画笔的粗细。</td></tr><tr><td>gestureend</td><td>其中一个手指离开屏幕时触发。</td><td>标识手势操作结束，可用于完成特定的手势动作并执行相应的响应。</td></tr></tbody></table><p>只有在两个手指同时接触事件接收者时，这些事件才会触发。</p><p>触摸事件和手势事件存在一定的关系。当一个手指放在屏幕上时，会触发 touchstart 事件。当另一个手指放到屏幕上时，gesturestart 事件会首先触发，然后紧接着触发这个手指的 touchstart 事件。如果两个手指或其中一个手指移动，则会触发 gesturechange 事件。只要其中一个手指离开屏幕，就会触发 gestureend 事件，紧接着触发该手指的 touchend 事件。</p><p>新增的两个 event 对象属性是 <strong>rotation 和 scale</strong>。<br> rotation 属性表示手指变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从 0 开始）。<br> scale 属性表示两指之间距离变化（对捏）的程度。开始时为 1，然后随着距离增大或缩小相应地增大或缩小。</p><h2 id="内存与性能" tabindex="-1">内存与性能 <a class="header-anchor" href="#内存与性能" aria-label="Permalink to &quot;内存与性能&quot;">​</a></h2><h3 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h3><p>“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;outBox&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;outBox&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.target; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取实际点击的元素对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.id) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		  //</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		  break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			//</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>事件委托具有如下优点：</p><ul><li>document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。</li><li>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也可以节省时间。</li><li>减少整个页面所需的内存，提升整体性能。</li></ul><p>最适合使用事件委托的事件包括：click、mousedown、mouseup、keydown 和 keypress。</p><h3 id="删除事件处理程序" tabindex="-1">删除事件处理程序 <a class="header-anchor" href="#删除事件处理程序" aria-label="Permalink to &quot;删除事件处理程序&quot;">​</a></h3><p>把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。这种联系建立得越多，页面性能就越差。</p><ol><li>被 removeChild() 或 replaceChild() 删除、被 innerHTML 删除的元素上如果有事件处理程序，不会被垃圾收集程序正常清理。</li><li>另一个可能导致内存中残留引用的问题是页面卸载。</li></ol><p>很有可能元素的引用和事件处理程序的引用都会残留在内存中。如果知道某个元素会被删除，那么最好在删除它之前手工删除它的事件处理程序</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.onclick </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除事件处理程序</span></span></code></pre></div><h2 id="模拟-dom-事件" tabindex="-1">模拟 DOM 事件 <a class="header-anchor" href="#模拟-dom-事件" aria-label="Permalink to &quot;模拟 DOM 事件&quot;">​</a></h2><p>任何时候，都可以使用 <code>document.createEvent()</code> 方法创建一个 event 对象。</p><blockquote><p>[!example]+ document.createEvent</p><p><code>document.createEvent(type)</code> 方法用于创建一个指定类型的事件对象。</p><ul><li>type: 字符串，表示要创建的事件类型。常见类型包括： <ul><li><code>&quot;UIEvents&quot;</code>：用户界面事件，例如 &#39;load&#39; 或者 &#39;resize&#39;。</li><li><code>&quot;MouseEvents&quot;</code>：鼠标事件，例如 &#39;click&#39; 或者 &#39;mouseover&#39;。</li><li><code>&quot;HTMLEvents&quot;</code>：HTML 元素上的标准事件。</li><li><code>&quot;KeyboardEvents&quot;</code>：键盘事件，例如 &#39;keydown&#39; 或者 &#39;keypress&#39;。</li><li><code>&quot;CustomEvent&quot;</code>：自定义事件。</li></ul></li></ul><p>返回值: 一个新的事件对象，可以对其进行初始化并分派到文档中的某个节点上。</p><p>注意点：</p><ul><li>在现代浏览器中，推荐使用更具体的事件构造函数（例如 <code>new MouseEvent()</code>, <code>new CustomEvent()</code>）代替 <code>document.createEvent()</code>。</li></ul></blockquote><p>创建 event 对象之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法，可以使用相应数据来完成初始化。</p><p>事件模拟的最后一步是触发事件。为此要使用 <code>dispatchEvent()</code> 方法。</p><h4 id="模拟鼠标事件" tabindex="-1">模拟鼠标事件 <a class="header-anchor" href="#模拟鼠标事件" aria-label="Permalink to &quot;模拟鼠标事件&quot;">​</a></h4><p>要创建鼠标 event 对象，可以调用 createEvent() 方法并传入 &quot;MouseEvents&quot; 参数。这样就会返回一个 event 对象，这个对象有一个 initMouseEvent() 方法，用于为新对象指定鼠标的特定信息。<code>initMouseEvent()</code> 方法接收 15 个参数，分别对应鼠标事件会暴露的属性。这些参数列举如下。</p><ul><li>type（字符串）：要触发的事件类型，如 &quot;click&quot;。</li><li>bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为 true。</li><li>cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。</li><li>view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li><li>detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。</li><li>screenX（整数）：事件相对于屏幕的 x 坐标。</li><li>screenY（整数）：事件相对于屏幕的 y 坐标。</li><li>clientX（整数）：事件相对于视口的 x 坐标。</li><li>clientY（整数）：事件相对于视口的 y 坐标。</li><li>ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。</li><li>altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。</li><li>shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。</li><li>metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。</li><li>button（整数）：表示按下了哪个按钮。默认为 0。</li><li>relatedTarget（对象）：与事件相关的对象。只在模拟 mouseover 和 mouseout 时使用。</li></ul><p>event 对象的 target 属性会自动设置为调用 <code>dispatchEvent()</code> 方法时传入的节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> btn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myBtn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建event 对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MouseEvents&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始化event 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initMouseEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, document.defaultView,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event);</span></span></code></pre></div><h4 id="模拟键盘事件" tabindex="-1">模拟键盘事件 <a class="header-anchor" href="#模拟键盘事件" aria-label="Permalink to &quot;模拟键盘事件&quot;">​</a></h4><p>在 DOM3 中创建键盘事件的方式是给 createEvent() 方法传入参数 &quot;KeyboardEvent&quot;。这样会返回一个 event 对象，这个对象有一个 initKeyboardEvent() 方法。这个方法接收以下参数。</p><ul><li>type（字符串）：要触发的事件类型，如 &quot;keydown&quot;。</li><li>bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。</li><li>cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。</li><li>view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li><li>key（字符串）：按下按键的字符串代码。</li><li>location（整数）：按下按键的位置。0 表示默认键，1 表示左边，2 表示右边，3 表示数字键盘，4 表示移动设备（虚拟键盘），5 表示游戏手柄。</li><li>modifiers（字符串）：空格分隔的修饰键列表，如 &quot;Shift&quot;。</li><li>repeat（整数）：连续按了这个键多少次。</li></ul><p>键盘事件也可以通过调用 <code>dispatchEvent()</code> 并传入 event 对象来触发。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textbox </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myTextbox&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;KeyboardEvent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始化event 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initKeyboardEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keydown&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, document.defaultView, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Shift&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">textbox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event);</span></span></code></pre></div><h4 id="自定义-dom-事件" tabindex="-1">自定义 DOM 事件 <a class="header-anchor" href="#自定义-dom-事件" aria-label="Permalink to &quot;自定义 DOM 事件&quot;">​</a></h4><p>DOM3 增加了自定义事件的类型。自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的事件。要创建自定义事件， 需要调用 createEvent(&quot;CustomEvent&quot;) 。返回的对象包含 initCustomEvent() 方法，该方法接收以下 4 个参数。</p><ul><li>type（字符串）：要触发的事件类型，如 &quot;myevent&quot;。</li><li>bubbles（布尔值）：表示事件是否冒泡。</li><li>cancelable（布尔值）：表示事件是否可以取消。</li><li>detail（对象）：任意值。作为 event 对象的 detail 属性。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CustomEvent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initCustomEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myevent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myevent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DIV: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.detail);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//同步触发</span></span></code></pre></div>`,184)]))}const b=n(p,[["render",k]]);export{F as __pageData,b as default};
