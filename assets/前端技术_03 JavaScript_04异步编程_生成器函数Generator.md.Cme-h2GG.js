import{_ as i,c as a,o as e,ae as n}from"./chunks/framework.CIivgcbp.js";const l="/obsidian-vitepress-docs/assets/Pasted%20image%2020231021225711.C1J_3bAC.png",E=JSON.parse('{"title":"生成器函数 Generator","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/04异步编程/生成器函数Generator.md","filePath":"前端技术/03 JavaScript/04异步编程/生成器函数Generator.md"}'),t={name:"前端技术/03 JavaScript/04异步编程/生成器函数Generator.md"};function r(h,s,p,k,o,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="生成器函数-generator" tabindex="-1">生成器函数 Generator <a class="header-anchor" href="#生成器函数-generator" aria-label="Permalink to &quot;生成器函数 Generator&quot;">​</a></h1><h1 id="一、基本概念" tabindex="-1">一、基本概念 <a class="header-anchor" href="#一、基本概念" aria-label="Permalink to &quot;一、基本概念&quot;">​</a></h1><ul><li>Generator</li></ul><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。<br> Generator 函数是一个状态机，封装了多个内部状态。<br> 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的<strong>遍历器对象</strong>(Iterator)，可以依次遍历 Generator 函数内部的每一个状态。<br> 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code> 关键字与函数名之间有一个星号；二是，函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态（<code>yield</code> 在英语里的意思就是“产出”）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> helloWorldGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  yield</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  yield</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ending&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> helloWorldGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// hw相当于一个iterator</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hw.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li><p>yield 表达式<br> yield 是一种暂停标志。<br> 遇到 yield 时，会暂停后面的操作，并返回 value 为表达式值，done 为 false 的 <code>IteratorResult</code> 对象。只有当<strong>遍历器对象</strong>(Iterator) 的 next 方法执行，才会继续下一个 yield。<br> 最后使用 return 语句表示结束，返回 value 为表达式值，done 为 true 的 <code>IteratorResult</code> 对象。</p></li><li><p>yield* 表达式<br> 在一个 Generator 函数里面执行另一个 Generator 函数</p></li></ul><h1 id="二、next、return、throw" tabindex="-1">二、next、return、throw <a class="header-anchor" href="#二、next、return、throw" aria-label="Permalink to &quot;二、next、return、throw&quot;">​</a></h1><p>next、return、throw 是 Generator 返回 Iterator 对象的三个方法，通常自行构建 Iterator 对象时 next、return、throw 是需要自行配置的，而 Generator 函数帮助我们实现了它们。<br> 生成器函数外部正是通过这三个方法去控制生成器函数的内部执行过程的。</p><ol><li><strong>next()</strong><br> 作用：next 方法可以想象成在生成器函数中，执行到下一个 yield 或 return 的一个过程。它首先将当前 yield 表达式的返回值更改（首次 next 的传参无意义），再执行生成器函数的代码至下一个 yield。 <ul><li>参数： <ol><li>一个参数，这个参数会被当作当前 <code>yield</code> 表达式的返回值。</li><li>无参数，当前 <code>yield</code> 表达式返回值设为 <code>undefined</code></li></ol></li><li>返回值：下一个 yield 的 <code>IteratorResult</code> 对象<br><code>{value://下个yield表达式返回值，done://yield为false,return为true}</code><br><img src="`+l+`" alt="Pasted image 20231021225711.png"></li></ul></li><li><strong>return()</strong><ul><li>作用：结束生成器函数的执行。</li><li>参数： <ol><li>一个参数，这个参数会被当作 <code>IteratorResult</code> 对象的 value 值。</li><li>无参数，value 值为 <code>undefined</code></li></ol></li><li>返回值：<code>IteratorResult</code> 对象，done 为 true</li></ul></li><li><strong>throw()</strong><ul><li>作用：生成器函数中抛出一个错误，会被 <code>catch</code> 语句捕获，接着恢复生成器的执行。</li><li>参数： <ol><li>一个参数，相当于错误参数 err。</li><li>无参数，err 为 <code>undefined</code></li></ol></li><li>返回值：下一个 yield 的 <code>IteratorResult</code> 对象</li><li>需要注意的是如果生成器函数内部没有 <code>catch</code> 到，则会在外部 <code>catch</code> 到，如果外部也没有 <code>catch</code> 到，则会像所有未捕获的错误一样导致程序终止执行。</li></ul></li></ol><h1 id="三、应用" tabindex="-1">三、应用 <a class="header-anchor" href="#三、应用" aria-label="Permalink to &quot;三、应用&quot;">​</a></h1><ol><li>异步操作的同步化表达</li><li>控制流管理</li><li>部署 Iterator 接口</li><li>作为数据结构</li></ol><h1 id="四、自动执行机制与-co-模块" tabindex="-1">四、自动执行机制与 co 模块 <a class="header-anchor" href="#四、自动执行机制与-co-模块" aria-label="Permalink to &quot;四、自动执行机制与 co 模块&quot;">​</a></h1><ul><li>为什么需要自动执行机制？</li></ul><p>Generator 就是一个异步操作的容器，当我们需要不断的执行其中的代码时，它就需要不停的 next 语句和异步成功或失败判断与处理。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>从代码可以看出，我们需要对 Generator 函数的流程管理是比较麻烦的。因此我们可以结合 Promise 或者 Thunk 进行自动管理。以 Promise 为例，当异步返回的 Promise 为 resolve 或 reject 时，剩余的代码会被 then 方法接管并往下执行。</p><ul><li>co 模块</li></ul><p>是一个用于 Generator 函数的自动执行的模块。<br> co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 <code>yield</code> 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。</p><p>co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> co </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;co&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//引入co模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">co</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gen);                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//自动执行gen</span></span></code></pre></div>`,20)]))}const g=i(t,[["render",r]]);export{E as __pageData,g as default};
