import{_ as t,c as l,o as e,ag as a}from"./chunks/framework.-ewJmwvT.js";const k=JSON.parse('{"title":"12_ 路由","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/08 React/12_路由.md","filePath":"前端技术/08 React/12_路由.md"}'),s={name:"前端技术/08 React/12_路由.md"};function o(n,i,h,c,d,p){return e(),l("div",null,i[0]||(i[0]=[a(`<h1 id="_12-路由" tabindex="-1">12_ 路由 <a class="header-anchor" href="#_12-路由" aria-label="Permalink to &quot;12_ 路由&quot;">​</a></h1><h2 id="一、什么是-spa" tabindex="-1">一、什么是 SPA? <a class="header-anchor" href="#一、什么是-spa" aria-label="Permalink to &quot;一、什么是 SPA?&quot;">​</a></h2><ol><li>单页 Web 应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>。</li><li>点击页面中的链接<strong>不会刷新页面</strong>，只会做页面的<strong>局部更新</strong>。</li><li>数据都需要通过 ajax 请求获取, 并在前端异步展现。</li></ol><h2 id="二、什么是路由" tabindex="-1">二、什么是路由？ <a class="header-anchor" href="#二、什么是路由" aria-label="Permalink to &quot;二、什么是路由？&quot;">​</a></h2><ol><li>一个路由就是一个映射关系 (<code>key:value</code>)</li><li>key 为路径, value 可能是 function 或 component</li></ol><ul><li><p>路由分类</p><ol><li>后端路由：<br> 理解： value 是 function, 用来处理客户端提交的请求。<br> 注册路由： <code>router.get(path, function(req, res))</code><br> 工作过程：当 node 接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</li><li>前端路由：<br> 浏览器端路由，value 是 component，用于展示页面内容。<br> 注册路由:</li></ol><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Route path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Test}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>工作过程：当浏览器的 path 变为 /test 时, 当前路由组件就会变为 Test 组件</p></li><li><p>路由模式</p><ol><li>直接使用 H5 推出 history 的 API</li><li>hash 模式（锚点，带#）</li></ol></li></ul><h2 id="三、react-router" tabindex="-1">三、React Router <a class="header-anchor" href="#三、react-router" aria-label="Permalink to &quot;三、React Router&quot;">​</a></h2><p>对比 vue3 的 <a href="./../07 Vue/VueRouter/VueRouter.html">../07 Vue/VueRouter</a></p><ul><li>react-router-dom: react 的一个插件库，专门用来实现一个 SPA 应用，基于 react 的项目基本都会用到此库。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">库</p><p><a href="https://reactrouter.com/en/main/start/tutorial" target="_blank" rel="noreferrer">React Router Tutorial v6.21.1</a></p></div><ul><li><p>基本使用 (@5 版本)</p><ol><li>明确好界面中的导航区、展示区</li><li>导航区的 a 标签改为 Link 标签</li></ol><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Link to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/xxxxx&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Demo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Link</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><ol start="3"><li><code>&lt;App&gt;</code> 的最外侧包裹了一个 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code></li><li>展示区写 Route 标签进行路径的匹配</li></ol><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Route path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/xxxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Demo}</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/&gt;</span></span></code></pre></div></li><li><p>路由组件与一般组件</p><ol><li>写法不同： <ul><li>一般组件：<code>&lt;Demo/&gt;</code></li><li>路由组件：<code>&lt;Route path=&quot;/demo&quot; component={Demo}/&gt;</code> <code>&lt;Route path=&quot;/demo&quot; component={Demo}/&gt;</code></li></ul></li><li>存放位置不同： <ul><li>一般组件：components</li><li>路由组件：pages</li></ul></li><li>接收到的 props 不同： <ul><li><p>一般组件：写组件标签时传递了什么，就能收到什么</p></li><li><p>路由组件：接收到三个固定的属性</p><ol><li>history:</li></ol><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ƒ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n)  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	goBack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ƒ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">goBack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	goForward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ƒ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">goForward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ƒ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, state)  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ƒ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, state)</span></span></code></pre></div><ol start="2"><li>location:<br><code>pathname: &quot;/about&quot;</code><br><code>search: &quot;&quot;</code><br><code>state: undefined</code></li><li>match:<br><code>params: {}</code><br><code>path: &quot;/about&quot;</code><br><code>url: &quot;/about&quot;</code></li></ol></li></ul></li></ol></li></ul><h2 id="四、路由内置组件" tabindex="-1">四、路由内置组件 <a class="header-anchor" href="#四、路由内置组件" aria-label="Permalink to &quot;四、路由内置组件&quot;">​</a></h2><ul><li><p>常用的内置组件</p><ol><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;Route&gt;</code></li><li><code>&lt;Redirect&gt;</code></li><li><code>&lt;Link&gt;</code></li><li><code>&lt;NavLink&gt;</code></li><li><code>&lt;Switch&gt;</code></li></ol></li><li><p>其它组件对象</p><ol><li>history 对象</li><li>match 对象</li><li>withRouter 函数</li></ol></li><li><p>NavLink 组件</p><ul><li>一个特殊版本的 Link，当它与当前 URL 匹配时，为其渲染元素添加样式属性。</li><li>NavLink 可以实现路由链接的高亮，通过 <code>activeClassName</code> 指定样式名。</li><li>属性： <ol><li><code>activeClassName: string</code></li><li><code>activeStyle: object</code></li><li><code>exact: bool</code></li><li><code>strict: bool</code></li><li><code>isActive: func</code></li><li><code>location: object</code></li></ol></li><li>NavLink 的封装：套一层普通组件，通过 props 传递 to 和 chirdren 等属性，使用 <code>{...this.props}</code> 解构所有属性。</li></ul></li><li><p>Switch 组件</p><ul><li>渲染与该地址匹配的第一个子节点 <code>&lt;Route&gt;</code> 或者 <code>&lt;Redirect&gt;</code>。</li><li>适用于<strong>单对单</strong>的路由匹配，适用 Switch 进行包裹，以节省性能。</li><li>属性： <ol><li><code>location: object</code></li><li><code>children: node</code></li></ol></li></ul></li></ul><blockquote><p>[!tips]+ 解决多级路径刷新页面导致的请求路径错误问题</p><ol><li>public/index.html 中 引入样式时不写 <code>./</code> 写 <code>/</code>（常用）</li><li>public/index.html 中 引入样式时不写 <code>./</code> 写 <code>%PUBLIC_URL%/</code>（常用）</li><li>使用 HashRouter</li></ol></blockquote><h2 id="五、匹配模式" tabindex="-1">五、匹配模式 <a class="header-anchor" href="#五、匹配模式" aria-label="Permalink to &quot;五、匹配模式&quot;">​</a></h2><ul><li>默认使用的是模糊匹配（导航路径包含匹配路径）。</li><li>==exact 完全匹配==，只有在路径完全匹配 <code>location.pathname</code> 时才匹配，开启严格匹配需要添加 exact 属性为 true。<br> 示例：<code>&lt;Route exact path=&#39;&#39; component={Home}/&gt;</code></li><li>==strict 严格匹配==，当真实的路径具有一个斜线将只匹配一个斜线 <code>location.pathname</code>，如果有更多的 URL 段 <code>location.pathname</code> ，将不起作用。<br> 示例：<code>&lt;Route strict path=&#39;&#39; component={Home}/&gt;</code></li></ul><h2 id="六、redirect-的使用" tabindex="-1">六、Redirect 的使用 <a class="header-anchor" href="#六、redirect-的使用" aria-label="Permalink to &quot;六、Redirect 的使用&quot;">​</a></h2><ul><li>渲染 <code>&lt;Redirect&gt;</code> 将使导航到一个新的地址。这个新的地址会覆盖 history 栈中的当前地址，类似服务器端（HTTP 3xx）的重定向。</li><li>属性： <ol><li><code>to: string</code></li><li><code>to: object</code></li><li><code>push: bool</code>（当 true 时，重定向会将新地址推入 history 中，而不是替换当前地址。）</li><li><code>from: string</code>（重定向 from 的路径名。）</li><li><code>exact: bool</code></li><li><code>strict: bool</code></li></ol></li><li>示例：<code>&lt;Redirect from=&quot;/&quot; to=&#39;/About&#39;/&gt;</code></li></ul><h2 id="七、嵌套路由" tabindex="-1">七、嵌套路由 <a class="header-anchor" href="#七、嵌套路由" aria-label="Permalink to &quot;七、嵌套路由&quot;">​</a></h2>`,19)]))}const u=t(s,[["render",o]]);export{k as __pageData,u as default};
