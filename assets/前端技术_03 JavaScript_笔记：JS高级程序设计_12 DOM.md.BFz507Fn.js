import{_ as s,a as e,b as t,c as a,d as l,e as n,f as o,g as d}from"./chunks/12 DOM-8.D2W5_boN.js";import{_ as h,c as p,o as r,ag as k}from"./chunks/framework.-ewJmwvT.js";const v=JSON.parse('{"title":"12 DOM","description":"","frontmatter":{},"headers":[],"relativePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/12 DOM.md","filePath":"前端技术/03 JavaScript/笔记：JS高级程序设计/12 DOM.md"}'),c={name:"前端技术/03 JavaScript/笔记：JS高级程序设计/12 DOM.md"};function E(g,i,u,y,b,m){return r(),p("div",null,i[0]||(i[0]=[k('<h1 id="_12-dom" tabindex="-1">12 DOM <a class="header-anchor" href="#_12-dom" aria-label="Permalink to &quot;12 DOM&quot;">​</a></h1><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。</p><h2 id="一、节点层级" tabindex="-1">一、节点层级 <a class="header-anchor" href="#一、节点层级" aria-label="Permalink to &quot;一、节点层级&quot;">​</a></h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。<br><img src="'+s+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-1.png"><br> document 节点表示每个文档的根节点，称之为<strong>文档元素（documentElement）</strong><br> HTML 中的每段标记都可以表示为这个树形结构中的一个节点。==DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。==</p><h3 id="node-类型" tabindex="-1">Node 类型 <a class="header-anchor" href="#node-类型" aria-label="Permalink to &quot;Node 类型&quot;">​</a></h3><p>在 JavaScript 中，所有节点类型都继承 Node 类型。</p><p>每个节点都有 <strong>nodeType</strong> 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：</p><ul><li>Node.ELEMENT_NODE（1）</li><li>Node.ATTRIBUTE_NODE（2）</li><li>Node.TEXT_NODE（3）</li><li>Node.CDATA_SECTION_NODE（4）</li><li>Node.ENTITY_REFERENCE_NODE（5）</li><li>Node.ENTITY_NODE（6）</li><li>Node.PROCESSING_INSTRUCTION_NODE（7）</li><li>Node.COMMENT_NODE（8）</li><li>Node.DOCUMENT_NODE（9）</li><li>Node.DOCUMENT_TYPE_NODE（10）</li><li>Node.DOCUMENT_FRAGMENT_NODE（11）</li><li>Node.NOTATION_NODE（12）</li></ul><hr><ul><li><strong>nodeName 与 nodeValue</strong></li></ul><p>nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。（对元素而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null。）</p><h4 id="节点关系" tabindex="-1">节点关系 <a class="header-anchor" href="#节点关系" aria-label="Permalink to &quot;节点关系&quot;">​</a></h4><p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。<br> 在 HTML 中，<code>&lt;body&gt;</code> 元素是 <code>&lt;html&gt;</code> 元素的子元素，而 <code>&lt;html&gt;</code> 元素则是 <code>&lt;body&gt;</code> 元素的父元素。<code>&lt;head&gt;</code> 元素是 <code>&lt;body&gt;</code> 元素的同胞元素，因为它们有共同的父元素 <code>&lt;html&gt;</code>。</p><p>每个节点都有一个 <strong>childNodes</strong> 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。</p><p>NodeList 对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来。==我们通常说 NodeList 是实时的活动对象，而不是第一次访问时所获得内容的快照。==</p><p>可以使用中括号或使用 <code>item()</code> 方法访问 NodeList 中的元素</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secondChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>每个节点都有一个 <strong>parentNode</strong> 属性，指向其 DOM 树中的父元素。</p><p>childNodes 列表中的每个节点都是同一列表中其他节点的同胞节点。使用 <strong>previousSibling</strong> 和 <strong>nextSibling</strong> 可以在这个列表的节点间导航。</p><p><strong>firstChild</strong> 和 <strong>lastChild</strong> 分别指向 childNodes 中的第一个和最后一个子节点。</p><p><img src="`+e+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-2.png"></p><p><code>hasChildNodes()</code> 方法可以查询一个节点是有否子节点，如果返回 true 则说明节点有一个或多个子节点。</p><p><strong>ownerDocument</strong> 属性是一个指向代表整个文档的文档节点的指针。</p><h4 id="操纵节点" tabindex="-1">操纵节点 <a class="header-anchor" href="#操纵节点" aria-label="Permalink to &quot;操纵节点&quot;">​</a></h4><p>所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。<br><code>appendChild()</code> 方法用于在 childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针。</p><blockquote><p>[!example]+ appendChild</p><p><code>node.appendChild(child)</code> 方法用于将一个节点添加到给定父节点的子节点列表的末尾。</p><ul><li>child: 要添加到 <code>node</code> 的子节点。这个参数可以是一个单独的节点或文档片段（DocumentFragment）。如果传入的是文档片段，那么片段的所有子节点会被添加到目标节点中，而文档片段本身不会被添加。</li></ul><p>返回值: 返回被添加的 <code>child</code> 节点，这允许链式调用方法。</p><p>注意点：</p><ul><li>如果 child 已经存在于文档的其他地方，appendChild 会先将其从原位置移除再添加到新位置。这意味着==每个 DOM 元素在同一时间只能出现在文档的一个位置上。==</li><li>对于大量元素的插入操作，考虑使用 <code>DocumentFragment</code> 来优化性能，因为直接操作 DOM 是相对昂贵的操作，而 <code>DocumentFragment</code> 可以减少重排和重绘。</li></ul></blockquote><p>如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 <code>insertBefore()</code> 方法。</p><blockquote><p>[!example]+ insertBefore</p><p><code>parentNode.insertBefore(newNode, referenceNode)</code> 方法在给定的 <code>referenceNode</code> 之前插入一个新的子节点 newNode。如果 referenceNode 是 null，则 newNode 将被插入到子节点列表的末尾。</p><ul><li>newNode: 要插入的节点。</li><li>referenceNode: 新节点将插入到这个节点之前。如果为 null，则 newNode 将被添加为最后一个子节点。</li></ul><p>返回值: 返回被插入的 <code>newNode</code> 节点。</p><p>注意点：</p><ul><li>如果 newNode 已存在于文档中的其他位置，则它会从原来的位置移除并重新插入到新的位置。</li></ul></blockquote><p><code>replaceChild()</code> 方法可以用于替换节点。</p><blockquote><p>[!example]+ replaceChild</p><p><code>parentNode.replaceChild(newChild, oldChild)</code> 方法用一个新的子节点替换现有的子节点。</p><ul><li>newChild: 用来替换现有子节点的新节点。如果该节点已经存在于文档的其他位置，则它会被首先移除。</li><li>oldChild: 要被替换掉的现有子节点。</li></ul><p>返回值: 返回被替换掉的 <code>oldChild</code> 节点。</p><p>注意点：</p><ul><li>两个参数都必须是同一个父节点的直接子节点，否则会抛出错误。</li><li>此方法不会影响旧节点的内容或状态；它只是改变了 DOM 树中的位置和引用。</li><li>可以用于更新部分页面内容而不必重载整个页面，适用于实现动态内容更新的场景。</li></ul></blockquote><p>要移除节点而不是替换节点，可以使用 <code>removeChild()</code> 方法。</p><blockquote><p>[!example]+ removeChild</p><p><code>parentNode.removeChild(child)</code> 方法从 DOM 中删除一个子节点。一旦被删除，该节点不再属于文档的一部分，并且所有相关的事件监听器也会被移除。</p><ul><li>child: 要从文档中删除的节点。</li></ul><p>返回值: 返回已被删除的 <code>child</code> 节点。</p><p>注意点：</p><ul><li>删除节点并不会自动销毁它；你仍然可以在 JavaScript 中使用该节点对象，但不能再将其作为文档的一部分显示出来。</li><li>适合于需要动态移除页面上的元素的情况，如关闭对话框、删除列表项等。</li></ul></blockquote><p>并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。</p><h4 id="其他方法" tabindex="-1">其他方法 <a class="header-anchor" href="#其他方法" aria-label="Permalink to &quot;其他方法&quot;">​</a></h4><p><code>cloneNode()</code> 方法会返回与调用它的节点一模一样的节点。</p><blockquote><p>[!example]+ cloneNode</p><p><code>node.cloneNode(deep)</code> 方法用于创建一个节点的深层或浅层副本。</p><ul><li>deep: 一个布尔值，指定是否应该执行深拷贝。如果是 true，则克隆包括子节点在内的整个节点树；如果是 false，则仅克隆指定的节点，而不复制任何子节点。</li></ul><p>返回值: 返回克隆的新节点。</p><p>注意点：</p><ul><li>如果 <code>deep</code> 设置为 true，所有的子节点和它们的所有属性都会被复制；但是事件监听器不会自动复制，除非手动重新绑定。</li><li>对于某些类型的节点（例如 <code>&lt;canvas&gt;</code>），可能还需要额外的操作来完全复制其状态。</li><li>在需要复用现有结构但又不想影响原始节点的情况下非常有用。</li></ul></blockquote><p><code>normalize()</code> 方法用于处理文档子树中的文本节点。</p><blockquote><p>[!example]+ normalize</p><p><code>node.normalize()</code> 方法用于清理给定节点下的所有文本节点，确保没有相邻的文本节点，并且所有空的文本节点都被移除。这有助于保持文档结构整洁，尤其是在动态修改 DOM 后。</p><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>主要用于处理由浏览器解析 HTML 文档时产生的多个连续文本节点的情况，将这些文本节点合并成一个单一的文本节点。</li><li>当用户通过 JavaScript 动态地插入或删除文本节点时，可能会导致出现相邻的文本节点，这时使用 <code>normalize</code> 可以帮助维护良好的文档结构。</li></ul></blockquote><h3 id="document-类型" tabindex="-1">Document 类型 <a class="header-anchor" href="#document-类型" aria-label="Permalink to &quot;Document 类型&quot;">​</a></h3><p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例，表示整个 HTML 页面。<br> document 是 window 对象的属性，因此是一个全局对象。</p><p>Document 类型的节点有以下特征：</p><ul><li>nodeType 等于 9；</li><li>nodeName 值为 &quot;#document&quot;；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 null；</li><li>ownerDocument 值为 null；</li><li>子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment 类型。</li></ul><h4 id="文档子节点" tabindex="-1">文档子节点 <a class="header-anchor" href="#文档子节点" aria-label="Permalink to &quot;文档子节点&quot;">​</a></h4><p><strong>documentElement</strong> 属性，始终指向 HTML 页面中的 <code>&lt;html&gt;</code> 元素。<br><strong>body</strong> 属性，直接指向 <code>&lt;body&gt;</code> 元素。</p><p><code>&lt;!doctype&gt;</code> 标签是文档中独立的部分，其信息可以通过 <strong>doctype</strong> 属性来访问。</p><h4 id="文档信息" tabindex="-1">文档信息 <a class="header-anchor" href="#文档信息" aria-label="Permalink to &quot;文档信息&quot;">​</a></h4><p><strong>title</strong>：读取文档标题<br><strong>URL</strong>：当前页面的完整 URL（地址栏中的 URL）<br><strong>domain</strong>：页面的域名<br><strong>referrer</strong>：链接到当前页面的那个页面的 URL</p><h4 id="定位元素" tabindex="-1">定位元素 <a class="header-anchor" href="#定位元素" aria-label="Permalink to &quot;定位元素&quot;">​</a></h4><p>DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。</p><blockquote><p>[!example]+ getElementById</p><p><code>document.getElementById(id)</code> 方法返回具有指定 ID 的元素。</p><ul><li>id: 要查找的元素的唯一标识符。ID 必须在文档中是唯一的；如果有多个相同 ID 的元素，仅返回第一个匹配的元素。</li></ul><p>返回值: 拥有指定 ID 的元素对象。如果没有找到对应的元素，则返回 <code>null</code>。</p><p>注意点：</p><ul><li>参数 ID 必须跟元素在页面中的 id 属性值完全匹配，包括大小写。</li></ul></blockquote><blockquote><p>[!example]+ getElementsByTagName</p><p><code>element.getElementsByTagName(tagName)</code> 方法返回一个实时的 <code>HTMLCollection</code>，包含了所有指定标签名的子元素。如果没有任何匹配的元素，则返回一个空的 <code>HTMLCollection</code>。</p><ul><li>tagName: 要查找的元素标签名。特殊值 <code>*</code> 可以用来选择所有元素。</li></ul><p>返回值: 包含所有匹配元素的 <code>HTMLCollection</code> 对象。</p><p>注意点：</p><ul><li>返回的 <code>HTMLCollection</code> 是实时的，这意味着它会随着文档的变化而自动更新。</li><li>如果需要遍历或操作一组同类型的元素，这是非常有用的方法。</li><li>不区分标签名的大小写，因此 &quot;DIV&quot; 和 &quot;div&quot; 都会被视为相同的标签名。</li></ul></blockquote><blockquote><p>[!example]+ getElementsByName</p><p><code>document.getElementsByName(name)</code> 方法返回一个实时的 <code>NodeList</code>，包含了文档中所有带有指定名称（name 属性）的元素。由于多个元素可以共享同一个名称，因此该方法总是返回一个集合，即使只有一个匹配项。</p><ul><li>name: 要查找的元素的 <code>name</code> 属性值。</li></ul><p>返回值: 一个实时的 <code>NodeList</code> 集合，包含所有具有指定名称的元素。如果没有找到匹配的元素，则返回一个空的 <code>NodeList</code>。</p><p>注意点：</p><ul><li>此方法在 HTML 文档中主要用于表单元素（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;button&gt;</code> 等），因为它们通常会使用 name 属性来标识自己或作为提交数据的一部分。</li></ul></blockquote><h4 id="htmlcollection" tabindex="-1">HTMLCollection <a class="header-anchor" href="#htmlcollection" aria-label="Permalink to &quot;HTMLCollection&quot;">​</a></h4><p>HTMLCollection 对象与 NodeList 对象类似，也可以使用中括号或 <code>item()</code> 方法得特定的元素。元素的数量同样可以通过 <strong>length</strong> 属性得知。</p><p>HTMLCollection 对象还有一个额外的方法 <code>namedItem()</code>，可通过标签的 name 属性取得某一项的引用。对于 name 属性的元素，还可以直接使用中括号来获取。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myimage.gif&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myImage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let myImage = images.namedItem(&quot;myImage&quot;);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let myImage = images[&quot;myImage&quot;];</span></span></code></pre></div><p>document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是<br> 访问文档中公共部分的快捷方式，列举如下。</p><ul><li><strong>document.anchors</strong> 包含文档中所有带 name 属性的 <code>&lt;a&gt;</code> 元素。</li><li><strong>document.forms</strong> 包含文档中所有 <code>&lt;form&gt;</code> 元素</li><li><strong>document.images</strong> 包含文档中所有 <code>&lt;img&gt;</code> 元素</li><li><strong>document.links</strong> 包含文档中所有带 href 属性的 <code>&lt;a&gt;</code> 元素。</li></ul><h4 id="dom-兼容性检测" tabindex="-1">DOM 兼容性检测 <a class="header-anchor" href="#dom-兼容性检测" aria-label="Permalink to &quot;DOM 兼容性检测&quot;">​</a></h4><p><strong>document.implementation</strong> 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。</p><p>它有一个方法，<code>hasFeature()</code>。<code>hasFeature()</code> 接收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则返回 true。</p><table tabindex="0"><thead><tr><th>特性</th><th>支持的版本</th><th>说明</th></tr></thead><tbody><tr><td>Core</td><td>1.0、2.0、3.0</td><td>定义树形文档结构的基本 DOM</td></tr><tr><td>XML</td><td>1.0、2.0、3.0</td><td>Core 的 XML 扩展，增加了对 CDATA 区块、处理指令和实体的支持</td></tr><tr><td>HTML</td><td>1.0、2.0</td><td>XML 的 HTML 扩展，增加了 HTML 特定的元素和实体</td></tr><tr><td>Views</td><td>2.0</td><td>文档基于某些样式的实现格式</td></tr><tr><td>StyleSheets</td><td>2.0</td><td>文档的相关样式表</td></tr><tr><td>CSS</td><td>2.0</td><td>Cascading Style Sheets Level 1</td></tr><tr><td>CSS2</td><td>2.0</td><td>Cascading Style Sheets Level 2</td></tr><tr><td>Events</td><td>2.0、3.0</td><td>通用 DOM 事件</td></tr><tr><td>UIEvents</td><td>2.0、3.0</td><td>用户界面事件</td></tr><tr><td>TextEvents</td><td>3.0</td><td>文本输入设备触发的事件</td></tr><tr><td>MouseEvents</td><td>2.0、3.0</td><td>鼠标导致的事件（单击、悬停等）</td></tr><tr><td>MutationEvents</td><td>2.0、3.0</td><td>DOM 树变化时触发的事件</td></tr><tr><td>MutationNameEvents</td><td>3.0</td><td>DOM 元素或元素属性被重命名时触发的事件</td></tr><tr><td>HTMLEvents</td><td>2.0</td><td>HTML 4.01 事件</td></tr><tr><td>Range</td><td>2.0</td><td>在 DOM 树中操作一定范围的对象和方法</td></tr><tr><td>Traversal</td><td>2.0</td><td>遍历 DOM 树的方法</td></tr><tr><td>LS</td><td>3.0</td><td>文件与 DOM 树之间的同步加载与保存</td></tr><tr><td>LS-Async</td><td>3.0</td><td>文件与 DOM 树之间的异步加载与保存</td></tr><tr><td>Validation</td><td>3.0</td><td>修改 DOM 树并保证其继续有效的方法</td></tr><tr><td>XPath</td><td>3.0</td><td>访问 XML 文档不同部分的语言</td></tr></tbody></table><h4 id="文档写入" tabindex="-1">文档写入 <a class="header-anchor" href="#文档写入" aria-label="Permalink to &quot;文档写入&quot;">​</a></h4><p>document 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：<code>write()</code>、 <code>writeln()</code>、<code>open()</code> 和 <code>close()</code>。</p><p><code>write()</code> 和 <code>writeln()</code> 方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code> 简单地写入文本，而 <code>writeln()</code> 还会在字符串末尾追加一个换行符（\\n）。这两个方法可以用来在页面加载期间向页面中动态添加内容，经常用于动态包含外部资源，如 JavaScript 文件。</p><p><code>open()</code> 和 <code>close()</code> 方法分别用于打开和关闭网页输出流。</p><h3 id="element-类型" tabindex="-1">Element 类型 <a class="header-anchor" href="#element-类型" aria-label="Permalink to &quot;Element 类型&quot;">​</a></h3><p>Element 表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。<br> Element 类型的节点具有以下特征：</p><ul><li>nodeType 等于 1；</li><li>nodeName 值为元素的标签名；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 Document 或 Element 对象；</li><li>子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、 EntityReference 类型。</li></ul><p>可以通过 <strong>nodeName</strong> 或 <strong>tagName</strong> 属性来获取元素的标签名。</p><h4 id="html-元素" tabindex="-1">HTML 元素 <a class="header-anchor" href="#html-元素" aria-label="Permalink to &quot;HTML 元素&quot;">​</a></h4><p>所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。HTMLElement<br> 直接继承 Element 并增加了一些属性。<br> 每个属性都对应下列属性之一，它们是所有 HTML 元素上都有的标准属性：</p><ul><li><strong>id</strong>，元素在文档中的唯一标识符；</li><li><strong>title</strong>，包含元素的额外信息，通常以提示条形式展示；</li><li><strong>lang</strong>，元素内容的语言代码（很少用）；</li><li><strong>dir</strong>，语言的书写方向（&quot;ltr&quot; 表示从左到右，&quot;rtl&quot; 表示从右到左，同样很少用）；</li><li><strong>className</strong>，相当于 class 属性，用于指定元素的 CSS 类（因为 class 是 ECMAScript 关键字，所以不能直接用这个名字）。</li></ul><p>所有 HTML 元素及其对应的类型（斜体表示已经废弃的元素）。<br><img src="`+t+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-3.png"><br><img src="'+a+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-4.png"></p><h4 id="元素属性" tabindex="-1">元素属性 <a class="header-anchor" href="#元素属性" aria-label="Permalink to &quot;元素属性&quot;">​</a></h4><p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法主要有 3 个：<code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code>。</p><blockquote><p>[!example]+ getAttribute</p><p><code>element.getAttribute(name)</code> 方法返回元素上指定属性的值。</p><ul><li>name: 要检索其值的属性名称。</li></ul><p>返回值: 指定属性的值，如果属性不存在则返回 <code>null</code> 或者空字符串。</p><p>注意点：</p><ul><li>适用于获取任何标准或自定义属性的值，但更推荐使用特定于属性的方法（如 <code>.href</code> 对于 <code>&lt;a&gt;</code> 标签）来访问标准属性，因为它们提供了更好的类型支持和兼容性。</li></ul></blockquote><p>==通过 DOM 对象访问的属性中有两个返回的值跟使用 getAttribute() 取得的值不一样。==首先是 style 属性，这个属性用于为元素设定 CSS 样式。在使用 getAttribute() 访问 style 属性时，返回的是 CSS 字符串。而在通过 DOM 对象的属性访问时，style 属性返回的是一个（CSSStyleDeclaration）对象。</p><blockquote><p>[!example]+ setAttribute</p><p><code>element.setAttribute(name, value)</code> 方法为元素添加一个新属性或更改现有属性的值。</p><ul><li>name: 要设置的属性名称。</li><li>value: 要赋予该属性的新值。</li></ul><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>如果指定的属性已经存在，则更新它的值；如果不存在，则创建一个新的属性并赋值。</li><li>对于一些特殊属性（如 <code>style</code> 或 <code>class</code>），直接使用此方法可能不会总是产生预期的效果，考虑使用特定的 DOM 属性或方法（如 <code>.className</code> 或 <code>.classList</code> 对于类操作）。</li></ul></blockquote><p><code>removeAttribute()</code> 用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉。</p><h4 id="attributes-属性" tabindex="-1">attributes 属性 <a class="header-anchor" href="#attributes-属性" aria-label="Permalink to &quot;attributes 属性&quot;">​</a></h4><p>Element 类型是唯一使用 attributes 属性的 DOM 节点类型。attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。<br> NamedNodeMap 对象包含下列方法：</p><ul><li><code>getNamedItem(name)</code>，返回 nodeName 属性等于 name 的节点；</li><li><code>removeNamedItem(name)</code>，删除 nodeName 属性等于 name 的节点；</li><li><code>setNamedItem(node)</code>，向列表中添加 node 节点，以其 nodeName 为索引；</li><li><code>item(pos)</code>，返回索引位置 pos 处的节点。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getNamedItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).nodeValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.attributes[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].nodeValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;someOtherId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h4 id="创建元素" tabindex="-1">创建元素 <a class="header-anchor" href="#创建元素" aria-label="Permalink to &quot;创建元素&quot;">​</a></h4><p>可以使用 <code>document.createElement()</code> 方法创建新元素。</p><blockquote><p>[!example]+ createElement</p><p><code>document.createElement(tagName[, options])</code> 方法用于创建由指定标签名称的新元素节点。</p><ul><li>tagName: 要创建的元素的标签名。它是一个字符串，代表了新元素的类型。</li><li>options（可选）: 自 HTML5 规范以来引入的一个参数，允许传递一个包含配置选项的对象，例如 <code>{ is: &#39;custom-element&#39; }</code> 用于创建自定义元素。</li></ul><p>返回值: 返回一个新创建的 <code>Element</code> 对象，但该对象尚未被插入到文档树中。</p><p>注意点：</p><ul><li>创建的元素不会自动添加到文档中，需要使用如 <code>appendChild()</code>, <code>insertBefore()</code>, 或者其他类似的方法将其插入到文档的某个位置。</li><li>可以在创建元素后设置其属性、样式、内容等，然后将其插入到页面中，从而实现动态内容更新。</li></ul></blockquote><h3 id="text-类型" tabindex="-1">Text 类型 <a class="header-anchor" href="#text-类型" aria-label="Permalink to &quot;Text 类型&quot;">​</a></h3><p>Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。Text 类型的节点具有以下特征：</p><ul><li>nodeType 等于 3；</li><li>nodeName 值为 &quot;#text&quot;；</li><li>nodeValue 值为节点中包含的文本；</li><li>parentNode 值为 Element 对象；</li><li>不支持子节点。</li></ul><p>Text 节点中包含的文本可以通过 <strong>nodeValue</strong> 属性访问，也可以通过 <strong>data</strong> 属性访问</p><p>文本节点暴露了以下操作文本的方法：</p><ul><li><code>appendData(text)</code>，向节点末尾添加文本 text；</li><li><code>deleteData(offset, count)</code>，从位置 offset 开始删除 count 个字符；</li><li><code>insertData(offset, text)</code>，在位置 offset 插入 text；</li><li><code>replaceData(offset, count, text)</code>，用 text 替换从位置 offset 到 offset + count 的文本；</li><li><code>splitText(offset)</code>，在位置 offset 将当前文本节点拆分为两个文本节点；</li><li><code>substringData(offset, count)</code>，提取从位置 offset 到 offset + count 的文本。<br> 除了这些方法，还可以通过 <strong>length</strong> 属性获取文本节点中包含的字符数量。</li></ul><ol><li><p>创建文本节点<br><code>document.createTextNode()</code> 可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。</p></li><li><p>规范化文本节点<br> 有一个方法可以合并相邻的文本节点。这个方法叫 <code>normalize()</code></p></li><li><p>拆分文本节点<br> Text 类型定义了一个与 <code>normalize()</code> 相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分 nodeValue，将一个文本节点拆分成两个文本节点。</p></li></ol><h3 id="comment-类型" tabindex="-1">Comment 类型 <a class="header-anchor" href="#comment-类型" aria-label="Permalink to &quot;Comment 类型&quot;">​</a></h3><p>DOM 中的注释通过 Comment 类型表示。Comment 类型的节点具有以下特征：</p><ul><li>nodeType 等于 8；</li><li>nodeName 值为 &quot;#comment&quot;；</li><li>nodeValue 值为注释的内容；</li><li>parentNode 值为 Document 或 Element 对象；不支持子节点。</li></ul><p>==Comment 类型与 Text 类型继承同一个基类（CharacterData）==，因此拥有除 splitText() 之外 Text 节点所有的字符串操作方法。</p><p>可以使用 <code>document.createComment()</code> 方法创建注释节点，参数为注释文本。</p><h3 id="documenttype-类型" tabindex="-1">DocumentType 类型 <a class="header-anchor" href="#documenttype-类型" aria-label="Permalink to &quot;DocumentType 类型&quot;">​</a></h3><p>DocumentType 类型的节点包含文档的文档类型（doctype）信息，具有以下特征：</p><ul><li>nodeType 等于 10；</li><li>nodeName 值为文档类型的名称；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 Document 对象；不支持子节点。</li></ul><p>DocumentType 对象在 DOM Level 1 中==不支持动态创建==，只能在解析文档代码时创建。</p><p>DOM Level 1 规定了 DocumentType 对象的 3 个属性：name、entities 和 notations。<br> 其中，<strong>name</strong> 是文档类型的名称，<strong>entities</strong> 是这个文档类型描述的实体的 NamedNodeMap，而 <strong>notations</strong> 是这个文档类型描述的表示法的 NamedNodeMap。</p><h3 id="documentfragment-类型" tabindex="-1">DocumentFragment 类型 <a class="header-anchor" href="#documentfragment-类型" aria-label="Permalink to &quot;DocumentFragment 类型&quot;">​</a></h3><p>在所有节点类型中，DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。DOM 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。<br> DocumentFragment 节点具有以下特征：</p><ul><li>nodeType 等于 11；</li><li>nodeName 值为 &quot;#document-fragment&quot;；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 null；</li><li>子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。</li></ul><p>可以使用 <code>document.createDocumentFragment()</code> 方法创建文档片段</p><h3 id="attr-类型" tabindex="-1">Attr 类型 <a class="header-anchor" href="#attr-类型" aria-label="Permalink to &quot;Attr 类型&quot;">​</a></h3><p>元素数据在 DOM 中通过 Attr 类型表示。Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 attributes 属性中的节点。<br> Attr 节点具有以下特征：</p><ul><li>nodeType 等于 2；</li><li>nodeName 值为属性名；</li><li>nodeValue 值为属性值；</li><li>parentNode 值为 null；</li><li>在 HTML 中不支持子节点；在 XML 中子节点可以是 Text 或 EntityReference。</li></ul><p>==属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。==</p><p>可以使用 <code>document.createAttribute()</code> 方法创建新的 Attr 节点，参数为属性名。</p><h2 id="二、dom-编程" tabindex="-1">二、DOM 编程 <a class="header-anchor" href="#二、dom-编程" aria-label="Permalink to &quot;二、DOM 编程&quot;">​</a></h2><h3 id="动态脚本" tabindex="-1">动态脚本 <a class="header-anchor" href="#动态脚本" aria-label="Permalink to &quot;动态脚本&quot;">​</a></h3><p>动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。<br> 与对应的 HTML 元素一样，有两种方式通过 <code>&lt;script&gt;</code> 动态为网页添加脚本：引入外部文件和直接插入源代码。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;foo.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;function sayHi(){alert(&#39;hi&#39;);}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span></code></pre></div><h3 id="动态样式" tabindex="-1">动态样式 <a class="header-anchor" href="#动态样式" aria-label="Permalink to &quot;动态样式&quot;">​</a></h3><p>CSS 样式在 HTML 页面中可以通过两个元素加载。<code>&lt;link&gt;</code> 元素用于包含 CSS 外部文件，而 <code>&lt;style&gt;</code> 元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> link </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;link&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">link.rel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;stylesheet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">link.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;text/css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">link.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;styles.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;head&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(link);</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">style.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;text/css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">style.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;body{background-color:red}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;head&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(style);</span></span></code></pre></div><h3 id="操作表格" tabindex="-1">操作表格 <a class="header-anchor" href="#操作表格" aria-label="Permalink to &quot;操作表格&quot;">​</a></h3><p>为了方便创建表格，HTML DOM 给 <code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code> 和 <code>&lt;tr&gt;</code> 元素添加了一些属性和方法。<br><code>&lt;table&gt;</code> 元素添加了以下属性和方法：</p><ul><li>caption，指向 <code>&lt;caption&gt;</code> 元素的指针（如果存在）；</li><li>tBodies，包含 <code>&lt;tbody&gt;</code> 元素的 HTMLCollection；</li><li>tFoot，指向 <code>&lt;tfoot&gt;</code> 元素（如果存在）；</li><li>tHead，指向 <code>&lt;thead&gt;</code> 元素（如果存在）；</li><li>rows，包含表示所有行的 HTMLCollection；</li><li>createTHead()，创建 <code>&lt;thead&gt;</code> 元素，放到表格中，返回引用；</li><li>createTFoot()，创建 <code>&lt;tfoot&gt;</code> 元素，放到表格中，返回引用；</li><li>createCaption()，创建 <code>&lt;caption&gt;</code> 元素，放到表格中，返回引用；</li><li>deleteTHead()，删除 <code>&lt;thead&gt;</code> 元素；</li><li>deleteTFoot()，删除 <code>&lt;tfoot&gt;</code> 元素；</li><li>deleteCaption()，删除 <code>&lt;caption&gt;</code> 元素；</li><li>deleteRow(pos)，删除给定位置的行；</li><li>insertRow(pos)，在行集合中给定位置插入一行。</li></ul><p><code>&lt;tbody&gt;</code> 元素添加了以下属性和方法：</p><ul><li>rows，包含 <code>&lt;tbody&gt;</code> 元素中所有行的 HTMLCollection；</li><li>deleteRow(pos)，删除给定位置的行；</li><li>insertRow(pos)，在行集合中给定位置插入一行，返回该行的引用。</li></ul><p><code>&lt;tr&gt;</code> 元素添加了以下属性和方法：</p><ul><li>cells，包含 <code>&lt;tr&gt;</code> 元素所有表元的 HTMLCollection；</li><li>deleteCell(pos)，删除给定位置的表元；</li><li>insertCell(pos)，在表元集合给定位置插入一个表元，返回该表元的引用。</li></ul><h3 id="使用-nodelist" tabindex="-1">使用 NodeList <a class="header-anchor" href="#使用-nodelist" aria-label="Permalink to &quot;使用 NodeList&quot;">​</a></h3><p>==理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。==<br> 这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。</p><h3 id="selectors-api" tabindex="-1">Selectors API <a class="header-anchor" href="#selectors-api" aria-label="Permalink to &quot;Selectors API&quot;">​</a></h3><p>Selectors API 是 W3C 推荐标准，规定了浏览器原生支持的 CSS 查询 API。<br> 核心是两个方法：<code>querySelector()</code> 和 <code>querySelectorAll()</code>。在兼容浏览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。</p><blockquote><p>[!example]+ querySelector</p><p><code>element.querySelector(selectors)</code> 方法返回文档中匹配指定 CSS 选择器的第一个元素。</p><ul><li>selectors: 一个字符串，包含一个或多个 CSS 选择器（如 &quot;#id&quot;, &quot;.class&quot;, &quot;tagName&quot; 等）。可以使用逗号分隔多个选择器来扩展搜索范围。</li></ul><p>返回值: 匹配的第一个元素对象。如果没有找到匹配项，则返回 <code>null</code>。</p><p>注意点：</p><ul><li>非常适合用于快速定位单个元素，特别是当你知道你只需要操作第一个匹配的元素时。</li><li>支持复杂的 CSS 选择器，包括后代选择器、子选择器、相邻兄弟选择器等。</li></ul></blockquote><blockquote><p>[!example]+ querySelectorAll</p><p><code>element.querySelectorAll(selectors)</code> 方法返回一个静态的 <code>NodeList</code>，包含了文档中所有匹配指定 CSS 选择器的元素。如果找不到匹配项，则返回一个空的 <code>NodeList</code>。</p><ul><li>selectors: 一个字符串，包含一个或多个 CSS 选择器（同 <code>querySelector</code>）。</li></ul><p>返回值: 包含所有匹配元素的 <code>NodeList</code> 对象。==这是一个静态集合，意味着它不会随着文档的变化而自动更新。==</p><p>注意点：</p><ul><li><code>NodeList</code> 对象可以通过数组索引或 <code>forEach</code> 方法遍历和操作每个元素。</li><li>与 <code>getElementsByClassName</code> 或 <code>getElementsByTagName</code> 不同，<code>querySelectorAll</code> 返回的是静态列表，而不是实时更新的集合。</li></ul></blockquote><p><code>matches()</code> 方法接收一个 CSS 选择符参数，如果元素匹配则该选择符返回 true，否则返回 false。</p><h3 id="元素遍历" tabindex="-1">元素遍历 <a class="header-anchor" href="#元素遍历" aria-label="Permalink to &quot;元素遍历&quot;">​</a></h3><p>Element Traversal API 为 DOM 元素添加了 5 个属性：</p><ul><li>childElementCount，返回子元素数量（不包含文本节点和注释）；</li><li>firstElementChild，指向第一个 Element 类型的子元素（Element 版 firstChild）；</li><li>lastElementChild，指向最后一个 Element 类型的子元素（Element 版 lastChild）；</li><li>previousElementSibling ， 指向前一个 Element 类型的同胞元素（ Element 版 previousSibling）；</li><li>nextElementSibling，指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。</li></ul><h3 id="html5" tabindex="-1">HTML5 <a class="header-anchor" href="#html5" aria-label="Permalink to &quot;HTML5&quot;">​</a></h3><h4 id="css-类扩展" tabindex="-1">CSS 类扩展 <a class="header-anchor" href="#css-类扩展" aria-label="Permalink to &quot;CSS 类扩展&quot;">​</a></h4><ul><li><code>getElementsByClassName()</code></li></ul><blockquote><p>[!example]+ getElementsByClassName</p><p><code>document.getElementsByClassName(classNames)</code> 方法返回一个实时的 <code>HTMLCollection</code>，包含了文档中所有带有指定类名的元素。</p><ul><li>classNames: 一个字符串，包含一个或多个类名。如果包含多个类名，则必须用空格分隔。只有当元素同时具有所有这些类名时，才会被包括在返回的集合中。</li></ul><p>返回值: 一个实时的 <code>HTMLCollection</code>，包含所有匹配的元素。如果没有找到匹配项，则返回一个空的 <code>HTMLCollection</code>。</p><p>注意点：</p><ul><li>返回的 <code>HTMLCollection</code> 是实时更新的，这意味着如果文档中的元素发生了变化（例如添加或移除了某些类），该集合会自动反映这些更改。</li><li>适合用于快速获取一组具有相同类名的元素，便于批量操作。</li></ul></blockquote><ul><li>classList 属性<br> classList 是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList 也有 <strong>length</strong> 属性表示自己包含多少项，也可以通过 <code>item()</code> 或中括号取得个别的元素。<br> 此外，DOMTokenList 还增加了以下方法。</li><li><code>add(value)</code>，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</li><li><code>contains(value)</code>，返回布尔值，表示给定的 value 是否存在。</li><li><code>remove(value)</code>，从类名列表中删除指定的字符串值 value。</li><li><code>toggle(value)</code>，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</li></ul><h4 id="焦点管理" tabindex="-1">焦点管理 <a class="header-anchor" href="#焦点管理" aria-label="Permalink to &quot;焦点管理&quot;">​</a></h4><p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 <strong>document.activeElement</strong>，始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 <code>focus()</code> 方法）让某个元素自动获得焦点。</p><p>其次是 <code>document.hasFocus()</code> 方法，该方法返回布尔值，表示文档是否拥有焦点。</p><h4 id="htmldocument-扩展" tabindex="-1">HTMLDocument 扩展 <a class="header-anchor" href="#htmldocument-扩展" aria-label="Permalink to &quot;HTMLDocument 扩展&quot;">​</a></h4><ol><li><p>readyState 属性<br><strong>document.readyState</strong> 属性有两个可能的值：</p><ul><li>loading，表示文档正在加载；</li><li>complete，表示文档加载完成。</li></ul></li><li><p>compatMode 属性<br> 标准模式下 <strong>document.compatMode</strong> 的值是 &quot;CSS1Compat&quot;，而在混杂模式下，document.compatMode 的值是 &quot;BackCompat&quot;</p></li><li><p>head 属性<br> HTML5 增加了<strong>document.head</strong> 属性，指向文档的 <code>&lt;head&gt;</code> 元素。</p></li></ol><h4 id="字符集属性" tabindex="-1">字符集属性 <a class="header-anchor" href="#字符集属性" aria-label="Permalink to &quot;字符集属性&quot;">​</a></h4><p><strong>characterSet</strong> 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是 &quot;UTF-16&quot;，但可以通过 <code>&lt;meta&gt;</code> 元素或响应头，以及新增的 characterSet 属性来修改。</p><h4 id="自定义数据属性" tabindex="-1">自定义数据属性 <a class="header-anchor" href="#自定义数据属性" aria-label="Permalink to &quot;自定义数据属性&quot;">​</a></h4><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 <code>data-</code> 以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。</p><p>定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个 DOMStringMap 的实例，包含一组键/值对映射。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data-appId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;12345&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data-myname</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Nicholas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得自定义数据属性的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> appId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.dataset.appId;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.dataset.myname;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置自定义数据属性的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.dataset.appId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 23456</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.dataset.myname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Michael&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。</p><h4 id="插入标记" tabindex="-1">插入标记 <a class="header-anchor" href="#插入标记" aria-label="Permalink to &quot;插入标记&quot;">​</a></h4><ol><li><p><strong>innerHTML</strong> 属性<br> 在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。<br> 而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。<br> 在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。</p></li><li><p><strong>outerHTML</strong> 属性<br> 读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。<br> 在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。</p></li><li><p><code>insertAdjacentHTML()</code> 与 <code>insertAdjacentText()</code><br> 它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。<br> 第一个参数必须是下列值中的一个：</p><ul><li>&quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点；</li><li>&quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面；</li><li>&quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li><li>&quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。<br> 第二个参数会作为 HTML 字符串解析</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentHTML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;beforebegin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertAdjacentText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;beforebegin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p>使用安全<br> 限制使用 innerHTML 和 outerHTML 的次数。<br> 如果页面中要使用用户提供的信息，则不建议使用 innerHTML，以防止 XSS 攻击。</p></li><li><p><strong>innerText</strong> 属性（HTML5 没入选）<br> innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。<br> 在用于读取值时，innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。<br> 在用于写入值时，innerText 会移除元素的所有后代并插入一个包含该值的文本节点。</p></li><li><p><strong>outerText</strong> 属性（HTML5 没入选）<br> outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。<br> 要读取文本值时，outerText 与 innerText 实际上会返回同样的内容。<br> 但在写入文本值时，outerText 就大不相同了。 写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。</p></li></ol><h4 id="scrollintoview" tabindex="-1">scrollIntoView <a class="header-anchor" href="#scrollintoview" aria-label="Permalink to &quot;scrollIntoView&quot;">​</a></h4><p><code>scrollIntoView()</code> 方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。</p><blockquote><p>[!example]+ scrollIntoView</p><p><code>element.scrollIntoView([options])</code> 方法滚动当前元素到浏览器视窗的可见区域。如果提供了选项，则根据提供的选项调整滚动行为；如果没有提供选项，默认行为是将元素尽可能地对齐到视窗顶部。</p><ul><li>options（可选）: 一个布尔值或对象，用于控制滚动的行为。 <ul><li>如果为布尔值：<code>true</code> 表示尽可能将元素与视窗顶部对齐（默认行为），<code>false</code> 表示尽可能将元素与视窗底部对齐。</li><li>如果为对象，可以包含以下属性： <ul><li>behavior: 字符串，可取值为 <code>&quot;auto&quot;</code> 或 <code>&quot;smooth&quot;</code>，分别表示瞬时滚动或平滑滚动。默认为 <code>&quot;auto&quot;</code>。</li><li>block: 字符串，定义垂直方向上的对齐方式，可取值为 <code>&quot;start&quot;</code>, <code>&quot;center&quot;</code>, <code>&quot;end&quot;</code>, 或 <code>&quot;nearest&quot;</code>。默认为 <code>&quot;start&quot;</code>，即将元素顶部与视窗顶部对齐。</li><li>inline: 字符串，定义水平方向上的对齐方式，类似 <code>block</code> 的取值。默认为 <code>&quot;nearest&quot;</code>，即尽可能少滚动。</li></ul></li></ul></li></ul><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>这个方法对于确保用户能够看到某个特定的元素非常有用，特别是在表单验证失败后自动滚动到错误字段，或者在点击跳转链接时平滑滚动到目标部分。</li><li>平滑滚动 (<code>behavior: &#39;smooth&#39;</code>) 提供了更好的用户体验，但需要注意的是，某些旧版浏览器可能不支持这一特性。</li></ul></blockquote><h4 id="children-属性" tabindex="-1">children 属性 <a class="header-anchor" href="#children-属性" aria-label="Permalink to &quot;children 属性&quot;">​</a></h4><p>children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。<br> 如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的。</p><h4 id="contains-方法" tabindex="-1">contains 方法 <a class="header-anchor" href="#contains-方法" aria-label="Permalink to &quot;contains 方法&quot;">​</a></h4><p><code>contains()</code> 方法用于确定一个元素是不是另一个元素的后代。</p><blockquote><p>[!example]+ contains</p><p><code>node.contains(childNode)</code> 方法用于检查一个节点是否包含另一个节点，即判断 childNode 是否是 node 的子节点（直接或间接）。</p><ul><li><code>childNode</code>: 要检查的节点，看它是否为 node 的子节点。</li></ul><p>返回值: 如果 <code>childNode</code> 是 node 的后代节点，则返回 true；否则返回 false。</p><p>注意点：</p><ul><li>该方法可以用来检测两个节点之间的包含关系，不仅限于直接子节点，还包括所有层级的后代节点。</li></ul></blockquote><p>另外，使用 DOM Level 3 的 <code>compareDocumentPosition()</code> 方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。</p><table tabindex="0"><thead><tr><th>掩码</th><th>节点关系</th></tr></thead><tbody><tr><td>0x1</td><td>断开（传入的节点不在文档中）</td></tr><tr><td>0x2</td><td>领先（传入的节点在 DOM 树中位于参考节点之前）</td></tr><tr><td>0x4</td><td>随后（传入的节点在 DOM 树中位于参考节点之后）</td></tr><tr><td>0x8</td><td>包含（传入的节点是参考节点的祖先）</td></tr><tr><td>0x10</td><td>被包含（传入的节点是参考节点的后代）</td></tr></tbody></table><h2 id="三、dom-扩展" tabindex="-1">三、DOM 扩展 <a class="header-anchor" href="#三、dom-扩展" aria-label="Permalink to &quot;三、DOM 扩展&quot;">​</a></h2><h3 id="样式" tabindex="-1">样式 <a class="header-anchor" href="#样式" aria-label="Permalink to &quot;样式&quot;">​</a></h3><p>HTML 中的样式有 3 种定义方式：外部样式表（通过 <code>&lt;link&gt;</code> 元素）、文档样式表（使用 <code>&lt;style&gt;</code> 元素）和元素特定样式（使用 <strong>style</strong> 属性）。DOM2 Style 为这 3 种应用样式的机制都提供了 API。<br> 在 DOM 中，元素的 <strong>style 属性</strong>（即内联样式）和通过 <strong>外部/内部样式表（CSS）</strong> 设置的属性是<strong>独立存储</strong>的，但二者会共同影响元素的最终渲染样式。</p><h4 id="存取元素样式" tabindex="-1">存取元素样式 <a class="header-anchor" href="#存取元素样式" aria-label="Permalink to &quot;存取元素样式&quot;">​</a></h4><p>任何支持 style 属性的 HTML 元素在 JavaScript 中都会有一个对应的 style 属性。这个 style 属性是 CSSStyleDeclaration 类型的实例，==其中包含通过 HTML style 属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式==。</p><p>CSS 属性名使用连字符表示法（用连字符分隔两个单词，如 background-image），所以在 JavaScript 中这些属性必须转换为驼峰大小写形式（如 backgroundImage）</p><p>通过 style 属性设置的值也可以通过 style 对象获取。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myDiv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置背景颜色</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myDiv.style.backgroundColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myDiv.style.backgroundColor); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;red&quot;</span></span></code></pre></div><ol><li><p>DOM 样式属性和方法<br> DOM2 Style 规范也在 style 对象上定义了一些属性和方法。这些属性和方法提供了元素 style 属<br> 性的信息并支持修改，列举如下。</p><ul><li><strong>cssText</strong>，包含 style 属性中的 CSS 代码。</li><li><strong>length</strong>，应用给元素的 CSS 属性数量。</li><li><strong>parentRule</strong>，表示 CSS 信息的 CSSRule 对象。</li><li>getPropertyCSSValue(propertyName)，返回包含 CSS 属性 propertyName 值的 CSSValue 对象（已废弃）。</li><li><code>getPropertyPriority(propertyName)</code>，如果 CSS 属性 propertyName 使用了!important 则返回 &quot;important&quot;，否则返回空字符串。</li><li><code>getPropertyValue(propertyName)</code>，返回属性 propertyName 的字符串值。</li><li><code>item(index)</code>，返回索引为 index 的 CSS 属性名。</li><li><code>removeProperty(propertyName)</code>，从样式中删除 CSS 属性 propertyName。</li><li><code>setProperty(propertyName, value, priority)</code>，设置 CSS 属性 propertyName 的值为 value，priority 是 &quot;important&quot; 或空字符串。</li></ul></li><li><p>计算样式<br> ==style 对象中包含支持 style 属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息==<br> DOM2 Style 在 document.defaultView 上增加了 <code>getComputedStyle()</code> 方法。<br> 这个方法接收两个参数：要取得计算样式的元素和伪元素字符串（如 &quot;:after&quot;）。如果不需要查询伪元素，则第二个参数可以传 null。<code>getComputedStyle()</code> 方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型一样），包含元素的计算样式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myDiv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> computedStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.defaultView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComputedStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myDiv, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ol><h4 id="操作样式表" tabindex="-1">操作样式表 <a class="header-anchor" href="#操作样式表" aria-label="Permalink to &quot;操作样式表&quot;">​</a></h4><p>CSSStyleSheet 类型表示 CSS 样式表，包括使用 <code>&lt;link&gt;</code> 元素和通过 <code>&lt;style&gt;</code> 元素定义的样式表。注意，这两个元素本身分别是 HTMLLinkElement 和 HTMLStyleElement。</p><p>CSSStyleSheet 类型是一个通用样式表类型，可以表示以任何方式在 HTML 中定义的样式表。<strong>CSSStyleSheet 对象是浏览器内核（渲染引擎）在解析 CSS 样式表时创建的结果。</strong></p><p>以下是 CSSStyleSheet 从 StyleSheet 继承的属性。</p><ul><li>disabled，布尔值，表示样式表是否被禁用了（这个属性是可读写的，因此将它设置为 true 会禁用样式表）。</li><li>href，如果是使用 <code>&lt;link&gt;</code> 包含的样式表，则返回样式表的 URL，否则返回 null。</li><li>media，样式表支持的媒体类型集合，这个集合有一个 length 属性和一个 item() 方法，跟所有 DOM 集合一样。同样跟所有 DOM 集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表。</li><li>ownerNode，指向拥有当前样式表的节点，在 HTML 中要么是 <code>&lt;link</code>&gt;元素要么是 <code>&lt;style</code>&gt;元素（在 XML 中可以是处理指令）。如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性值为 null。</li><li>parentStyleSheet，如果当前样式表是通过 <code>@import</code> 被包含在另一个样式表中，则这个属性指向导入它的样式表。</li><li>title，ownerNode 的 title 属性。</li><li>type，字符串，表示样式表的类型。对 CSS 样式表来说，就是 &quot;<code>text/css</code>&quot;。<br> ==上述属性里除了 disabled，其他属性都是只读的。==除了上面继承的属性，CSSStyleSheet 类型还支持以下属性和方法。</li><li>cssRules，当前样式表包含的样式规则的集合。</li><li>ownerRule，如果样式表是使用@import 导入的，则指向导入规则；否则为 null。</li><li>deleteRule(index)，在指定位置删除 cssRules 中的规则。</li><li>insertRule(rule, index)，在指定位置向 cssRules 中插入规则。</li></ul><p><strong>document.styleSheets</strong> 表示文档中可用的样式表集合。这个集合的 <strong>length</strong> 属性保存着文档中样式表的数量，而每个样式表都可以使用中括号或 <code>item()</code> 方法获取。</p><p>通过 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 元素也可以直接获取 CSSStyleSheet 对象。DOM 在这两个元素上暴露了 sheet 属性，其中包含对应的 CSSStyleSheet 对象。</p><ol><li><p>CSS 规则<br> CSSRule 类型表示样式表中的一条规则。以下是 CSSStyleRule 对象上可用的属性。</p><ul><li>cssText，返回整条规则的文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。</li><li>parentRule，如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是 null。</li><li>parentStyleSheet，包含当前规则的样式表。</li><li>selectorText，返回规则的选择符文本。</li><li>style，返回 CSSStyleDeclaration 对象，可以设置和获取当前规则中的样式。</li><li>type，数值常量，表示规则类型。对于样式规则，它始终为 1。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.box {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	background</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: blue;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: 100px;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: 200px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sheet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.styleSheets[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rules </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sheet.cssRules </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sheet.rules; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得规则集合</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rule </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rules[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得第一条规则</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rule.selectorText); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;div.box&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rule.style.cssText); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 完整的CSS 代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rule.style.backgroundColor); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;blue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rule.style.width); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;100px&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rule.style.height); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;200px&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rule.style.backgroundColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;red&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //也可以修改</span></span></code></pre></div></li><li><p>创建规则<br> 可以使用 <code>insertRule()</code> 方法向样式表中添加新规则。这个方法接收两个参数：规则的文本和表示插入位置的索引值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sheet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertRule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;body { background-color: silver }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p>删除规则<br><code>deleteRule()</code>，它接收一个参数：要删除规则的索引。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sheet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deleteRule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ol><h4 id="元素尺寸" tabindex="-1">元素尺寸 <a class="header-anchor" href="#元素尺寸" aria-label="Permalink to &quot;元素尺寸&quot;">​</a></h4><h5 id="_1-偏移尺寸" tabindex="-1">1. 偏移尺寸 <a class="header-anchor" href="#_1-偏移尺寸" aria-label="Permalink to &quot;1. 偏移尺寸&quot;">​</a></h5><p>第一组属性涉及偏移尺寸（offset dimensions），包含元素在屏幕上占用的所有视觉空间。元素在页<br> 面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框（但不包含外边距）。<br> 以下 4 个 属性用于取得元素的偏移尺寸。</p><ul><li>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度（如果可见）和上、下边框的高度。</li><li>offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。</li><li>offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。</li><li>offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。<br><img src="`+l+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-5.png"></li></ul><h5 id="_2-客户端尺寸" tabindex="-1">2. 客户端尺寸 <a class="header-anchor" href="#_2-客户端尺寸" aria-label="Permalink to &quot;2. 客户端尺寸&quot;">​</a></h5><p>元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性：clientWidth 和 clientHeight。其中，clientWidth 是内容区宽度加左、右内边距宽度，clientHeight 是内容区高度加上、下内边距高度。<br><img src="'+n+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-6.png"></p><h5 id="_3-滚动尺寸" tabindex="-1">3. 滚动尺寸 <a class="header-anchor" href="#_3-滚动尺寸" aria-label="Permalink to &quot;3. 滚动尺寸&quot;">​</a></h5><p>最后一组尺寸是滚动尺寸（scroll dimensions），提供了元素内容滚动距离的信息。<br> 滚动尺寸相关的属性有如下 4 个。</p><ul><li>scrollHeight，没有滚动条出现时，元素内容的总高度。</li><li>scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li>scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li>scrollWidth，没有滚动条出现时，元素内容的总宽度。<br><img src="'+o+'" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-7.png"></li></ul><h5 id="_4-确定元素尺寸" tabindex="-1">4. 确定元素尺寸 <a class="header-anchor" href="#_4-确定元素尺寸" aria-label="Permalink to &quot;4. 确定元素尺寸&quot;">​</a></h5><p>浏览器在每个元素上都暴露了 <code>getBoundingClientRect()</code> 方法，返回一个 DOMRect 对象，包含 6 个属性：left、top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视<br> 口的位置。<br><img src="'+d+`" alt="D-学习笔记/前端技术/03 JavaScript/笔记：JS高级程序设计/attachments/12 DOM-8.png"></p><h3 id="遍历" tabindex="-1">遍历 <a class="header-anchor" href="#遍历" aria-label="Permalink to &quot;遍历&quot;">​</a></h3><p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— <strong>NodeIterator</strong> 和 <strong>TreeWalker</strong> ——从某个起点开始执行对 DOM 结构的==深度优先遍历==。</p><h4 id="nodeiterator" tabindex="-1">NodeIterator <a class="header-anchor" href="#nodeiterator" aria-label="Permalink to &quot;NodeIterator&quot;">​</a></h4><p>可以通过 <code>document.createNodeIterator()</code> 方法创建其实例。这个方法接收以下 4 个参数。</p><ul><li>root，作为遍历根节点的节点。</li><li>whatToShow，数值代码，表示应该访问哪些节点。</li><li>filter，NodeFilter 对象或函数，表示是否接收或跳过特定节点。</li><li>entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。</li></ul><p>whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。</p><ul><li>NodeFilter.SHOW_ALL，所有节点。</li><li>NodeFilter.SHOW_ELEMENT，元素节点。</li><li>NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。</li><li>NodeFilter.SHOW_TEXT，文本节点。</li><li>NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。</li><li>NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。</li><li>NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。</li><li>NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。</li><li>NodeFilter.SHOW_COMMENT，注释节点。</li><li>NodeFilter.SHOW_DOCUMENT，文档节点。</li><li>NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。</li><li>NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。</li><li>NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的。</li></ul><p><code>createNodeIterator()</code> 方法的 filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数。NodeFilter 对象只有一个方法 <code>acceptNode()</code>，如果给定节点应该访问就返回 NodeFilter.FILTER_ACCEPT，否则返回 NodeFilter.FILTER_SKIP。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iterator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNodeIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document, NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ALL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>NodeIterator 的两个主要方法是 <code>nextNode()</code> 和 <code>previousNode()</code>。<br><code>nextNode()</code> 方法在 DOM 子树中以深度优先方式进前一步，而 <code>previousNode()</code> 则是在遍历中后退一步。</p><h4 id="treewalker" tabindex="-1">TreeWalker <a class="header-anchor" href="#treewalker" aria-label="Permalink to &quot;TreeWalker&quot;">​</a></h4><p>TreeWalker 是 NodeIterator 的高级版。除了包含同样的 <code>nextNode()</code>、<code>previousNode()</code> 方法，TreeWalker 还添加了如下在 DOM 结构中向不同方向遍历的方法。</p><ul><li><code>parentNode()</code>，遍历到当前节点的父节点。</li><li><code>firstChild()</code>，遍历到当前节点的第一个子节点。</li><li><code>lastChild()</code>，遍历到当前节点的最后一个子节点。</li><li><code>nextSibling()</code>，遍历到当前节点的下一个同胞节点。</li><li><code>previousSibling()</code>，遍历到当前节点的上一个同胞节点。</li></ul><p>TreeWalker 对象要调用 document.createTreeWalker() 方法来创建， 这个方法接收与 document.createNodeIterator() 同样的参数：作为遍历起点的根节点、要查看的节点类型、节点过滤器和一个表示是否扩展实体引用的布尔值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> walker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTreeWalker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(div, NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ELEMENT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>不同的是，节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter.FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。</p><h3 id="范围" tabindex="-1">范围 <a class="header-anchor" href="#范围" aria-label="Permalink to &quot;范围&quot;">​</a></h3><p>为了支持对页面更细致的控制，DOM2 Traversal and Range 模块定义了范围接口。</p><h4 id="dom-范围" tabindex="-1">DOM 范围 <a class="header-anchor" href="#dom-范围" aria-label="Permalink to &quot;DOM 范围&quot;">​</a></h4><p>DOM2 在 Document 类型上定义了一个 <code>createRange()</code> 方法，暴露在 document 对象上。使用这个方法可以创建一个 DOM 范围对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>每个范围都是 Range 类型的实例，拥有相应的属性和方法。下面的属性提供了与范围在文档中位置相关的信息。</p><ul><li>startContainer，范围起点所在的节点（选区中第一个子节点的父节点）。</li><li>startOffset，范围起点在 startContainer 中的偏移量。如果 startContainer 是文本节点、注释节点或 CData 区块节点，则 startOffset 指范围起点之前跳过的字符数；否则，表示范围中第一个节点的索引。</li><li>endContainer，范围终点所在的节点（选区中最后一个子节点的父节点）。</li><li>endOffset，范围起点在 startContainer 中的偏移量（与 startOffset 中偏移量的含义相同）。</li><li>commonAncestorContainer，文档中以 startContainer 和 endContainer 为后代的最深的节点。</li></ul><h4 id="简单选择" tabindex="-1">简单选择 <a class="header-anchor" href="#简单选择" aria-label="Permalink to &quot;简单选择&quot;">​</a></h4><p>通过范围选择文档中某个部分最简单的方式，就是使用 <code>selectNode()</code> 或 <code>selectNodeContents()</code> 方法。<br> 这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。<br><code>selectNode()</code> 方法选择整个节点，包括其后代节点，而 <code>selectNodeContents()</code> 只选择节点的后代。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    range2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectNodeContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1);</span></span></code></pre></div><p>还可以在范围上调用相应的方法，实现对范围中选区的更精细控制。</p><ul><li><code>setStartBefore(refNode)</code>，把范围的起点设置到 refNode 之前，从而让 refNode 成为选区的第一个子节点。startContainer 属性被设置为 refNode.parentNode，而 startOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引。</li><li><code>setStartAfter(refNode)</code>，把范围的起点设置到 refNode 之后，从而将 refNode 排除在选区之外，让其下一个同胞节点成为选区的第一个子节点。startContainer 属性被设置为 refNode.parentNode，startOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引加 1。</li><li><code>setEndBefore(refNode)</code>，把范围的终点设置到 refNode 之前，从而将 refNode 排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。endContainer 属性被设置为 refNode.parentNode，endOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引。</li><li><code>setEndAfter(refNode)</code>，把范围的终点设置到 refNode 之后，从而让 refNode 成为选区的最后一个子节点。endContainer 属性被设置为 refNode.parentNode，endOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引加 1。</li></ul><h4 id="复杂选择" tabindex="-1">复杂选择 <a class="header-anchor" href="#复杂选择" aria-label="Permalink to &quot;复杂选择&quot;">​</a></h4><p>要创建复杂的范围，需要使用 <code>setStart()</code> 和 <code>setEnd()</code> 方法。这两个方法都接收两个参数：参照节点和偏移量。<br> 对 <code>setStart()</code> 来说，参照节点会成为 startContainer，而偏移量会赋值给 startOffset。<br> 对 <code>setEnd()</code> 而言，参照节点会成为 endContainer，而偏移量会赋值给 endOffset。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloNode, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(worldNode, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h4 id="操作范围" tabindex="-1">操作范围 <a class="header-anchor" href="#操作范围" aria-label="Permalink to &quot;操作范围&quot;">​</a></h4><p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。</p><p><code>deleteContents()</code> ：方法会从文档中删除范围包含的节点。<br><code>extractContents()</code> ：方法返回范围对应的文档片段。<br><code>cloneContents()</code>：创建一个副本，然后把这个副本插入到文档其他地方。</p><h4 id="范围插入" tabindex="-1">范围插入 <a class="header-anchor" href="#范围插入" aria-label="Permalink to &quot;范围插入&quot;">​</a></h4><p>使用 <code>insertNode()</code> 方法可以在范围选区的开始位置插入一个节点。<br> 使用 <code>surroundContents()</code> 方法插入包含范围的内容</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloNode);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> span </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;span&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">span.style.backgroundColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;yellow&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">surroundContents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(span);</span></span></code></pre></div><h4 id="范围折叠" tabindex="-1">范围折叠 <a class="header-anchor" href="#范围折叠" aria-label="Permalink to &quot;范围折叠&quot;">​</a></h4><p>如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。<br> 折叠范围可以使用 <code>collapse()</code> 方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。true 表示折叠到起点，false 表示折叠到终点。<br> 要确定范围是否已经被折叠，可以检测范围的 collapsed 属性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collapse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 折叠到起点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(range.collapsed); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出true</span></span></code></pre></div><h4 id="范围比较" tabindex="-1">范围比较 <a class="header-anchor" href="#范围比较" aria-label="Permalink to &quot;范围比较&quot;">​</a></h4><p>如果有多个范围，则可以使用 <code>compareBoundaryPoints()</code> 方法确定范围之间是否存在公共的边界（起点或终点）。这个方法接收两个参数：要比较的范围和一个常量值，表示比较的方式。这个常量参数包括：</p><ul><li>Range.START_TO_START（0），比较两个范围的起点；</li><li>Range.START_TO_END（1），比较第一个范围的起点和第二个范围的终点；</li><li>Range.END_TO_END（2），比较两个范围的终点；</li><li>Range.END_TO_START（3），比较第一个范围的终点和第二个范围的起点。</li></ul><p><code>compareBoundaryPoints()</code> 方法在第一个范围的边界点位于第二个范围的边界点之前时返回 -1，在两个范围的边界点相等时返回 0，在第一个范围的边界点位于第二个范围的边界点之后时返回 1。</p><h4 id="复制范围" tabindex="-1">复制范围 <a class="header-anchor" href="#复制范围" aria-label="Permalink to &quot;复制范围&quot;">​</a></h4><p>调用范围的 <code>cloneRange()</code> 方法可以复制范围。这个方法会创建调用它的范围的副本</p><h4 id="清理" tabindex="-1">清理 <a class="header-anchor" href="#清理" aria-label="Permalink to &quot;清理&quot;">​</a></h4><p>调用 <code>detach()</code> 方法把范围从创建它的文档中剥离。调用 detach() 之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">detach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从文档中剥离范围</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解除引用</span></span></code></pre></div><h4 id="应用场景与优势" tabindex="-1">应用场景与优势 <a class="header-anchor" href="#应用场景与优势" aria-label="Permalink to &quot;应用场景与优势&quot;">​</a></h4><p>DOM 的范围操作（Range API）在处理复杂的文本选择和编辑任务时非常有用，尤其是在需要精确控制哪些部分的文档被选中或修改的情况下。</p><ol><li><strong>富文本编辑器</strong></li><li><strong>高亮显示</strong></li><li><strong>拖放功能</strong></li><li><strong>自定义剪切板行为</strong></li><li><strong>复杂布局调整</strong></li></ol><p>优势</p><ol><li><strong>性能考虑</strong>：每次修改 DOM 都可能导致浏览器重新计算布局（重排）和重新绘制页面（重绘），这会消耗大量的资源。==通过 Range，可以在内存中构建好所有的更改后再一次性应用到 DOM 上，从而减少不必要的重排和重绘次数。==</li><li><strong>简化逻辑</strong>：对于复杂的文本选择和编辑任务，直接操作 DOM 元素节点可能会使代码变得复杂且难以理解。==Range 提供了一种更为抽象的方式来处理这些问题，使得代码更加清晰易读。==</li></ol><h3 id="observer-api" tabindex="-1">Observer API <a class="header-anchor" href="#observer-api" aria-label="Permalink to &quot;Observer API&quot;">​</a></h3><p>使用 Observer API 可以监听网页不同方面的变化，并针对这些变化执行相应的架设函数。现代浏览器支持的观察者 API 主要有：</p><ul><li>Mutation Observer API 是 DOM 标准定义的。</li><li>Resize Observer API 是 W3C CSS 工作组的 Resize Observer 规范定义的。</li><li>Intersectiopn Observer API 是 W3C Web 应用工作组在 Intersectiopn Observer 规范中定义的。</li></ul><h4 id="observer-通用-api" tabindex="-1">Observer 通用 API <a class="header-anchor" href="#observer-通用-api" aria-label="Permalink to &quot;Observer 通用 API&quot;">​</a></h4><p>Observer API 的初始化和使用方法大同小异。</p><ul><li>初始化</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fakeEventContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义回调函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fakeObserver</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FakeObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fb)</span></span></code></pre></div><ul><li>observe</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察一个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fakeObserver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body)</span></span></code></pre></div><ul><li>unobserve 和 disconnet</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 停止观察一个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fakeObserver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unobserve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 停止观察所有对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fakeObserver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li><p>异步回调和记录队列<br> 为了在注册大量重叠事件时不影响性能，每个有效事件的信息都会被捕获到一个记录中，然后推入一个<strong>记录队列</strong>。这个队列对每个观察者都是唯一的，表示按顺序发生的每个事件。</p></li><li><p>takeRecords<br> 调用该方法可以取得所有尚未被回调处理的记录</p></li><li><p>观察者的引用<br> 观察者与它所观察的元素直接的引用关系是不对称的。<br> 观察者有指向被观察元素的弱引用，不会影响目标元素被作为垃圾回收。<br> 目标元素有指向观察者的强引用，如果元素从 DOM 中被删除，进而被垃圾回收，关联的观察者也会被垃圾回收</p></li></ul><h4 id="resize-observer" tabindex="-1">Resize Observer <a class="header-anchor" href="#resize-observer" aria-label="Permalink to &quot;Resize Observer&quot;">​</a></h4><p>Resize Observer API 用于跟踪 DOM 元素尺寸的变化，适用于响应式 Web 设计或动态布局更新。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResizeObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Resize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body)</span></span></code></pre></div><blockquote><p>[!example]+ ResizeObserver.observe</p><p><code>resizeObserver.observe(targetElement[, options])</code> 方法开始对指定的 <code>targetElement</code> 进行观察。</p><ul><li>targetElement: 要观察的 DOM 元素。</li><li>options（可选）: 一个选项对象，允许你设置观察的盒模型类型。当前仅支持一个参数： <ul><li>box: 设置观察的盒模型。可能的值有： <ul><li>&quot;content-box&quot;（默认）：观察内容区域的大小变化。</li><li>&quot;border-box&quot;：观察边框区域的大小变化。</li><li>&quot;device-pixel-content-box&quot;：以设备像素为单位观察内容区域的大小变化，在应用任何 CSS 转换之前。</li></ul></li></ul></li></ul><p>返回值: 无返回值。</p><p>注意点：</p><ul><li>调用 <code>observe()</code> 会触发一次回调函数。</li><li>可以为同一个 <code>ResizeObserver</code> 实例调用多次 <code>observe()</code> 方法来观察多个元素。</li><li>如果不再需要观察某个元素，可以使用 <code>unobserve()</code> 方法停止对该元素的观察。</li><li>使用 <code>disconnect()</code> 方法可以停止对所有元素的观察。</li></ul></blockquote><p>==resizeObserver 在渲染过程中处理缩放事件：所有操作在布局之后、绘制之前发生。==</p><p>回调函数接受两个参数：第一个表示每个缩放事件的 ResizeObserverEntry 对象的数组，第二个是观察者实例。<br> ResizeObserverEntry 对象是一个包含以下只读属性的字典。</p><ul><li>borderBoxSize：包含新边框盒子的尺寸。</li><li>contentBoxSize：包含新内容盒子的尺寸。</li><li>devicePixelContentBox：包含以设备像素计的新内容盒子的尺寸。</li><li>contentRect：DOMRect 对象，包含新元素尺寸，是之前 API 规范遗留下来的。</li><li>target：对元素的引用。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResizeObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entries)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>borderBoxSize 和 contentBoxSize 属性是包含两个属性的对象的数组，其中一个属性是 blockSize，即块状元素盒子的长度，另一个属性是行内元素盒子的长度。</p><p>resizeObserver API 没有使用记录队列。</p><h4 id="intersection-observer" tabindex="-1">Intersection Observer <a class="header-anchor" href="#intersection-observer" aria-label="Permalink to &quot;Intersection Observer&quot;">​</a></h4><p>Intersection Observer API 可以监听 DOM 元素相对于指定视口或容器元素的可见性及位置，特别适合用于基于滚动的动画，或者图片懒加载、无穷滚动等性能优化逻辑。</p><p>实例化需要传入一个回调函数和一个可选的 options 对象。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IntersectionObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">IntersectionObserverEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{},options)</span></span></code></pre></div><p>在不提供 options 对象的情况下，观察者默认行为如下。</p><ul><li>默认视口是文档的视口，也就是整个屏幕</li><li>默认阈值是 0，即目标元素与视口有 1 个像素的重叠就会触发回调。</li></ul><p>options 对象可选属性：</p><ul><li><code>root</code>: 用来作为参照的元素，默认是浏览器的视口。</li><li><code>rootMargin</code>: 类似于 CSS 中的 margin，用来扩展或缩小 <code>root</code> 元素的区域。</li><li><code>threshold</code>: 一个数值或者数值数组，指定了交叉比例，当目标元素达到这些比例时会触发回调函数</li><li><code>trackVisibility</code>：是一个布尔值，表示是否跟踪目标元素的实际可见性变化。如果设置则必须设置 <code>delay</code>。</li><li><code>delay</code>：表示观察者针对给定目标元素发出通知的最小延迟事件，最小 100ms。</li></ul><p>回调函数会在每次观察到的变化发生时被调用，并且会接收到两个参数：</p><ul><li><code>entries</code>: 一个 <code>IntersectionObserverEntry</code> 对象数组，每个对象包含了关于目标元素当前状态的信息。</li><li><code>observer</code>: 对应的 <code>IntersectionObserver</code> 实例。</li></ul><p><code>IntersectionObserverEntry</code> 对象属性：</p><ol><li><strong><code>time</code></strong>：一个表示时间戳的 <code>DOMHighResTimeStamp</code> 值，它反映了从文档加载开始到发生交集变化的时间点</li><li><strong><code>target</code></strong>：这是被观察的目标元素，即触发回调的那个元素。它是一个 <code>Element</code> 类型的对象</li><li><strong><code>boundingClientRect</code></strong>：提供了一个 <code>DOMRectReadOnly</code> 对象，该对象包含目标元素相对于视口的位置和尺寸信息。这类似于调用 <code>Element.getBoundingClientRect()</code> 所返回的结果</li><li><strong><code>rootBounds</code></strong>：如果指定了根元素，则这是一个 <code>DOMRectReadOnly</code> 对象，代表根元素的边界矩形。如果没有指定根元素（即使用浏览器视口），则此属性可能为 <code>null</code></li><li><strong><code>intersectionRect</code></strong>：这也是一个 <code>DOMRectReadOnly</code> 对象，它描述了目标元素与根元素实际重叠部分的边界矩形</li><li><strong><code>intersectionRatio</code></strong>：这是一个浮点数，表示目标元素与根元素相交的比例。值范围从 0 到 1，其中 0 表示没有交集，而 1 表示完全重合</li><li><strong><code>isIntersecting</code></strong>：一个布尔值，当目标元素与根元素相交时为 <code>true</code>，否则为 <code>false</code>。这个属性可以帮助快速判断目标是否进入了视口或者指定的根元素</li><li><strong><code>isVisible</code></strong>：这是 Intersection Observer API v2 中引入的一个属性，仅在启用了 <code>trackVisibility</code> 选项时可用。如果目标元素不仅与根元素相交而且是实际可见的（未被其他元素遮挡或由于样式原因不可见），则该属性为 <code>true</code> 。</li></ol><h4 id="mutation-observer" tabindex="-1">Mutation Observer <a class="header-anchor" href="#mutation-observer" aria-label="Permalink to &quot;Mutation Observer&quot;">​</a></h4><p>MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">MutationRecord</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MutationRecord)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><blockquote><p>[!example]+ MutationObserver.observe</p><p><code>mutationObserver.observe(target, options)</code> 配置了 <code>MutationObserver</code> 对象的回调方法以开始接收与给定选项匹配的 DOM 变化的通知。</p><ul><li>target: 一个 DOM 节点（可能是元素），它是要观察变化的 DOM 树中的节点或者是被观察的子树的根节点。</li><li>MutationObserverInit 对象: 一个对象提供选项，控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。</li></ul><p>返回值: 无返回值。</p></blockquote><ul><li>MutationObserverInit 对象</li></ul><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>subtree</td><td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代）<br>如果是 false，则只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树<br>默认为 false</td></tr><tr><td>attributes</td><td>布尔值，表示是否观察目标节点的属性变化<br>默认为 false</td></tr><tr><td>attributeFilter</td><td>字符串数组，表示要观察哪些属性的变化<br>把这个值设置为 true 也会将 <code>attributes</code> 的值转换为 true<br>默认为观察所有属性</td></tr><tr><td>attributeOldValue</td><td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的属性值<br>把这个值设置为 true 也会将 <code>attributes</code> 的值转换为 true<br>默认为 false</td></tr><tr><td>characterData</td><td>布尔值，表示修改字符数据是否触发变化事件<br>默认为 false</td></tr><tr><td>characterDataOldValue</td><td>布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的字符数据<br>把这个值设置为 true 也会将 <code>characterData</code> 的值转换为 true<br>默认为 false</td></tr><tr><td>childList</td><td>布尔值，表示修改目标节点的子节点是否触发变化事件<br>默认为 false</td></tr></tbody></table><ul><li>MutationRecord</li></ul><p>==每个回调都会收到一个 MutationRecord 实例的数组。==MutationRecord 实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。<br> MutationRecord 实例的属性。</p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>被修改影响的目标节点</td></tr><tr><td>type</td><td>字符串，表示变化的类型：&quot;attributes&quot;、&quot;characterData&quot; 或 &quot;childList&quot;</td></tr><tr><td>oldValue</td><td>如果在 <code>MutationObserverInit</code> 对象中启用 (<code>attributeOldValue</code> 或 <code>characterDataOldValue</code> 为 true)，<br>&quot;attributes&quot; 或 &quot;characterData&quot; 的变化事件会设置这个属性为被替代的值<br>&quot;childList&quot; 类型的变化始终将这个属性设置为 null</td></tr><tr><td>attributeName</td><td>对于 &quot;attributes&quot; 类型的变化，这里保存被修改属性的名字<br>其他变化事件会将这个属性设置为 null</td></tr><tr><td>attributeNamespace</td><td>对于使用了命名空间的 &quot;attributes&quot; 类型的变化，这里保存被修改属性的名字其他变化事件会将这个属性设置为 null</td></tr><tr><td>addedNodes</td><td>对于 &quot;childList&quot; 类型的变化，返回包含变化中添加节点的 NodeList<br>默认为空 NodeList</td></tr><tr><td>removedNodes</td><td>对于 &quot;childList&quot; 类型的变化，返回包含变化中删除节点的 NodeList<br>默认为空 NodeList</td></tr><tr><td>previousSibling</td><td>对于 &quot;childList&quot; 类型的变化，返回变化节点的前一个同胞 Node<br>默认为 null</td></tr><tr><td>nextSibling</td><td>对于 &quot;childList&quot; 类型的变化，返回变化节点的后一个同胞 Node<br>默认为 null</td></tr></tbody></table><p>传给回调函数的第二个参数是观察变化的 MutationObserver 的实例</p><ul><li>disconnect() 方法</li></ul><p>要提前终止执行回调，可以调用 <code>disconnect()</code> 方法，它会停止观察所有目标。<br> 调用 <code>disconnect()</code> 并不会结束 MutationObserver 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。</p><ul><li>1.观察属性</li></ul><p>MutationObserver 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 MutationObserverInit 对象中将 <code>attributes</code> 属性设置为 true。</p><p>把 attributes 设置为 true 的默认行为是观察所有属性，但不会在 MutationRecord 对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用 <code>attributeFilter</code> 属性来设置白名单，即一个属性名字符串数组。</p><p>如果想在变化记录中保存属性原来的值，可以将 <code>attributeOldValue</code> 属性设置为 true</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationRecords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutationRecords));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributeFilter: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributeOldValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><ul><li>2.观察字符数据</li></ul><p>MutationObserver 可以观察文本节点（如 Text、Comment 或 ProcessingInstruction 节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在 MutationObserverInit 对象中将 <code>characterData</code> 属性设置为 true</p><p>将 characterData 属性设置为 true 的默认行为不会在 MutationRecord 对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将 characterDataOldValue 属性设置为 true。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body.firstChild, { characterData: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body.firstChild, { characterDataOldValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><ul><li>3.观察子节点</li></ul><p>MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 MutationObserverInit 对象中将 <code>childList</code> 属性设置为 true。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { childList: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加。</p><ul><li>4.观察子树</li></ul><p>默认情况下，MutationObserver 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在 MutationObserverInit 对象中将 <code>subtree</code> 属性设置为 true。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, subtree: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><p>被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p><ul><li>异步回调与记录队列</li></ul><p>MutationObserver 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord 实例中，然后添加到记录队列。==这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM 变化事件的有序列表。==</p><p>每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p><p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一 个 MutationRecord 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 MutationRecord 就用不着了，因此记录队列会被清空，其内容会被丢弃。</p><p>调用 MutationObserver 实例的 <code>takeRecords()</code> 方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例。</p><ul><li>性能</li></ul><p>MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。<br> 然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</p><p>记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是 childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord，然后让它们超出作用域并被垃圾回收。<br> 有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，==建议从每个 MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord==。</p>`,321)]))}const D=h(c,[["render",E]]);export{v as __pageData,D as default};
