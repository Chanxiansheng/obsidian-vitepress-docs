import{_ as a,c as e,o as r,ae as p}from"./chunks/framework.CIivgcbp.js";const f=JSON.parse('{"title":"04-path 模块","description":"","frontmatter":{},"headers":[],"relativePath":"服务端/NodeJS/NodeJS笔记/04-path模块.md","filePath":"服务端/NodeJS/NodeJS笔记/04-path模块.md"}'),h={name:"服务端/NodeJS/NodeJS笔记/04-path模块.md"};function o(n,t,s,d,i,l){return r(),e("div",null,t[0]||(t[0]=[p('<h1 id="_04-path-模块" tabindex="-1">04-path 模块 <a class="header-anchor" href="#_04-path-模块" aria-label="Permalink to &quot;04-path 模块&quot;">​</a></h1><blockquote><p><a href="https://nodejs.cn/api/path.html" target="_blank" rel="noreferrer">path 路径 | Node.js v22 文档</a></p></blockquote><p><code>node:path</code> 模块提供了用于处理文件和目录的路径的实用工具。可以使用以下方式访问它：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node:path&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="window-与-posix" tabindex="-1">window 与 posix <a class="header-anchor" href="#window-与-posix" aria-label="Permalink to &quot;window 与 posix&quot;">​</a></h2><p><strong>posix（Portable Operating System Interface of UNIX）</strong> 表示可移植操作系统接口，也就是定义了一套标准，遵守这套标准的操作系统有 (unix,like unix,linux,macOs,windows wsl)。</p><p>而 Windows 并没有完全遵循 POSIX 标准。Windows 在设计上采用了不同于 POSIX 的路径表示方法。</p><p>在 Windows 系统中，路径使用反斜杠（<code>\\</code>）作为路径分隔符。这与 POSIX 系统使用的正斜杠（<code>/</code>）是不同的。这是 Windows 系统的历史原因所致，早期的 Windows 操作系统采用了不同的设计选择。</p><p>差异：<br><code>path.basename()</code> 方法返回的是给定路径中的最后一部分。<br> 在处理 windows 路径时，结果返回的是完整的路径，而不是应该返回的文件名。<br> 如果要在 posix 系统处理 windows 的路径需要调用对应操作系统的方法应该修改为使用 <code>path.win32.basename()</code> 函数。<br> 更多的差异见官方文档。</p><h2 id="api" tabindex="-1">Api <a class="header-anchor" href="#api" aria-label="Permalink to &quot;Api&quot;">​</a></h2><p>常用：</p><table tabindex="0"><thead><tr><th>Api</th><th>功能</th></tr></thead><tbody><tr><td><a href="https://nodejs.cn/api/path.html#pathbasenamepath-suffix" target="_blank" rel="noreferrer"><code>path.basename(path[, suffix])</code></a></td><td>返回 path 的最后一部分</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathdirnamepath" target="_blank" rel="noreferrer"><code>path.dirname(path)</code></a></td><td>返回 path 的目录名，与 basename 互补</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathextnamepath" target="_blank" rel="noreferrer"><code>path.extname(path)</code></a></td><td>返回 path 的扩展名</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathjoinpaths" target="_blank" rel="noreferrer"><code>path.join([...paths])</code></a></td><td>使用特定于平台的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathresolvepaths" target="_blank" rel="noreferrer"><code>path.resolve([...paths])</code></a></td><td>将路径或路径片段的序列解析为绝对路径。</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathparsepath" target="_blank" rel="noreferrer"><code>path.parse(path)</code></a></td><td>返回一个对象，包含 dir、root、base、name、ext 等属性。</td></tr><tr><td><a href="https://nodejs.cn/api/path.html#pathformatpathobject" target="_blank" rel="noreferrer"><code>path.format(pathObject)</code></a></td><td>从对象返回路径字符串。这与 <a href="https://nodejs.cn/api/path.html#pathparsepath" target="_blank" rel="noreferrer"><code>path.parse()</code></a> 相反。</td></tr></tbody></table><ul><li><a href="https://nodejs.cn/api/path.html#pathdelimiter" target="_blank" rel="noreferrer"><code>path.delimiter</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathmatchesglobpath-pattern" target="_blank" rel="noreferrer"><code>path.matchesGlob(path, pattern)</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathisabsolutepath" target="_blank" rel="noreferrer"><code>path.isAbsolute(path)</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathnormalizepath" target="_blank" rel="noreferrer"><code>path.normalize(path)</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathposix" target="_blank" rel="noreferrer"><code>path.posix</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathrelativefrom-to" target="_blank" rel="noreferrer"><code>path.relative(from, to)</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathsep" target="_blank" rel="noreferrer"><code>path.sep</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathtonamespacedpathpath" target="_blank" rel="noreferrer"><code>path.toNamespacedPath(path)</code></a></li><li><a href="https://nodejs.cn/api/path.html#pathwin32" target="_blank" rel="noreferrer"><code>path.win32</code></a></li></ul>',13)]))}const m=a(h,[["render",o]]);export{f as __pageData,m as default};
