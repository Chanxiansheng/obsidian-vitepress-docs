import{_ as l,c as a,o as i,ag as S}from"./chunks/framework.-ewJmwvT.js";const X=JSON.parse('{"title":"XSS","description":"","frontmatter":{},"headers":[],"relativePath":"计算机基础课程/网络/02 网络安全/XSS.md","filePath":"计算机基础课程/网络/02 网络安全/XSS.md"}'),r={name:"计算机基础课程/网络/02 网络安全/XSS.md"};function e(o,t,s,d,n,h){return i(),a("div",null,t[0]||(t[0]=[S('<h1 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;XSS&quot;">​</a></h1><h2 id="什么是-xss" tabindex="-1">什么是 XSS <a class="header-anchor" href="#什么是-xss" aria-label="Permalink to &quot;什么是 XSS&quot;">​</a></h2><p><strong>Cross-Site Scripting</strong>（跨站脚本攻击）简称 XSS，是一种<strong>代码注入攻击</strong>。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><p>所以，网页上哪些部分会引起 XSS 攻击？简单来说,任何可以输入的地方都有可能引起，包括 URL!</p><p>XSS 常见的注入方法：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> (伪协议) 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><h2 id="xss-攻击的分类" tabindex="-1">XSS 攻击的分类 <a class="header-anchor" href="#xss-攻击的分类" aria-label="Permalink to &quot;XSS 攻击的分类&quot;">​</a></h2><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><h3 id="反射型-xss" tabindex="-1">反射型 XSS <a class="header-anchor" href="#反射型-xss" aria-label="Permalink to &quot;反射型 XSS&quot;">​</a></h3><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS (也被称为非持久性 XSS) 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><h3 id="存储型-xss" tabindex="-1">存储型 XSS <a class="header-anchor" href="#存储型-xss" aria-label="Permalink to &quot;存储型 XSS&quot;">​</a></h3><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>存储型 XSS(又被称为持久性 XSS) 攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><p>它是最危险的一种跨站脚本，相比反射型 XSS 和 DOM 型 XSS 具有更高的隐蔽性，所以危害更大，因为<strong>它不需要用户手动触发</strong>。<strong>任何允许用户存储数据的 web 程序都可能存在存储型 XSS 漏洞</strong>，当攻击者提交一段 XSS 代码后，被服务器端接收并存储，当<strong>所有浏览者访问某个页面时都会被 XSS</strong>。</p><h3 id="dom-型-xss" tabindex="-1">DOM 型 XSS <a class="header-anchor" href="#dom-型-xss" aria-label="Permalink to &quot;DOM 型 XSS&quot;">​</a></h3><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><p><strong>注意:<strong>DOM 通常代表在 html、xhtml 和 xml 中的对象，使用 DOM 可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发 XSS</strong>靠的是浏览器端的DOM解析</strong>，所以防范<strong>DOM 型 XSS 完全就是前端的责任,必须注意!!!</strong>。</p><h3 id="对比" tabindex="-1"><strong>对比</strong> <a class="header-anchor" href="#对比" aria-label="Permalink to &quot;**对比**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>存储区</th><th>插入点</th></tr></thead><tbody><tr><td>存储型 XSS</td><td>后端数据库</td><td>HTML</td></tr><tr><td>反射型 XSS</td><td>URL</td><td>HTML</td></tr><tr><td>DOM 型 XSS</td><td>后端数据库/前端存储/URL</td><td>前端 JavaScript</td></tr></tbody></table><h2 id="如何防御-xss" tabindex="-1">如何防御 XSS <a class="header-anchor" href="#如何防御-xss" aria-label="Permalink to &quot;如何防御 XSS&quot;">​</a></h2><ul><li>xss 漏洞扫描工具 <ul><li>wvs</li><li>椰树</li><li>safe3</li><li>Xelenium</li><li>w3af —Kali / vega—Kali</li><li>burp</li></ul></li><li>常用防范方法 <ul><li>输入过滤<br> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li>转义 HTML<br> 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义，但这还不是很完善。想对 HTML 模板各处插入点进行充分的转义，就需要采用合适的转义库。</li><li>配置 CSP 规则<br> 在服务端生成 CSP 规则，以 HTTP 相应头的方式发送给浏览器</li></ul></li></ul>',29)]))}const c=l(r,[["render",e]]);export{X as __pageData,c as default};
