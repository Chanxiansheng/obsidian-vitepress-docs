import{_ as s,c as e,o as n,ag as a}from"./chunks/framework.-ewJmwvT.js";const l="/obsidian-vitepress-docs/assets/npm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-1.BrP-g-ze.png",m=JSON.parse('{"title":"npm 基础使用","description":"","frontmatter":{},"headers":[],"relativePath":"服务端/NodeJS/npm/npm基础使用.md","filePath":"服务端/NodeJS/npm/npm基础使用.md"}'),p={name:"服务端/NodeJS/npm/npm基础使用.md"};function o(t,i,d,c,r,h){return n(),e("div",null,i[0]||(i[0]=[a(`<h1 id="npm-基础使用" tabindex="-1">npm 基础使用 <a class="header-anchor" href="#npm-基础使用" aria-label="Permalink to &quot;npm 基础使用&quot;">​</a></h1><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">https://www.npmjs.com/</a></p></div><h2 id="npm-与包" tabindex="-1">npm 与包 <a class="header-anchor" href="#npm-与包" aria-label="Permalink to &quot;npm 与包&quot;">​</a></h2><ul><li>什么是 npm？</li></ul><p>npm，即 Node.js Package Manager，是一个用于 Node.js 的包管理器。通过该软件包管理器，开发者可以下载别人编写的代码包以及发布自己编写的代码包，并在项目中引用和使用这些包。</p><ul><li>npm 包是什么？</li></ul><p>npm 包实际上就是可以被复用的 Node.js 模块。这些模块可以是由其他开发者创建的，也可以是我们自己个人创建并且上传到 npm 上的。</p><h2 id="npm-install" tabindex="-1">npm install <a class="header-anchor" href="#npm-install" aria-label="Permalink to &quot;npm install&quot;">​</a></h2><ul><li><code>npm install</code> 是做什么的？</li></ul><p>通过 <code>npm install</code>，我们可以将一个或多个 npm 包安装到当前项目中。这样，在项目中就可以直接使用这些包，而不必担心依赖关系等问题。</p><div class="note custom-block github-alert"><p class="custom-block-title">npm install 的内部执行过程</p><p></p><h3 id="第一步-读取-package-json-文件" tabindex="-1">第一步：读取 package.json 文件 <a class="header-anchor" href="#第一步-读取-package-json-文件" aria-label="Permalink to &quot;第一步：读取 package.json 文件&quot;">​</a></h3><p>首先，npm 会读取当前项目中的 <code>package.json</code> 文件，该文件含有了所有相关的依赖和开发者信息。在 <code>package.json</code> 文件中，可以指定使用哪个版本的某个包。</p><h3 id="第二步-创建-node-modules-文件夹" tabindex="-1">第二步：创建 node_modules 文件夹 <a class="header-anchor" href="#第二步-创建-node-modules-文件夹" aria-label="Permalink to &quot;第二步：创建 node_modules 文件夹&quot;">​</a></h3><p>接下来，在 <code>package.json</code> 所在的目录下，npm 会自动创建一个名为 <code>node_modules</code> 的文件夹。</p><h3 id="第三步-下载依赖项" tabindex="-1">第三步：下载依赖项 <a class="header-anchor" href="#第三步-下载依赖项" aria-label="Permalink to &quot;第三步：下载依赖项&quot;">​</a></h3><p>当以上两个步骤完成后，npm 就开始执行真正的安装操作了。这时，它会根据 <code>package.json</code> 中定义的依赖信息，从 npm registry 上下载所有依赖项，并将它们放置到 <code>node_modules</code> 目录下。</p><p>值得注意的是，如果项目中的依赖项已经存在于本地缓存中，则 npm 会直接从本地缓存中拷贝这些依赖对象，而不是重新从 registry 上下载。这样做的好处是可以提高安装速度，同时避免重复下载相同版本的依赖包。</p><p>例如，我们使用以下命令来安装 jQuery：</p><p><code>$ npm install jquery --save-dev</code></p><p>那么，npm 就会检查 <code>package.json</code> 文件中所列出的依赖项，并将 jQuery 3.4.1 版本下载并安装到本地的 <code>node_modules/jquery</code> 目录下。</p><h3 id="第四步-解决依赖项" tabindex="-1">第四步：解决依赖项 <a class="header-anchor" href="#第四步-解决依赖项" aria-label="Permalink to &quot;第四步：解决依赖项&quot;">​</a></h3><p>通过上述步骤，我们成功下载并安装了我们使用到的依赖包。不过，我们的项目中还可能存在其他依赖项，这些依赖项也需要被安装到 <code>node_modules</code> 目录下。</p><p>具体来说，当 npm 发现项目中某个包依赖于另一个包时，它会检查该依赖包是否已经在本地缓存中。如果是，则会将该依赖项拷贝到该包的 <code>node_modules</code> 目录下；如果不是，则从 npm registry 上下载该包，并将其安装到本地缓存里。</p><p>例如，当前项目中使用了 <code>lodash</code> 和 <code>underscore.string</code> 两个包。其中，在 <code>package.json</code> 中，<code>lodash</code> 是直接被定义为项目的一个依赖，而 <code>underscore.string</code> 是被定义为 <code>lodash</code> 的一个依赖。那么，在执行 <code>npm install</code> 时，会按以下顺序进行依赖项的解决：</p><ol><li>首先，npm 会安装 <code>lodash</code> 包，并将其拷贝到 <code>node_modules/lodash</code> 中。</li><li>接着，当 npm 看到在 <code>package.json</code> 文件中定义了 <code>underscore.string</code> 的依赖项时，它会检查 <code>lodash</code> 是否已经被安装。此时，由于 <code>lodash</code> 已经被安装在了 <code>node_modules/lodash</code> 目录下，因此 npm 会继续安装并将 <code>underscore.string</code> 打包到 <code>node_modules/lodash/node_modules/underscore.string</code> 路径下。</li></ol><h3 id="第五步-执行-preinstall-脚本" tabindex="-1">第五步：执行 preinstall 脚本 <a class="header-anchor" href="#第五步-执行-preinstall-脚本" aria-label="Permalink to &quot;第五步：执行 preinstall 脚本&quot;">​</a></h3><p>在所有的依赖项被成功安装后，npm 可能会在默认情况下运行预安装钩子 (preinstall hook) 脚本，以确保所有依赖关系都已经被正确地安装。</p><p>如果有任何错误发生，npm 将会在这个阶段抛出异常，并停止执行 <code>npm install</code> 命令。</p><h3 id="第六步-执行-postinstall-脚本" tabindex="-1">第六步：执行 postinstall 脚本 <a class="header-anchor" href="#第六步-执行-postinstall-脚本" aria-label="Permalink to &quot;第六步：执行 postinstall 脚本&quot;">​</a></h3><p>当所有依赖关系已经被处理完毕后，npm 可根据需要运行一个或多个后安装钩子 (postinstall hook) 脚本，以执行任何定制化的项目初始化、配置或是构建任务等操作。</p><h3 id="第七步-生成-lockfile" tabindex="-1">第七步：生成 Lockfile <a class="header-anchor" href="#第七步-生成-lockfile" aria-label="Permalink to &quot;第七步：生成 Lockfile&quot;">​</a></h3><p>最后，npm 会在项目根目录下生成一个 <code>package-lock.json</code> 文件，该文件用于锁定该项目中所有依赖项的版本号。该文件可以帮助其他开发者在不同的主机或环境中重新创建和复制该项目时，确保使用的依赖项版本与原本一致。</p></div><h2 id="常用-cli-commands" tabindex="-1">常用 CLI Commands <a class="header-anchor" href="#常用-cli-commands" aria-label="Permalink to &quot;常用 CLI Commands&quot;">​</a></h2><div class="note custom-block github-alert"><p class="custom-block-title">Title</p><p><a href="https://docs.npmjs.com/cli/v6/commands" target="_blank" rel="noreferrer">CLI Commands | npm Docs</a></p></div><ul><li><p>install 安装</p><div class="language-TypeScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">TypeScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm install [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">package</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">spec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm install [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@scope</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>别名 <code>npm i</code>, <code>npm add</code> 等等<br> 常用可选符</p><ol><li><p><code>--save-dev</code> 简写 <code>-D</code><br> 表示当前安装的依赖是一个辅助开发的依赖包，只在开发环境才需要。<br> 依赖会添加到 <code>package.json</code> 下的 <code>devDependencies</code> 属性下。</p></li><li><p><code>--save</code> 简写 <code>-S</code><br> 表示当前安装的依赖是运行依赖（生产），意思是发布到生产环境后也是不可缺少的包。<br> 依赖会被添加到 <code>package.json</code> 下的 <code>dependencies</code> 属性下。</p></li><li><p><code>-global</code> 简写 <code>-g</code><br> 表示全局安装</p></li></ol></li><li><p>update 更新<br><code>npm update &lt;package_name&gt;</code></p></li><li><p>uninstall 卸载<br><code>npm uninstall &lt;package_name&gt;</code></p></li><li><p>init 初始化<br><code>npm init</code> 命令用来初始化一个简单的 package.json 文件，执行该命令后终端会依次询问 name, version, description 等字段。<br><code>npm init -y</code>。-y 参数表示 yes 的意思，在 <code>init</code> 的时候省去了多次敲回车的步骤，直接生成的默认的 package.json 文件。</p></li><li><p>ls 查看安装列表<br><code>npm ls</code></p></li></ul><h2 id="package-json" tabindex="-1">package.json <a class="header-anchor" href="#package-json" aria-label="Permalink to &quot;package.json&quot;">​</a></h2><ul><li>执行 <code>npm init</code> 后生成一个文件和一个文件夹：<strong>package.json</strong> 、 <strong>node_modules</strong>：</li><li>package.json 用来描述项目及项目所依赖的模块信息，安装包依赖关系都由 package.json 来管理，开发者几乎不必考虑它们，但是有必要了解 package.json 中各个字段的含义和使用方法。</li><li>配置项 <ul><li>name：项目/模块名称，长度必须小于等于 214 个字符，不能以 &quot;.&quot;(点) 或者 &quot;<em>&quot;(下划线) 开头，不能包含大写字母。</em></li><li>version：项目版本</li><li>author：项目开发者，它的值是你在 npmjs.org 网站的有效账户名，遵循“<code>账户名&lt;邮件&gt;</code>”的规则，例如:<code>zhangsan zhangsan@163.com</code>。</li><li>description：项目描述，是一个字符串。它可以帮助人们在使用 <code>npm search</code> 时找到这个包。</li><li>keywords：项目关键字，是一个字符串数组。它可以帮助人们在使用 <code>npm search</code> 时找到这个包。</li><li>private：是否私有，设置为 true 时，npm 拒绝发布。</li><li>license：软件授权条款，让用户知道他们的使用权利和限制。</li><li>bugs：bug 提交地址。</li><li>contributors：项目贡献者 。</li><li>repository：项目仓库地址。</li><li>homepage：项目包的官网 URL。</li><li>dependencies：生产环境下，项目运行所需依赖。</li><li>devDependencies：开发环境下，项目所需依赖。</li><li>scripts：执行 npm 脚本命令简写，比如 <code>“start”: “react-scripts start”</code>, 执行 npm start 就是运行 <code>“react-scripts start”</code>。</li><li>bin：内部命令对应的可执行文件的路径。</li><li>main：项目默认执行文件，比如 require(‘webpack’)；就会默认加载 lib 目录下的 webpack.js 文件，如果没有设置，则默认加载项目跟目录下的 index.js 文件。</li><li>module：是以 ES Module(也就是 ES6) 模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而 CommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有 module 字段，没有才使用 main 字段。</li><li>eslintConfig：EsLint 检查文件配置，自动读取验证。</li><li>engines：项目运行的平台/环境。</li><li>browserslist：供浏览器使用的版本列表。</li><li>style：供浏览器使用时，样式文件所在的位置；样式文件打包工具 parcelify，通过它知道样式文件的打包位置。</li><li>files：打包是被项目包含的文件名数组；</li></ul></li></ul><h2 id="npm-run-与-script" tabindex="-1">npm run 与 script <a class="header-anchor" href="#npm-run-与-script" aria-label="Permalink to &quot;npm run 与 script&quot;">​</a></h2><ul><li><p><code>npm run</code></p><p><code>npm run &lt;command&gt; [--silent] [-- &lt;args&gt;...]</code></p><p><code>npm run</code> 是一个执行 package.json 中 script 属性下脚本指令的命令。当执行 <code>npm run start</code> ，则映射为 <code>scripts</code> 属性下的 <code>start</code> 命令。</p></li><li><p>具体过程</p><div class="language-TypeScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">TypeScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node ./src/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;dev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vite&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上代码为例，srart 中直接执行了 &quot;<code>node ./src/index.js</code>&quot; 的脚本，比较简单，不再赘述。而 dev 中的 &quot;vite&quot; 相对较为复杂，下面进行详细解读。</p><p>当使用 vite 构建 Vue3 项目的时候，在 <code>node_modules/.bin</code> 文件夹下可以看到一系列的文件。<strong>vite 命令分别由三个文件组成，后缀.cmd 文件对应的是 window 的终端，后缀.ps1 对应 window 的 PowerShell，没有后缀名的文件对应的是 linux 版本。</strong></p></li></ul><p><img src="`+l+`" alt=""></p><p>当使用 <code>npm run dev </code> 执行 <code>vite</code> 时，虽然没有安装 vite 的全局命令，但是 <code>npm</code> 会到 <code>./node_modules/.bin</code> 中找到 <code>vite.cmd</code> 文件。查看该文件：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@ECHO</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> off</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GOTO</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:find_dp0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dp0=%~dp0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EXIT</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /b</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:start</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SETLOCAL</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CALL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :find_dp0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IF</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> EXIST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;%dp0%\\node.exe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  SET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;_prog=%dp0%\\node.exe&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ELSE (</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  SET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;_prog=node&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  SET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PATHEXT=%PATHEXT:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.JS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">endLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">goto</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #_undefined_# 2&gt;NUL || title %COMSPEC% &amp; &quot;%_prog%&quot;  &quot;%dp0%\\..\\vite\\bin\\vite.js&quot; %*</span></span></code></pre></div><p>我们发现，该文件又调用了 <code>\\vite\\bin\\vite.js</code> 这个 js 文件。至此，实际上 <code>npm run dev</code> 执行的就是 <code>node vite.js</code> ，当然这同时会附带上一些参数。</p><p>总结，当 npm i 的时候，npm 就帮我们把这种<strong>软连接</strong>配置好了，其实这种软连接相当于一种映射，执行 <code>npm run xxx</code> 的时候，就会到 <code>node_modules/bin</code> 中找对应的映射文件，然后再找到相应的 js 文件来执行。</p><h2 id="包的制作与发布" tabindex="-1">包的制作与发布 <a class="header-anchor" href="#包的制作与发布" aria-label="Permalink to &quot;包的制作与发布&quot;">​</a></h2><ol><li><p>配置 package.json 执行脚本，发布项等<br> 在 <code>package.json</code> 文件的 <code>main</code> 字段中配置引入包的入口文件，一般配置打包后的文件路径。</p><p><code>file</code> 字段可以指定需要打包的文件或文件夹。</p></li><li><p>注册与登录</p><ul><li>创建账户 <code>npm adduser</code> (注意使用官方源）</li><li>登录 <code>npm login</code></li></ul></li><li><p>发布 <code>npm publish</code></p></li></ol><h2 id="配置镜像源" tabindex="-1">配置镜像源 <a class="header-anchor" href="#配置镜像源" aria-label="Permalink to &quot;配置镜像源&quot;">​</a></h2><ul><li><p>临时使用<br> 在 npm install XXX 时加入 --registry URL 即可，不会影响到本地配置，如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\`npm --registry https://registry.npmmirror.com install express \`</span></span></code></pre></div></li><li><p>持久使用 永久修改本地 npm 的配置：</p><ul><li>阿里源 <ul><li><code>npm config set registry https://registry.npmmirror.com</code></li></ul></li><li>淘宝源 (已下线） <ul><li><code>npm config set registry https://registry.npm.taobao.org/</code></li></ul></li></ul></li><li><p>查看 npm 源地址：<br><code>npm config get registry</code></p></li><li><p>重置为官方源：<br><code>npm config delete registry</code><br><code>npm config set registry https://registry.npmjs.org/</code></p></li></ul><h2 id="npx" tabindex="-1">npx <a class="header-anchor" href="#npx" aria-label="Permalink to &quot;npx&quot;">​</a></h2><ul><li><p>什么是 npx</p><ul><li><strong>npx 是一个工具</strong>，npm v5.2.0 引入的一条命令（npx），一个 npm 包执行器，<strong>旨在提高从 npm 注册表使用软件包的体验</strong> ，npm 使得它非常容易地安装和管理托管在注册表上的依赖项，npx 使得使用 CLI 工具和其他托管在注册表。加强用户的体验。</li><li>npx 通俗地来讲就是执行 <code>node_modules/bin/可执行文件的</code> 在 node5 之后，npm 就和 npx 捆绑在一起了。</li></ul></li><li><p>原理<br> 就是运行的时候，会到 node_modules/.bin 路径和环境变量 $PATH 里面，检查命令是否存在。</p></li><li><p>特点</p><ol><li>临时安装可执行依赖包，不用全局安装，不用担心长期的污染。</li><li><strong>可以执行依赖包中的命令，安装完成自动运行</strong>。</li><li>自动加载 node_modules 中依赖包，不用指定 $PATH。</li><li>可以指定 node 版本、命令的版本，解决了不同项目使用不同版本的命令的问题。</li></ol></li><li><p>与 npm 的区别<br> - npx 侧重于执行这个包<br> - npm 侧重安装与卸载这个包。但 npm 可以通过 scripts 配置来达到 npx 的效果</p></li><li><p>例子<br> vite 构建的 Vue3 项目中，当执行 <code>npm run dev</code> 时，实际执行的是 package.json 下 script 字段中 dev 的值 vite build，这是，可以直接使用 <code>npx vite build</code> 执行。</p></li></ul><h2 id="拓展-pnpm" tabindex="-1">拓展：pnpm <a class="header-anchor" href="#拓展-pnpm" aria-label="Permalink to &quot;拓展：pnpm&quot;">​</a></h2><div class="note custom-block github-alert"><p class="custom-block-title">Title</p><p><a href="https://www.pnpm.cn/" target="_blank" rel="noreferrer">https://www.pnpm.cn/</a></p></div><ul><li><p>什么是 pnpm</p><p>什么是 pnpm，pnpm 是新一代包管理工具，为什么叫 pnpm 呢，是因为 pnpm 作者对现有的包管理工具，尤其是 npm 和 yarn 的性能特别失望，所以起名叫做 performance npm，即 pnpm（高性能 npm）</p></li><li><p>npm 存在的问题</p><p>同样的依赖会复制多次，并且路径过长在 windows 下有问题。</p></li><li><p>link</p><p>link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。</p><p>如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？</p><p>这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。</p><p>pnpm 就是通过这种思路来实现的。</p></li><li><p>特点</p><ul><li>快速—pnpm 是同类工具速度的将近 2 倍</li><li>高效—node_modules 中的所有文件均克隆或硬链接自单一存储位置</li><li>支持单体仓库—pnpm 内置了对单个源码仓库中包含多个软件包的支持</li><li>权限严格—pnpm 创建的 node_modules 默认并非扁平结构，因此代码无法对任意软件包进行访问</li></ul></li><li><p>安装<br><code>npm install -g pnpm</code></p></li></ul><h2 id="拓展-nvm—node-版本控制" tabindex="-1">拓展：nvm—node 版本控制 <a class="header-anchor" href="#拓展-nvm—node-版本控制" aria-label="Permalink to &quot;拓展：nvm—node 版本控制&quot;">​</a></h2><ul><li><p>nvm 是 node 版本管理器，用于管理多个活动 Node.js 版本的简单 bash 脚本，让我们可以设置默认 node 版本，并在不同开发环境中切换不同版本。</p></li><li><p>安装<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noreferrer">https://github.com/coreybutler/nvm-windows/releases</a></p></li><li><p>常用命令</p><ul><li><code>nvm arch [32|64]</code>：显示 node 是运行在 32 位还是 64 位。</li><li><code>nvm current</code>： 显示活动版本。</li><li><code>nvm install &lt;version&gt; [arch]</code>：安装 node， version 是特定版本也可以是最新稳定版本 latest。可选参数 arch 指定安装 32 位还是 64 位版本，默认是系统位数。可以添加 --insecure 绕过 - 远程服务器的 SSL。</li><li><code>nvm list [available]</code>：显示已安装的列表。可选参数 available，显示可安装的所有版本。list 可简化为 ls。</li><li><code>nvm on</code>：开启 node.js 版本管理。</li><li><code>nvm off</code>：关闭 node.js 版本管理。</li><li><code>nvm proxy [url]</code>：设置下载代理。不加可选参数 url，显示当前代理。将 url 设置为 none 则移除代理。</li><li><code>nvm uninstall &lt;version&gt;</code>：卸载指定版本 node。</li><li><code>nvm use [version] [arch]</code>：使用制定版本 node。可指定 32/64 位。</li><li><code>nvm root [path]</code>：设置存储不同版本 node 的目录。如果未设置，默认使用当前目录。</li><li><code>nvm version</code>：显示 nvm 版本。version 可简化为 v。</li><li><code>nvm node_mirror [node_mirror_url]</code>：设置 node 镜像。默认是 <code>https://nodejs.org/dist/</code>。如果不写 url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。</li><li><code>nvm npm_mirror [npm_mirror_url]</code>：设置 npm 镜像。默认是 <code>https://github.com/npm/cli/archive/</code>。如果不写 url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。</li></ul></li><li><p>理清 <code>node</code>、<code>nvm</code>、<code>npm</code>、<code>npx</code>、<code>nrm</code> 关系</p><p><code>nvm</code> 管理 <code>node</code> (包含 <code>npm</code> 与 <code>npx</code>) 的版本<br><code>npm</code> 管理 <code>node</code> 的第三方插件<br><code>nrm</code> 管理 <code>npm</code> 的源地址</p></li></ul>`,34)]))}const u=s(p,[["render",o]]);export{m as __pageData,u as default};
